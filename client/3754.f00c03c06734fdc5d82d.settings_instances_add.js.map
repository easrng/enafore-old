{"version":3,"file":"3754.f00c03c06734fdc5d82d.settings_instances_add.js","mappings":"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","sources":["webpack:///./src/routes/_api/oauth.js","webpack:///./src/routes/_static/blocks.js","webpack:///./src/routes/_actions/addInstance.js","webpack:///./src/routes/_pages/settings/instances/add.html","webpack:///./src/routes/settings/instances/add.html","webpack:///./src/routes/_actions/emoji.js","webpack:///./src/routes/_api/emoji.js","webpack:///./src/routes/_api/user.js","webpack:///./src/routes/_utils/sync.js"],"sourcesContent":["import { post, paramsString, WRITE_TIMEOUT } from '../_utils/ajax.js'\nimport { basename } from './utils.js'\n\nconst WEBSITE = 'https://pinafore.easrng.net'\nconst SCOPES = 'read write follow push'\n\nexport function registerApplication (instanceName, redirectUri) {\n  const url = `${basename(instanceName)}/api/v1/apps`\n  return post(url, {\n    client_name: process.env.UPSTREAM ? 'Enafore' : process.browser ? location.hostname : 'Enafore',\n    redirect_uris: redirectUri,\n    scopes: SCOPES,\n    website: process.browser ? location.origin : WEBSITE\n  }, null, { timeout: WRITE_TIMEOUT })\n}\n\nexport function generateAuthLink (instanceName, clientId, redirectUri) {\n  const params = paramsString({\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    response_type: 'code',\n    scope: SCOPES\n  })\n  return `${basename(instanceName)}/oauth/authorize?${params}`\n}\n\nexport function getAccessTokenFromAuthCode (instanceName, clientId, clientSecret, code, redirectUri) {\n  const url = `${basename(instanceName)}/oauth/token`\n  // Using URLSearchParams here guarantees a content type of application/x-www-form-urlencoded\n  // See https://fetch.spec.whatwg.org/#bodyinit-unions\n  return post(url, new URLSearchParams({\n    client_id: clientId,\n    client_secret: clientSecret,\n    redirect_uri: redirectUri,\n    grant_type: 'authorization_code',\n    code\n  }), null, { timeout: WRITE_TIMEOUT })\n}\n","export const DOMAIN_BLOCKS = [\n  'gab.com',\n  'gab.ai'\n]\n","import { getAccessTokenFromAuthCode, registerApplication, generateAuthLink } from '../_api/oauth.js'\nimport { getInstanceInfo } from '../_api/instance.js'\nimport { goto } from '../../../__sapper__/client.js'\nimport { DEFAULT_THEME, switchToTheme } from '../_utils/themeEngine.js'\nimport { store } from '../_store/store.js'\nimport { updateVerifyCredentialsForInstance } from './instances.js'\nimport { updateCustomEmojiForInstance } from './emoji.js'\nimport { database } from '../_database/database.js'\nimport { DOMAIN_BLOCKS } from '../_static/blocks.js'\n\nconst GENERIC_ERROR = `\n  Is this a valid Mastodon instance? Is a browser extension\n  blocking the request? Are you in private browsing mode?\n  If you believe this is a problem with your instance, please send\n  <a href=\"https://github.com/easrng/enafore/blob/main/docs/Admin-Guide.md\"\n    target=\"_blank\" rel=\"noopener\">this link</a> to the administrator of your instance.`\n\nfunction createKnownError (message) {\n  const err = new Error(message)\n  err.knownError = true\n  return err\n}\n\nfunction getRedirectUri () {\n  return `${location.origin}/settings/instances/add`\n}\n\nasync function redirectToOauth () {\n  let { instanceNameInSearch, loggedInInstances } = store.get()\n  instanceNameInSearch = instanceNameInSearch.replace(/^https?:\\/\\//, '').replace(/\\/+$/, '').toLowerCase()\n  if (Object.keys(loggedInInstances).includes(instanceNameInSearch)) {\n    throw createKnownError(`You've already logged in to ${instanceNameInSearch}`)\n  }\n  const instanceHostname = new URL(`http://${instanceNameInSearch}`).hostname\n  if (DOMAIN_BLOCKS.some(domain => new RegExp(`(?:\\\\.|^)${domain}$`, 'i').test(instanceHostname))) {\n    throw createKnownError('This service is blocked')\n  }\n  const redirectUri = getRedirectUri()\n  const registrationPromise = registerApplication(instanceNameInSearch, redirectUri)\n  try {\n    const instanceInfo = await getInstanceInfo(instanceNameInSearch)\n    await database.setInstanceInfo(instanceNameInSearch, instanceInfo) // cache for later\n  } catch (err) {\n    // We get a 401 in limited federation mode, so we can just skip setting the instance info in that case.\n    // It will be fetched automatically later.\n    if (err.status !== 401) {\n      throw err // this is a good way to test for typos in the instance name or some other problem\n    }\n  }\n  const instanceData = await registrationPromise\n  store.set({\n    currentRegisteredInstanceName: instanceNameInSearch,\n    currentRegisteredInstance: instanceData\n  })\n  store.save()\n  const oauthUrl = generateAuthLink(\n    instanceNameInSearch,\n    instanceData.client_id,\n    redirectUri\n  )\n  // setTimeout to allow the browser to *actually* save the localStorage data (fixes Safari bug apparently)\n  setTimeout(() => {\n    document.location.href = oauthUrl\n  }, 200)\n}\n\nexport async function logInToInstance () {\n  store.set({\n    logInToInstanceLoading: true,\n    logInToInstanceError: null\n  })\n  try {\n    await redirectToOauth()\n  } catch (err) {\n    console.error(err)\n    const error = `${err.message || err.name}. ` +\n      (err.knownError ? '' : (navigator.onLine ? GENERIC_ERROR : 'Are you offline?'))\n    const { instanceNameInSearch } = store.get()\n    store.set({\n      logInToInstanceError: error,\n      logInToInstanceErrorForText: instanceNameInSearch\n    })\n  } finally {\n    store.set({ logInToInstanceLoading: false })\n  }\n}\n\nasync function registerNewInstance (code) {\n  const { currentRegisteredInstanceName, currentRegisteredInstance } = store.get()\n  const redirectUri = getRedirectUri()\n  const instanceData = await getAccessTokenFromAuthCode(\n    currentRegisteredInstanceName,\n    currentRegisteredInstance.client_id,\n    currentRegisteredInstance.client_secret,\n    code,\n    redirectUri\n  )\n  const { loggedInInstances, loggedInInstancesInOrder, instanceThemes } = store.get()\n  instanceThemes[currentRegisteredInstanceName] = DEFAULT_THEME\n  loggedInInstances[currentRegisteredInstanceName] = instanceData\n  if (!loggedInInstancesInOrder.includes(currentRegisteredInstanceName)) {\n    loggedInInstancesInOrder.push(currentRegisteredInstanceName)\n  }\n  store.set({\n    instanceNameInSearch: '',\n    currentRegisteredInstanceName: null,\n    currentRegisteredInstance: null,\n    loggedInInstances,\n    currentInstance: currentRegisteredInstanceName,\n    loggedInInstancesInOrder,\n    instanceThemes\n  })\n  store.save()\n  const { enableGrayscale } = store.get()\n  switchToTheme(DEFAULT_THEME, enableGrayscale)\n  // fire off these requests so they're cached\n  /* no await */ updateVerifyCredentialsForInstance(currentRegisteredInstanceName)\n  /* no await */ updateCustomEmojiForInstance(currentRegisteredInstanceName)\n  goto('/')\n}\n\nexport async function handleOauthCode (code) {\n  try {\n    store.set({ logInToInstanceLoading: true })\n    await registerNewInstance(code)\n  } catch (err) {\n    store.set({ logInToInstanceError: `${err.message || err.name}. Failed to connect to instance.` })\n  } finally {\n    store.set({ logInToInstanceLoading: false })\n  }\n}\n","<SettingsLayout page='settings/instances/add' label={pageLabel}>\n  <h1 id=\"add-an-instance-h1\">{pageLabel}</h1>\n\n  <div class=\"add-new-instance\">\n    <form on:submit='onSubmitInstance(event)' aria-labelledby=\"add-an-instance-h1\">\n\n      {#if !hasIndexedDB || !hasLocalStorage}\n        <div class=\"form-error form-error-user-error\" role=\"alert\">\n          It seems Enafore cannot store data locally. Is your browser in private mode or blocking cookies? Enafore stores all data locally, and requires LocalStorage and IndexedDB to work correctly.\n        </div>\n      {/if}\n\n      {#if $logInToInstanceError && $logInToInstanceErrorForText === $instanceNameInSearch}\n        <div class=\"form-error form-error-user-error\" role=\"alert\">\n          Error: {@html $logInToInstanceError}\n        </div>\n      {/if}\n\n      <noscript>\n        <div class=\"form-error\" role=\"alert\">\n          You must enable JavaScript to log in.\n        </div>\n      </noscript>\n\n      <label for=\"instanceInput\">Instance:</label>\n      <input type=\"text\" inputmode=\"url\" autocapitalize=\"none\" spellcheck=\"false\" id=\"instanceInput\"\n             bind:value='$instanceNameInSearch' placeholder=\"Enter instance name\" required\n      >\n      <button class=\"primary\" type=\"submit\" id=\"submitButton\"\n              disabled={!$instanceNameInSearch || $logInToInstanceLoading}>\n        Log in\n      </button>\n    </form>\n  </div>\n\n  {#if !$isUserLoggedIn}\n    <p>\n      Don't have an\n      <Tooltip\n        text=\"instance\"\n        tooltipText=\"An instance is your Mastodon home server, such as mastodon.social or cybre.space.\"\n      />\n      ?\n      <a rel=\"noopener\" target=\"_blank\" href=\"https://joinmastodon.org\">Join Mastodon!</a>\n    </p>\n  {/if}\n</SettingsLayout>\n<style>\n  .add-new-instance {\n    background: var(--form-bg);\n    padding: 5px 10px 15px;\n    margin: 20px auto;\n    border: 1px solid var(--form-border);\n    border-radius: 4px;\n  }\n\n  .form-error {\n    border: 2px solid var(--warn-color);\n    border-radius: 2px;\n    padding: 10px;\n    font-size: 1.3em;\n    margin: 5px;\n    background-color: var(--main-bg);\n  }\n  input {\n    min-width: 70%;\n    max-width: 100%;\n    background-color: var(--input-bg);\n  }\n\n  label, input, button, :global(.add-new-instance-aside) {\n    display: block;\n    margin: 20px 5px;\n  }\n\n  @media (max-width: 767px) {\n    input {\n      min-width: 95%;\n    }\n  }\n\n</style>\n<script>\n  import SettingsLayout from '../../../_components/settings/SettingsLayout.html'\n  import { store } from '../../../_store/store.js'\n  import { logInToInstance, handleOauthCode } from '../../../_actions/addInstance.js'\n  import { testHasIndexedDB, testHasLocalStorage } from '../../../_utils/testStorage.js'\n  import Tooltip from '../../../_components/Tooltip.html'\n\n  export default {\n    async oncreate () {\n      const params = new URLSearchParams(location.search)\n      const code = params.get('code')\n      if (code) {\n        await handleOauthCode(code)\n      } else {\n        this.set({\n          hasIndexedDB: await testHasIndexedDB(),\n          hasLocalStorage: testHasLocalStorage()\n        })\n      }\n    },\n    components: {\n      SettingsLayout,\n      Tooltip\n    },\n    store: () => store,\n    data: () => ({\n      hasIndexedDB: true,\n      hasLocalStorage: true\n    }),\n    computed: {\n      pageLabel: ({ $isUserLoggedIn }) => $isUserLoggedIn ? \"Add instance\" : \"Log in\"\n    },\n    methods: {\n      onSubmitInstance (event) {\n        event.preventDefault()\n        event.stopPropagation()\n        logInToInstance()\n      }\n    }\n  }\n</script>\n","<Title name={titleName} settingsPage={true} />\n\n  <LazyPage {pageComponent} {params} />\n\n<script>\n  import Title from '../../_components/Title.html'\n  import LazyPage from '../../_components/LazyPage.html'\n  import pageComponent from '../../_pages/settings/instances/add.html'\n\n  export default {\n    components: {\n\n      Title,\n      LazyPage\n    },\n    data: () => ({\n      pageComponent\n    }),\n    computed: {\n      titleName: ({ $isUserLoggedIn }) => $isUserLoggedIn ? \"Add instance\" : \"Log in\"\n    }\n  }\n</script>\n","import {\n  cacheFirstUpdateAfter,\n  cacheFirstUpdateOnlyIfNotInCache\n} from '../_utils/sync.js'\nimport { database } from '../_database/database.js'\nimport { getCustomEmoji } from '../_api/emoji.js'\nimport { store } from '../_store/store.js'\nimport { isEqual } from '../_thirdparty/lodash/objects.js'\n\nasync function syncEmojiForInstance (instanceName, syncMethod) {\n  await syncMethod(\n    () => {\n      const { loggedInInstances } = store.get()\n      const accessToken = loggedInInstances[instanceName].access_token\n      return getCustomEmoji(instanceName, accessToken)\n    },\n    () => database.getCustomEmoji(instanceName),\n    emoji => database.setCustomEmoji(instanceName, emoji),\n    emoji => {\n      const { customEmoji } = store.get()\n      if (!isEqual(customEmoji[instanceName], emoji)) { // avoid triggering updates if nothing's changed\n        customEmoji[instanceName] = emoji\n        store.set({ customEmoji })\n      }\n    }\n  )\n}\n\nexport async function updateCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n\nexport function insertEmoji (realm, emoji) {\n  const emojiText = emoji.unicode || `:${emoji.name}:`\n  const { composeSelectionStart } = store.get()\n  const idx = composeSelectionStart || 0\n  const oldText = store.getComposeData(realm, 'text') || ''\n  const pre = oldText.substring(0, idx)\n  const post = oldText.substring(idx)\n  const newText = `${pre}${emojiText} ${post}`\n  store.setComposeData(realm, { text: newText })\n}\n","import { auth, basename } from './utils.js'\nimport { DEFAULT_TIMEOUT, get } from '../_utils/ajax.js'\n\nexport function getCustomEmoji (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/custom_emojis`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","import { get, DEFAULT_TIMEOUT } from '../_utils/ajax.js'\nimport { auth, basename } from './utils.js'\n\nexport function getVerifyCredentials (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/accounts/verify_credentials`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function getAccount (instanceName, accessToken, accountId) {\n  const url = `${basename(instanceName)}/api/v1/accounts/${accountId}`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n"],"names":["SCOPES","DOMAIN_BLOCKS","createKnownError","message","err","Error","knownError","getRedirectUri","location","origin","async","redirectToOauth","instanceNameInSearch","loggedInInstances","store","get","replace","toLowerCase","Object","keys","includes","instanceHostname","URL","hostname","some","domain","RegExp","test","redirectUri","registrationPromise","instanceName","url","client_name","redirect_uris","scopes","website","timeout","registerApplication","instanceInfo","database","setInstanceInfo","status","instanceData","set","currentRegisteredInstanceName","currentRegisteredInstance","save","oauthUrl","clientId","params","client_id","redirect_uri","response_type","scope","generateAuthLink","setTimeout","document","href","registerNewInstance","code","clientSecret","URLSearchParams","client_secret","grant_type","getAccessTokenFromAuthCode","loggedInInstancesInOrder","instanceThemes","push","currentInstance","enableGrayscale","onSubmitInstance","event","preventDefault","stopPropagation","logInToInstanceLoading","logInToInstanceError","console","error","name","navigator","onLine","logInToInstanceErrorForText","logInToInstance","search","handleOauthCode","this","hasIndexedDB","hasLocalStorage","$logInToInstanceError","$logInToInstanceErrorForText","$instanceNameInSearch","$isUserLoggedIn","pageLabel","$logInToInstanceLoading","pageComponent","titleName","syncEmojiForInstance","syncMethod","accessToken","access_token","getCustomEmoji","emoji","setCustomEmoji","customEmoji","updateCustomEmojiForInstance","setupCustomEmojiForInstance","insertEmoji","realm","emojiText","unicode","composeSelectionStart","idx","oldText","getComposeData","newText","substring","setComposeData","text","getVerifyCredentials","getAccount","accountId","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","fetchAndUpdatePromise","then","networkResponse","cacheFirstUpdateOnlyIfNotInCache"],"sourceRoot":""}
{"version":3,"file":"9456.e96297fa81d7c9577c5c.9456.js","mappings":"4TAGaA,WAAa,E,wEAAbA,WAAa,M,wOAFbA,WAAa,E,wEAAbA,WAAa,M,0NADX,I,EAAVC,MAAW,E,4cCyEhB,MAAQC,EAA+B,I,MA0B1B,CACPC,QAAO,KACP,eAAAC,CAAiBC,GACfA,EAAEC,iBACFD,EAAEE,kBACF,MAAM,gBAAEC,EAAe,gBAAEC,GAAoBC,KAAKC,MAAMC,OACzC,QAAiCJ,EAAiBC,GAEjE,IAEE,MAAMI,EAAmBC,SAASC,cAAc,iBAAiBC,SAChDH,EAAiBA,EAAiBI,OAAS,GACnDF,cAAc,WAAWG,OACxC,CAAM,MAAOb,GACPc,QAAQC,MAAMf,EACpB,CACF,G,aArCI,IAAIgB,EAEJX,KAAKP,QAAQ,eAAemB,IACtBA,EACFD,EAAgCE,YAAW,KACzCF,OAAgCG,GAChC,EAAAC,EAAA,GAAuB,gBAAe,GACrCvB,GACMmB,GACTK,aAAaL,EACnB,GAEJ,C,mDACiBV,EAAA,E,mtCApFS,GAAE,UAAWW,a,8DAUjBlB,gBAAgBuB,E,8zBAhBPL,YAAc,QAAU,IAAE,kB,2BACpC,EAAAA,c,8FAUSM,eAAiB,QAAU,IAAE,kB,2BACtC,EAAAA,gB,mCAbOC,MAAQ,GAAK,UAAQ,gB,uMAOVP,a,sDANRA,YAAc,QAAU,IAAE,oB,sCACpC,EAAAA,e,yEAUSM,eAAiB,QAAU,IAAE,oB,yCACtC,EAAAA,kB,gEAbOC,MAAQ,GAAK,UAAQ,oB,oiBA2EjD,UAkBc,qBAAEC,EAAoB,eAAEC,EAAc,uBAAEC,I,OAC9CF,IAAyBE,GAA0BD,E,0FAEvC,eAAEA,I,OAAqBA,C,kIACpB,eAAEA,EAAc,uBAAEC,I,OAA8BD,GAAkBC,C,4DChF5E,CACP,OAAAC,CAASN,GACP,MAAM,QAAEM,GAAYvB,KAAKE,MACrBqB,GACFA,EAAQN,EAEhB,G,waAtBgDM,QAAQN,E,gEACrDO,e,iJAAAA,e,mPAAAA,c,8VAwBiB,MAAEC,I,OAChB,EAAAC,EAAA,GAAW,CAAC,QAAQ,CAAC,SAAS,SAAU,CAAED,S,oLC3B/BE,aAAaF,MAAK,UAChBE,aAAaJ,S,0JADfI,aAAaF,O,6BACXE,aAAaJ,S,gPCKlC,IAAIK,EACJ,SAASC,IAIP,OAHKD,IACHA,EAAiBxB,SAAS0B,eAAe,aAEpCF,EAAeG,YACxB,CAYO,SAASC,EAA0BC,GACxC,MAAMC,GAAe,UACfC,EAAaN,IACnB,IAAIO,GAAS,EACTC,GAAiB,EACrB,MAAMC,EAAML,EAAS1B,OACrB,IAAIgC,GAAK,EACT,OAASA,EAAID,GAAK,CAChB,MAAME,EAAUP,EAASM,GACzB,IAAKC,EACH,SAEF,MAAMC,EAAOD,EAAQE,wBACrB,GAAID,EAAKE,IAAMT,GAAgBO,EAAKG,QAAUT,EAAY,CACxDC,EAAQG,EACRF,EAAiBI,EAAKE,IAAMR,GAAcI,EAAKD,EAAM,EAAMC,EAAI,EAAIA,EACnE,KACF,CACF,CACA,MAAO,CAAEH,QAAOC,gBAClB,C,wBC5BA,MAEQQ,EAAeC,GAAO1C,SAAS0B,eAAegB,GAC9CC,EAAeP,GAAWA,EAAQQ,aAAa,MAC/CC,EAAQ,S,MA0BH,CACP,SAAAC,CAAWjC,GACT,GA1BoBA,KAGxB,MAAM,OAAEkC,EAAM,IAAEL,GAAQ7B,EAKxB,OAJgBkC,GACG,UAAnBA,EAAOC,SACS,UAAhBD,EAAOE,OACiB,YAARP,GAA6B,cAARA,EACnBQ,EAkBVC,CAAkBtC,GACpB,OAEF,GAAkB,MAAdA,EAAM6B,KAAe9C,KAAKC,MAAMC,MAAMH,gBAAgByD,WAAW,WAAY,CAE/EvC,EAAMpB,kBACNoB,EAAMrB,iBACN,MAAM,cAAE6D,GAAkBzD,KAAKE,MAG/B,OAFA,OAAK,qBAAsBuD,QAC3BzD,KAAK0D,IAAI,CAAED,eAAgBA,GAEjC,CACI,GAAkB,MAAdxC,EAAM6B,KAA6B,cAAd7B,EAAM6B,IAI7B,OAHA7B,EAAMpB,kBACNoB,EAAMrB,sBACNI,KAAK2D,iBAAiB,EAAG1C,EAAM2C,WAGjC,GAAkB,MAAd3C,EAAM6B,KAA6B,YAAd7B,EAAM6B,IAI7B,OAHA7B,EAAMpB,kBACNoB,EAAMrB,sBACNI,KAAK2D,kBAAkB,EAAG1C,EAAM2C,WAGlC,IAAIC,EAAgB7D,KAAK8D,gBAAgB7C,EAAM2C,WAC/C,IAAKC,EAAe,CAClB,MAAM,SAAE5B,GAAajC,KAAKE,MACpB6D,EAAQ/B,EAAyBC,GAAUG,MAC7C2B,GAAS,IACXF,EAAgBd,EAAad,EAAS8B,IAE9C,CACQF,IACF,QAAyBA,EAAe5C,EAEhD,EACI,gBAAA0C,CAAkBK,EAAUJ,GAC1B,MAAM,SAAE3B,GAAajC,KAAKE,MAC1B,IAAI6D,GAAS,EACTF,EAAgB7D,KAAK8D,gBAAgBF,GACzC,GAAIC,EAAe,CACjB,MAAMvB,EAAML,EAAS1B,OACrB,IAAIgC,GAAK,EACT,OAASA,EAAID,GACX,GAAIS,EAAad,EAASM,MAAQsB,EAAe,CAC/CE,EAAQxB,EACR,KACN,CAEJ,CACI,GAAc,IAAVwB,IAA6B,IAAdC,EAIjB,OAHAH,EAAgB,KAChB7D,KAAK0D,IAAI,CAAEG,uBACX,EAAAI,EAAA,IAAa,UAAsB,GAAoB,GAAwB,GAGjF,IAAe,IAAXF,EAAc,CAChB,MAAM,MAAE3B,EAAK,cAAEC,GAAkBL,EAAyBC,GAC1D8B,EAASC,EAAW,EAAK3B,EAAgBD,CAC/C,MACM2B,GAASC,EAEPD,GAAS,GAAKA,EAAQ9B,EAAS1B,SACjCsD,EAAgBd,EAAad,EAAS8B,IACtC/D,KAAKkE,cAAcL,EAAeD,GDlErC,SAAiCpB,GACtC,MAAMC,EAAOD,EAAQE,wBACfP,EAAaN,IACbK,GAAe,UACrB,IAAIiC,EAAU,EACd,GAAI1B,EAAKE,IAAMR,EACbgC,EAAUhC,MACL,MAAIM,EAAKG,OAASV,GAUvB,OAVqC,CACrC,MAAMkC,EAAS3B,EAAKG,OAASH,EAAKE,IAEhCwB,EADGjC,EAAeC,EAAciC,EACtBlC,EAAekC,EAIfjC,CAEd,CAEA,CACA,MAAMkC,GAAkB,UAClBC,EAAYD,EAAgBC,WAClC,EAAAL,EAAA,GAAaI,EAAiBC,EAAY7B,EAAKE,IAAMwB,GAA0B,GAAwB,EACzG,CC6CUI,CAAuB1B,EAAagB,IAE5C,EACI,eAAAC,CAAiBF,GACf,MAAMY,EAAgBpE,SAASoE,cAC/B,IAAKA,EACH,OAAO,KAIT,MAAMC,EAAgBD,EAAcE,QAAQ,WAC5C,IAAKD,EACH,OAAO,KAET,MAAME,EAAaF,EAAczB,aAAa,MAC9C,IAAK2B,EACH,OAAO,KAET,MAAM,qBAAEC,GAAyB5E,KAAKE,MACtC,OAAK0D,EAAYgB,EApHW,MDF7B,SAAoBpC,GACzB,IAAKA,EACH,OAAO,EAET,MAAMC,EAAOD,EAAQE,wBACfR,GAAe,UACfC,EAAaN,IACnB,OAAOY,EAAKE,IAAMT,GAAgBO,EAAKG,QAAUT,CACnD,CC+Ga0C,CAAUhC,EAAa8B,KAC1B3E,KAAKkE,cAAc,KAAM,GAClB,MAEFS,CACb,EACI,aAAAT,CAAepB,EAAKc,GAClB5D,KAAK0D,IAAI,CAAEkB,qBAAsBhB,IACjC,IACEf,EAAaC,GAAKtC,MAAM,CACtBsE,eAAe,GAEvB,CAAM,MAAOC,GACPtE,QAAQC,MAAM,sBAAuBqE,EAC3C,CACF,G,cA3GI,QAAoB9B,EAAOjD,KACjC,C,cAEM,QAAuBiD,EAAOjD,KACpC,C,6CANiBC,EAAA,E,qBALA,CACX2E,qBAAsB,EACtB3C,SAAU7B,SAAS4E,uBAAuB,sBAC1CvB,eAAe,G,shBCjBd,SAASwB,EAAiBC,EAAcC,EAAcC,GAC3D,IAAIC,EAAeC,QAAQC,UAI3BC,eAAeC,EAAoBC,IACjC,OAAK,sBAAsBA,KAC3B,IACE,MAAMC,QAA8B,kBAAjBR,EAxBzBK,eAAgCN,EAAcC,EAAcC,EAAeM,GACzE,MAAO,CACLP,eACAC,gBACAQ,mBAAoBC,EAAA,EAASC,gBAAgBZ,EAAcQ,GAE/D,CAmBUI,CAAgBZ,EAAcC,EAAcC,EAAeM,GAjBrEF,eAA0BN,EAAcC,EAAcC,EAAeM,GACnE,MAAO,CACLP,eACAC,gBACAW,aAAcF,EAAA,EAASG,UAAUd,EAAcQ,GAEnD,CAYUM,CAAUd,EAAcC,EAAcC,EAAeM,IACzD,OAAOC,CACT,CAAE,SACA,IAAAM,GAAK,sBAAsBP,IAC7B,CACF,CAUA,OAtBA,UAsBOA,IACL,MAAMQ,EATRV,eAAwCE,GACtC,MAAMS,QAA6BV,EAAmBC,GAEtD,aADM,EAAAU,EAAA,IAA8BD,GAC7BA,CACT,CAKyCE,CAAwBX,GAC/D,OAAO,IAAIJ,SAAQ,CAACC,EAASe,KAC3BjB,EAAeA,EACZkB,MAAK,IAAML,IACXK,KAAKhB,EAASe,EAAM,GACxB,CAEL,C,qDCqFa,CACP7G,QAAO,KACP,UAAA+G,GACE,MAAM,kBAAEC,GAAsBzG,KAAKE,MAC/BuG,IAGJzG,KAAK0D,IAAI,CAAE+C,mBAAmB,KAC9B,OAAK,uBACL,EAAAC,EAAA,IAAU,KAER1G,KAAKC,MAAMyD,IAAI,CAAEiD,qBAAqB,KACtC,IAAAV,GAAK,qBAAoB,IAEjC,EACI,kBAAAW,CAAoBtC,GAClBtE,KAAK0D,IAAI,CAAEY,aACjB,EACI,gBAAAuC,GACE,MAAM,aAAE1B,GAAiBnF,KAAKE,OACxB,oBAAEyG,EAAmB,cAAEG,EAAa,sBAAEC,GAA0B/G,KAAKC,MAAMC,MACjF,IAAKyG,GACDG,GACAC,GACiB,WAAjB5B,EACF,OAEF,MAAM,gBAAErF,GAAoBE,KAAKC,MAAMC,OACjC,SAAE8G,GAAahH,KAAKE,OACX,QAAiCJ,EAAiBkH,EACvE,EACI,aAAAC,GACE,MAAM,iBAAEC,GAAqBlH,KAAKC,MAAMC,MACpCgH,GACFlH,KAAKC,MAAMkH,sBAAsB,CAC/BC,YAAY,EACZF,kBAAkB,GAG5B,EACI,cAAAG,GACE,MAAM,gBAAEvH,EAAe,sBAAEiH,GAA0B/G,KAAKC,MAAMC,OACxD,SAAE8G,EAAQ,aAAE7B,GAAiBnF,KAAKE,MAClCoH,EAAqB,KACzB,MAAM,aAAEC,GAAiBvH,KAAKE,MAC9B,IAAKqH,IAAiBA,EAAahH,OACjC,QAEF,OAAK,sBACL,MAAM,UAAE+D,GAActE,KAAKE,OACrB,iBACJgH,EAAgB,WAChBE,GACEpH,KAAKC,MAAMC,MACM,WAAjBiF,GAEF,QAAuBrF,EAAiBkH,GAC9BD,GAAuC,IAAdzC,GAAoB4C,GAAqBE,GAM5EpH,KAAKC,MAAMuH,eAAe1H,EAAiBkH,EAAU,CAAEE,kBAAkB,IAErEH,GACF/G,KAAKC,MAAMuH,eAAe1H,EAAiBkH,EAAU,CAAEI,YAAY,MANrE,QAAyBtH,EAAiBkH,IAS5C,IAAAf,GAAK,qBAAoB,EAE3BjG,KAAKP,QAAQ,gBAAgB,CAACgI,EAAiBC,KACxCD,GACAA,EAAgBlH,UACjB,QAAQkH,EAAiBC,KAG7B,EAAAC,EAAA,GAAiBL,EAAkB,GAE3C,EACI,oBAAAM,GACE5H,KAAKP,QAAQ,qBAAqB+F,UAChC,GAAIqC,EAAmB,CAErB,MAAMC,QAAmBD,EAEzB7H,KAAK0D,IAAI,CAAEoE,cACjB,IAEJ,EACI,gBAAAC,GAKE/H,KAAKC,MAAMyD,IAAI,CAAEsE,wBAAwB,GAC/C,EACIC,uBCrOC,YAGL,UACA,MAAM,gBACJnI,EAAe,sBACfoI,EAAqB,oBACrBC,EAAmB,qBACnBC,GACEnI,EAAA,EAAMC,MACJmI,EAAmBH,GAAyBA,EAAsB,GACxE,IAAKG,EACH,OAEF,MAAMC,EAAyC,kBAAxBH,GAA2CE,EAAiBE,GAC7EC,EAAmC,kBAAxBL,GAA2CE,EAAiBE,IAC7E,EAAAE,EAAA,IAAyB,GACzB,MAAMF,GAAK,EAAAG,EAAA,GACT5I,EAAiBqI,EACjBC,EAAsBE,EAAgBE,IAExC,EAAAG,EAAA,GAAkBJ,EACpB,G,eD+BM,UACAvI,KAAKqH,iBACLrH,KAAK4H,sBACX,C,2BA1D8BE,WAAWc,c,iCACZd,WAAWe,kB,QACdC,iBAAmB,IAAM,EAAA9B,S,YAChC+B,U,QACMC,Q,YACK,E,kBACKC,c,aACLC,Y,kBACKC,yB,cAChBC,Y,eACAC,c,gFACkBxC,kB,iBACHI,e,iBACKL,mBAAmB3F,E,iBACxBuF,Y,iBACGuB,kB,mTAdRD,WAAWe,oB,4CACdC,iBAAmB,IAAM,EAAA9B,U,4BAChC+B,W,sBACMC,S,sCAEUC,e,+BACLC,a,iDACKC,0B,gCAChBC,a,kCACAC,c,SAVWvB,WAAWc,gB,6SAqIxB3I,EAAA,E,yNA1EA,CACXgJ,cAAa,EACbE,yBAAwB,EACxBG,OAAM,IACNhF,UAAW,EACXwD,gBAAYhH,I,sjBApEyByI,c,2EAGxB,oB,WAFMC,Y,4KAuBoBvB,wB,qEAxBawB,O,4KAAAA,O,6eAAAA,O,oCAAfF,c,YAGlCzB,W,8FAFgB0B,Y,skBA+GJ,qBAAEE,I,OAA2BA,C,iGAxDlD,UAmB0B,aAAEvE,IACpB,OAAOG,QAAQqE,IAAI,CACA,WAAjBxE,EE7EsB,+BAE9BoB,MAAKqD,GAAOA,EAAIC,UCFqB,wDAErCtD,MAAKqD,GAAOA,EAAIC,UH8ES,kBAAjB1E,EIhF6C,+BAErDoB,MAAKqD,GAAOA,EAAIC,UCF+B,+BAE/CtD,MAAKqD,GAAOA,EAAIC,YLiFPtD,MAAKuD,IAAW,CACjBlB,cAAekB,EAAQ,GACvBjB,kBAAmBiB,EAAQ,MAErC,C,gHA0BsB,sBAAEC,I,OAA4BA,C,mIAzBlC,iBAAEjB,EAAgB,aAAE3D,EAAY,cAAEC,I,OAC5CH,EAAgB6D,EAAkB3D,EAAcC,E,mIAE1C,SAAE4B,EAAQ,iBAAE8B,EAAgB,aAAE3D,EAAY,cAAEC,IAClD,GAAI4E,EAAA,EAAUhD,GACZ,OAAO,EAAAtF,EAAA,GAAW,CAAC,aAAa,CAAC,YAAY,gBAAgB,CAAC,aAAc,CAC1EsF,SAAUgD,EAAA,EAAUhD,GAAUyC,MAC9BQ,SAAUnB,IAId,OAAQ3D,GACN,IAAK,MACH,OAAO,EAAAzD,EAAA,GAAW,CAAC,cAAc,CAAC,WAAW,YAAa,CAAEwI,QAAS9E,IACvE,IAAK,SACH,MAAO,mBACT,IAAK,UACH,MAAO,6BACT,IAAK,OACH,MAAO,iBACT,IAAK,gBACH,OAAO,EAAA1D,EAAA,GAAW,CAAC,oBAAoB,CAAC,aAAc,CAAEuI,SAAUnB,IAE9E,C,oIAKqB,aAAE3D,EAAY,cAAEC,EAAa,qBAAE+E,I,MAC3B,WAAjBhF,GACAgF,GACA/E,IAAkB+E,GAClB/E,C,yGAEQ,+BAAEgF,I,OACVA,GAAkCA,EAA+BC,KAAIC,GAAKA,EAAE/B,I,mHAE/D,oCAAEgC,I,OACfA,GAAuCA,EAAoCF,KAAIC,GAAKA,EAAE/B,I,+FAE1E,aAAEhB,IACd,MAAO,CACL9F,MAAO8F,EAAeA,EAAahH,OAAS,EAC5CgB,QAAS,KAEnB,C,6GACmB,iBAAEuH,EAAgB,SAAE9B,I,MAAe,GAAG8B,KAAoB9B,G,6GACxD,SAAEA,EAAQ,aAAE7B,I,MAAgC,SAAb6B,GAAwC,WAAjB7B,EAA4B,EAAI,C","sources":["webpack:///./src/routes/_components/DynamicHeading.html","webpack:///./src/routes/_components/timeline/LoadingFooter.html","webpack:///./src/routes/_components/timeline/MoreHeader.html","webpack:///./src/routes/_components/timeline/MoreHeaderVirtualWrapper.html","webpack:///./src/routes/_utils/scrollIntoView.js","webpack:///./src/routes/_components/shortcut/ScrollListShortcuts.html","webpack:///./src/routes/_actions/createMakeProps.js","webpack:///./src/routes/_components/timeline/Timeline.html","webpack:///./src/routes/_actions/showMoreAndScrollToTop.js","webpack:///./src/routes/_utils/asyncModules/importList.js","webpack:///./src/routes/_utils/asyncModules/importVirtualList.js","webpack:///./src/routes/_utils/asyncModules/importNotificationVirtualListItem.js","webpack:///./src/routes/_utils/asyncModules/importStatusVirtualListItem.js"],"sourcesContent":["{#if level === 2}\n  <h2 class={className || ''}><slot></slot></h2>\n{:else}\n  <h1 class={className || ''}><slot></slot></h1>\n{/if}\n","<div class=\"loading-footer {shown ? '' : 'hidden'}\">\n  <div class=\"loading-wrapper {showLoading ? 'shown' : ''}\"\n       aria-hidden={!showLoading}\n  >\n    <!-- Sapper's mousemove event listener schedules style recalculations for the loading spinner in\n         Chrome because it's always animating, even when hidden. So disable animations when not visible\n         to avoid this. -->\n    <LoadingSpinner size={48} animate={showLoading} />\n    <span class=\"loading-footer-info\">\n      Loading moreâ€¦\n    </span>\n  </div>\n  <div class=\"button-wrapper {showLoadButton ? 'shown' : ''}\"\n       aria-hidden={!showLoadButton}\n  >\n    <button type=\"button\"\n            class=\"primary\"\n            on:click=\"onClickLoadMore(event)\">\n      Load more\n    </button>\n  </div>\n</div>\n<style>\n  .loading-footer {\n    padding: 20px 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n  }\n  .loading-wrapper {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    pointer-events: none;\n    transition: opacity 0.2s linear;\n  }\n  .loading-wrapper.shown {\n    opacity: 1;\n    pointer-events: auto;\n  }\n  .loading-footer-info {\n    margin-left: 20px;\n    font-size: 1.3em;\n  }\n  .button-wrapper {\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    top: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    pointer-events: none;\n    transition: none;\n  }\n  .button-wrapper.shown {\n    opacity: 1;\n    pointer-events: auto;\n    transition: opacity 0.2s linear 0.2s;\n  }\n</style>\n<script>\n  import { observe } from 'svelte-extras'\n  import LoadingSpinner from '../LoadingSpinner.html'\n  import { store } from '../../_store/store.js'\n  import { fetchMoreItemsAtBottomOfTimeline } from '../../_actions/timeline.js'\n  import { announceAriaLivePolite } from '../../_utils/announceAriaLivePolite.js'\n\n  const SCREEN_READER_ANNOUNCE_DELAY = 1000 // 1 second\n\n  export default {\n    oncreate () {\n      // If the new statuses are delayed a significant amount of time, announce to screen readers that we're loading\n      let delayedAriaAnnouncementHandle\n\n      this.observe('showLoading', showLoading => {\n        if (showLoading) {\n          delayedAriaAnnouncementHandle = setTimeout(() => {\n            delayedAriaAnnouncementHandle = undefined\n            announceAriaLivePolite(\"Loading moreâ€¦\")\n          }, SCREEN_READER_ANNOUNCE_DELAY)\n        } else if (delayedAriaAnnouncementHandle) {\n          clearTimeout(delayedAriaAnnouncementHandle)\n        }\n      })\n    },\n    store: () => store,\n    computed: {\n      shown: ({ $timelineInitialized, $runningUpdate, $disableInfiniteScroll }) => (\n        $timelineInitialized && ($disableInfiniteScroll || $runningUpdate)\n      ),\n      showLoading: ({ $runningUpdate }) => $runningUpdate,\n      showLoadButton: ({ $runningUpdate, $disableInfiniteScroll }) => !$runningUpdate && $disableInfiniteScroll\n    },\n    methods: {\n      observe,\n      onClickLoadMore (e) {\n        e.preventDefault()\n        e.stopPropagation()\n        const { currentInstance, currentTimeline } = this.store.get()\n        /* no await */ fetchMoreItemsAtBottomOfTimeline(currentInstance, currentTimeline)\n        // focus the last item in the timeline; it makes the most sense to me since the button disappears\n        try {\n          // TODO: should probably expose this as an API on the virtual list instead of reaching into the DOM\n          const virtualListItems = document.querySelector('.virtual-list').children\n          const lastItem = virtualListItems[virtualListItems.length - 2] // -2 because the footer is last\n          lastItem.querySelector('article').focus()\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n    components: {\n      LoadingSpinner\n    }\n  }\n</script>\n","<div class=\"more-items-header\">\n  <button class=\"primary\" type=\"button\" on:click=\"onClick(event)\">\n    {showMoreLabel}\n  </button>\n</div>\n<style>\n  .more-items-header {\n    display: flex;\n    padding: 5px;\n    align-items: center;\n    justify-content:center;\n  }\n</style>\n<script>\n  import { formatIntl } from '../../_utils/formatIntl.js'\n\n  export default {\n    methods: {\n      onClick (event) {\n        const { onClick } = this.get()\n        if (onClick) {\n          onClick(event)\n        }\n      }\n    },\n    computed: {\n      showMoreLabel: ({ count }) => (\n        formatIntl([\"Show \",[\"count\"],\" more\"], { count })\n      )\n    }\n  }\n</script>\n","<MoreHeader count={virtualProps.count}\n            onClick={virtualProps.onClick}\n/>\n<script>\n  import MoreHeader from './MoreHeader.html'\n  export default {\n    components: {\n      MoreHeader\n    }\n  }\n</script>","import {\n  getScrollContainer,\n  getOffsetHeight\n} from './scrollContainer.js'\nimport { smoothScroll } from './smoothScroll.js'\n\nlet mainNavElement\nfunction getTopOverlay () {\n  if (!mainNavElement) {\n    mainNavElement = document.getElementById('main-nav')\n  }\n  return mainNavElement.clientHeight\n}\n\nexport function isVisible (element) {\n  if (!element) {\n    return false\n  }\n  const rect = element.getBoundingClientRect()\n  const offsetHeight = getOffsetHeight()\n  const topOverlay = getTopOverlay()\n  return rect.top < offsetHeight && rect.bottom >= topOverlay\n}\n\nexport function firstVisibleElementIndex (elements) {\n  const offsetHeight = getOffsetHeight()\n  const topOverlay = getTopOverlay()\n  let first = -1\n  let firstComplete = -1\n  const len = elements.length\n  let i = -1\n  while (++i < len) {\n    const element = elements[i]\n    if (!element) {\n      continue\n    }\n    const rect = element.getBoundingClientRect()\n    if (rect.top < offsetHeight && rect.bottom >= topOverlay) {\n      first = i\n      firstComplete = (rect.top < topOverlay && i < (len - 1)) ? i + 1 : i\n      break\n    }\n  }\n  return { first, firstComplete }\n}\n\nexport function scrollIntoViewIfNeeded (element) {\n  const rect = element.getBoundingClientRect()\n  const topOverlay = getTopOverlay()\n  const offsetHeight = getOffsetHeight()\n  let scrollY = 0\n  if (rect.top < topOverlay) {\n    scrollY = topOverlay\n  } else if (rect.bottom > offsetHeight) {\n    const height = rect.bottom - rect.top\n    if ((offsetHeight - topOverlay) > height) {\n      scrollY = offsetHeight - height\n    } else {\n      // if element height is too great to fit,\n      // prefer showing the top of the element\n      scrollY = topOverlay\n    }\n  } else {\n    return // not needed\n  }\n  const scrollContainer = getScrollContainer()\n  const scrollTop = scrollContainer.scrollTop\n  smoothScroll(scrollContainer, scrollTop + rect.top - scrollY, /* horizontal */ false, /* preferFast */ false)\n}\n","<script>\n  import {\n    isVisible,\n    firstVisibleElementIndex,\n    scrollIntoViewIfNeeded\n} from '../../_utils/scrollIntoView.js'\n  import {\n    addShortcutFallback,\n    removeShortcutFallback,\n    onKeyDownInShortcutScope\n} from '../../_utils/shortcuts.js'\n  import { smoothScroll } from '../../_utils/smoothScroll.js'\n  import { getScrollContainer } from '../../_utils/scrollContainer.js'\n  import { store } from '../../_store/store.js'\n  import { emit } from '../../_utils/eventBus.js'\n\n  const VISIBILITY_CHECK_DELAY_MS = 600\n\n  const keyToElement = key => document.getElementById(key)\n  const elementToKey = element => element.getAttribute('id')\n  const scope = 'global'\n\n  const shouldIgnoreEvent = event => {\n    // For accessibility reasons, do not override the arrowup/arrowdown behavior for radio buttons\n    // (e.g. in a poll). Up/down is supposed to change the radio value, not the current status.\n    const { target, key } = event\n    const isRadio = target &&\n    target.tagName === 'INPUT' &&\n    target.type === 'radio'\n    const isArrow = key === 'ArrowUp' || key === 'ArrowDown'\n    return isRadio && isArrow\n  }\n\n  export default {\n    data: () => ({\n      activeItemChangeTime: 0,\n      elements: document.getElementsByClassName('shortcut-list-item'),\n      spoilersShown: false\n    }),\n    store: () => store,\n    oncreate () {\n      addShortcutFallback(scope, this)\n    },\n    ondestroy () {\n      removeShortcutFallback(scope, this)\n    },\n    methods: {\n      onKeyDown (event) {\n        if (shouldIgnoreEvent(event)) {\n          return\n        }\n        if (event.key === 'z' && this.store.get().currentTimeline.startsWith('status/')) {\n          // if we're in a thread, toggle all content warnings on or off\n          event.stopPropagation()\n          event.preventDefault()\n          const { spoilersShown } = this.get()\n          emit('toggleAllSpoilers', !spoilersShown)\n          this.set({ spoilersShown: !spoilersShown })\n          return\n        }\n        if (event.key === 'j' || event.key === 'ArrowDown') {\n          event.stopPropagation()\n          event.preventDefault()\n          this.changeActiveItem(1, event.timeStamp)\n          return\n        }\n        if (event.key === 'k' || event.key === 'ArrowUp') {\n          event.stopPropagation()\n          event.preventDefault()\n          this.changeActiveItem(-1, event.timeStamp)\n          return\n        }\n        let activeItemKey = this.checkActiveItem(event.timeStamp)\n        if (!activeItemKey) {\n          const { elements } = this.get()\n          const index = firstVisibleElementIndex(elements).first\n          if (index >= 0) {\n            activeItemKey = elementToKey(elements[index])\n          }\n        }\n        if (activeItemKey) {\n          onKeyDownInShortcutScope(activeItemKey, event)\n        }\n      },\n      changeActiveItem (movement, timeStamp) {\n        const { elements } = this.get()\n        let index = -1\n        let activeItemKey = this.checkActiveItem(timeStamp)\n        if (activeItemKey) {\n          const len = elements.length\n          let i = -1\n          while (++i < len) {\n            if (elementToKey(elements[i]) === activeItemKey) {\n              index = i\n              break\n            }\n          }\n        }\n        if (index === 0 && movement === -1) {\n          activeItemKey = null\n          this.set({ activeItemKey })\n          smoothScroll(getScrollContainer(), 0, /* horizontal */ false, /* preferFast */ false)\n          return\n        }\n        if (index === -1) {\n          const { first, firstComplete } = firstVisibleElementIndex(elements)\n          index = (movement > 0) ? firstComplete : first\n        } else {\n          index += movement\n        }\n        if (index >= 0 && index < elements.length) {\n          activeItemKey = elementToKey(elements[index])\n          this.setActiveItem(activeItemKey, timeStamp)\n          scrollIntoViewIfNeeded(keyToElement(activeItemKey))\n        }\n      },\n      checkActiveItem (timeStamp) {\n        const activeElement = document.activeElement\n        if (!activeElement) {\n          return null\n        }\n        // The user might be focused on an element inside a toot. We want to\n        // move relative to that toot.\n        const activeArticle = activeElement.closest('article')\n        if (!activeArticle) {\n          return null\n        }\n        const activeItem = activeArticle.getAttribute('id')\n        if (!activeItem) {\n          return null\n        }\n        const { activeItemChangeTime } = this.get()\n        if ((timeStamp - activeItemChangeTime) > VISIBILITY_CHECK_DELAY_MS &&\n            !isVisible(keyToElement(activeItem))) {\n          this.setActiveItem(null, 0)\n          return null\n        }\n        return activeItem\n      },\n      setActiveItem (key, timeStamp) {\n        this.set({ activeItemChangeTime: timeStamp })\n        try {\n          keyToElement(key).focus({\n            preventScroll: true\n          })\n        } catch (err) {\n          console.error('Ignored focus error', err)\n        }\n      }\n    }\n  }\n</script>\n","import { database } from '../_database/database.js'\nimport { mark, stop } from '../_utils/marks.js'\nimport { prepareToRehydrate, rehydrateStatusOrNotification } from './rehydrateStatusOrNotification.js'\n\nasync function getNotification (instanceName, timelineType, timelineValue, itemId) {\n  return {\n    timelineType,\n    timelineValue,\n    notification: await database.getNotification(instanceName, itemId)\n  }\n}\n\nasync function getStatus (instanceName, timelineType, timelineValue, itemId) {\n  return {\n    timelineType,\n    timelineValue,\n    status: await database.getStatus(instanceName, itemId)\n  }\n}\n\nexport function createMakeProps (instanceName, timelineType, timelineValue) {\n  let promiseChain = Promise.resolve()\n\n  prepareToRehydrate() // start blurhash early to save time\n\n  async function fetchFromIndexedDB (itemId) {\n    mark(`fetchFromIndexedDB-${itemId}`)\n    try {\n      const res = await (timelineType === 'notifications'\n        ? getNotification(instanceName, timelineType, timelineValue, itemId)\n        : getStatus(instanceName, timelineType, timelineValue, itemId))\n      return res\n    } finally {\n      stop(`fetchFromIndexedDB-${itemId}`)\n    }\n  }\n\n  async function getStatusOrNotification (itemId) {\n    const statusOrNotification = await fetchFromIndexedDB(itemId)\n    await rehydrateStatusOrNotification(statusOrNotification)\n    return statusOrNotification\n  }\n\n  // The results from IndexedDB or the worker thread can return in random order,\n  // so we ensure consistent ordering based on the order this function is called in.\n  return itemId => {\n    const getStatusOrNotificationPromise = getStatusOrNotification(itemId) // start the promise ASAP\n    return new Promise((resolve, reject) => {\n      promiseChain = promiseChain\n        .then(() => getStatusOrNotificationPromise)\n        .then(resolve, reject)\n    })\n  }\n}\n","<DynamicHeading className=\"sr-only\" level={headingLevel}>{label}</DynamicHeading>\n<FocusRestoration realm={focusRealm}>\n  <div class=\"timeline\" role=\"feed\">\n    {#if components}\n      <svelte:component this={components.listComponent}\n                  component={components.listItemComponent}\n                  realm=\"{$currentInstance + '/' + timeline}\"\n                  {makeProps}\n                  items={itemIds}\n                  showFooter={true}\n                  footerComponent={LoadingFooter}\n                  showHeader={$showHeader}\n                  headerComponent={MoreHeaderVirtualWrapper}\n                  {headerProps}\n                  {scrollToItem}\n                  on:scrollToBottom=\"onScrollToBottom()\"\n                  on:scrollToTop=\"onScrollToTop()\"\n                  on:scrollTopChanged=\"onScrollTopChanged(event)\"\n                  on:initialized=\"initialize()\"\n                  on:noNeedToScroll=\"onNoNeedToScroll()\"\n      />\n    {/if}\n  </div>\n</FocusRestoration>\n<Shortcut scope=\"global\" key=\".\" on:pressed=\"showMoreAndScrollToTop()\" />\n<ScrollListShortcuts />\n<script>\n  import { store } from '../../_store/store.js'\n  import DynamicHeading from '../DynamicHeading.html'\n  import Status from '../status/Status.html'\n  import LoadingFooter from './LoadingFooter.html'\n  import MoreHeaderVirtualWrapper from './MoreHeaderVirtualWrapper.html'\n  import ScrollListShortcuts from '../shortcut/ScrollListShortcuts.html'\n  import Shortcut from '../shortcut/Shortcut.html'\n  import { importVirtualList } from '../../_utils/asyncModules/importVirtualList.js'\n  import { importList } from '../../_utils/asyncModules/importList.js'\n  import { importStatusVirtualListItem } from '../../_utils/asyncModules/importStatusVirtualListItem.js'\n  import { importNotificationVirtualListItem } from '../../_utils/asyncModules/importNotificationVirtualListItem.js'\n  import { timelines } from '../../_static/timelines.js'\n  import {\n    fetchMoreItemsAtBottomOfTimeline,\n    setupTimeline,\n    showMoreItemsForTimeline,\n    showMoreItemsForThread,\n    showMoreItemsForCurrentTimeline\n  } from '../../_actions/timeline.js'\n  import { scheduleIdleTask } from '../../_utils/scheduleIdleTask.js'\n  import { mark, stop } from '../../_utils/marks.js'\n  import { isEqual } from '../../_thirdparty/lodash/objects.js'\n  import { doubleRAF } from '../../_utils/doubleRAF.js'\n  import { observe } from 'svelte-extras'\n  import { createMakeProps } from '../../_actions/createMakeProps.js'\n  import { showMoreAndScrollToTop } from '../../_actions/showMoreAndScrollToTop.js'\n  import FocusRestoration from '../FocusRestoration.html'\n  import { formatIntl } from '../../_utils/formatIntl.js'\n\n  export default {\n    oncreate () {\n      console.log('timeline oncreate()')\n      setupTimeline()\n      this.setupStreaming()\n      this.setupAsyncComponents()\n    },\n    data: () => ({\n      LoadingFooter,\n      MoreHeaderVirtualWrapper,\n      Status,\n      scrollTop: 0,\n      components: undefined\n    }),\n    computed: {\n      // For threads, it's simpler to just render all items as a pseudo-virtual list\n      // due to need to scroll to the right item and thus calculate all item heights up-front.\n      // Here we lazy-load both the virtual list component itself as well as the component\n      // it renders.\n      componentsPromise: ({ timelineType }) => {\n        return Promise.all([\n          timelineType === 'status'\n            ? importList()\n            : importVirtualList(),\n          timelineType === 'notifications'\n            ? importNotificationVirtualListItem()\n            : importStatusVirtualListItem()\n        ]).then(results => ({\n          listComponent: results[0],\n          listItemComponent: results[1]\n        }))\n      },\n      makeProps: ({ $currentInstance, timelineType, timelineValue }) => (\n        createMakeProps($currentInstance, timelineType, timelineValue)\n      ),\n      label: ({ timeline, $currentInstance, timelineType, timelineValue }) => {\n        if (timelines[timeline]) {\n          return formatIntl([\"Statuses: \",[\"timeline\"],\" timeline on \",[\"instance\"]], {\n            timeline: timelines[timeline].label,\n            instance: $currentInstance\n          })\n        }\n\n        switch (timelineType) {\n          case 'tag':\n            return formatIntl([\"Statuses: #\",[\"hashtag\"],\" hashtag\"], { hashtag: timelineValue })\n          case 'status':\n            return \"Statuses: thread\"\n          case 'account':\n            return \"Statuses: account timeline\"\n          case 'list':\n            return \"Statuses: list\"\n          case 'notifications':\n            return formatIntl([\"Notifications on \",[\"instance\"]], { instance: $currentInstance })\n        }\n      },\n      timelineType: ({ $currentTimelineType }) => $currentTimelineType,\n      timelineValue: ({ $currentTimelineValue }) => $currentTimelineValue,\n      // Scroll to the first item if this is a \"status in own thread\" timeline.\n      // Don't scroll to the first item because it obscures the \"back\" button.\n      scrollToItem: ({ timelineType, timelineValue, $firstTimelineItemId }) => (\n        timelineType === 'status' &&\n        $firstTimelineItemId &&\n        timelineValue !== $firstTimelineItemId &&\n        timelineValue\n      ),\n      itemIds: ({ $filteredTimelineItemSummaries }) => (\n        $filteredTimelineItemSummaries && $filteredTimelineItemSummaries.map(_ => _.id)\n      ),\n      itemIdsToAdd: ({ $filteredTimelineItemSummariesToAdd }) => (\n        $filteredTimelineItemSummariesToAdd && $filteredTimelineItemSummariesToAdd.map(_ => _.id)\n      ),\n      headerProps: ({ itemIdsToAdd }) => {\n        return {\n          count: itemIdsToAdd ? itemIdsToAdd.length : 0,\n          onClick: showMoreItemsForCurrentTimeline\n        }\n      },\n      focusRealm: ({ $currentInstance, timeline }) => `${$currentInstance}-${timeline}`,\n      headingLevel: ({ timeline, timelineType }) => timeline === 'home' || timelineType === 'status' ? 2 : 1\n    },\n    store: () => store,\n    methods: {\n      observe,\n      initialize () {\n        const { initializeStarted } = this.get()\n        if (initializeStarted) {\n          return\n        }\n        this.set({ initializeStarted: true })\n        mark('initializeTimeline')\n        doubleRAF(() => {\n          console.log('timeline initialized')\n          this.store.set({ timelineInitialized: true })\n          stop('initializeTimeline')\n        })\n      },\n      onScrollTopChanged (scrollTop) {\n        this.set({ scrollTop })\n      },\n      onScrollToBottom () {\n        const { timelineType } = this.get()\n        const { timelineInitialized, runningUpdate, disableInfiniteScroll } = this.store.get()\n        if (!timelineInitialized ||\n            runningUpdate ||\n            disableInfiniteScroll ||\n            timelineType === 'status') { // for status contexts, we've already fetched the whole thread\n          return\n        }\n        const { currentInstance } = this.store.get()\n        const { timeline } = this.get()\n        /* no await */ fetchMoreItemsAtBottomOfTimeline(currentInstance, timeline)\n      },\n      onScrollToTop () {\n        const { shouldShowHeader } = this.store.get()\n        if (shouldShowHeader) {\n          this.store.setForCurrentTimeline({\n            showHeader: true,\n            shouldShowHeader: false\n          })\n        }\n      },\n      setupStreaming () {\n        const { currentInstance, disableInfiniteScroll } = this.store.get()\n        const { timeline, timelineType } = this.get()\n        const handleItemIdsToAdd = () => {\n          const { itemIdsToAdd } = this.get()\n          if (!itemIdsToAdd || !itemIdsToAdd.length) {\n            return\n          }\n          mark('handleItemIdsToAdd')\n          const { scrollTop } = this.get()\n          const {\n            shouldShowHeader,\n            showHeader\n          } = this.store.get()\n          if (timelineType === 'status') {\n            // this is a thread, just insert the statuses already\n            showMoreItemsForThread(currentInstance, timeline)\n          } else if (!disableInfiniteScroll && scrollTop === 0 && !shouldShowHeader && !showHeader) {\n            // if the user is scrolled to the top and we're not showing the header, then\n            // just insert the statuses. this is \"chat room mode\"\n            showMoreItemsForTimeline(currentInstance, timeline)\n          } else {\n            // user hasn't scrolled to the top, show a header instead\n            this.store.setForTimeline(currentInstance, timeline, { shouldShowHeader: true })\n            // unless the user has disabled infinite scroll entirely\n            if (disableInfiniteScroll) {\n              this.store.setForTimeline(currentInstance, timeline, { showHeader: true })\n            }\n          }\n          stop('handleItemIdsToAdd')\n        }\n        this.observe('itemIdsToAdd', (newItemIdsToAdd, oldItemIdsToAdd) => {\n          if (!newItemIdsToAdd ||\n              !newItemIdsToAdd.length ||\n              isEqual(newItemIdsToAdd, oldItemIdsToAdd)) {\n            return\n          }\n          scheduleIdleTask(handleItemIdsToAdd)\n        })\n      },\n      setupAsyncComponents () {\n        this.observe('componentsPromise', async componentsPromise => {\n          if (componentsPromise) {\n            console.log('loading timeline components')\n            const components = await componentsPromise\n            console.log('loaded timeline components')\n            this.set({ components })\n          }\n        })\n      },\n      onNoNeedToScroll () {\n        // If the timeline doesn't need to scroll, then we can safely \"preinitialize,\"\n        // i.e. render anything above the fold of the timeline. This avoids the affect\n        // where the scrollable content appears to jump around if we need to scroll it.\n        console.log('timeline preinitialized')\n        this.store.set({ timelinePreinitialized: true })\n      },\n      showMoreAndScrollToTop\n    },\n    components: {\n      ScrollListShortcuts,\n      Shortcut,\n      FocusRestoration,\n      DynamicHeading\n    }\n  }\n</script>\n","import { showMoreItemsForCurrentTimeline } from './timeline.js'\nimport { scrollToTop } from '../_utils/scrollToTop.js'\nimport { createStatusOrNotificationUuid } from '../_utils/createStatusOrNotificationUuid.js'\nimport { store } from '../_store/store.js'\nimport { tryToFocusElement } from '../_utils/tryToFocusElement.js'\n\nexport function showMoreAndScrollToTop () {\n  // Similar to Twitter, pressing \".\" will click the \"show more\" button and select\n  // the first toot.\n  showMoreItemsForCurrentTimeline()\n  const {\n    currentInstance,\n    timelineItemSummaries,\n    currentTimelineType,\n    currentTimelineValue\n  } = store.get()\n  const firstItemSummary = timelineItemSummaries && timelineItemSummaries[0]\n  if (!firstItemSummary) {\n    return\n  }\n  const notificationId = currentTimelineType === 'notifications' && firstItemSummary.id\n  const statusId = currentTimelineType !== 'notifications' && firstItemSummary.id\n  scrollToTop(/* smooth */ false)\n  const id = createStatusOrNotificationUuid(\n    currentInstance, currentTimelineType,\n    currentTimelineValue, notificationId, statusId\n  )\n  tryToFocusElement(id)\n}\n","export const importList = () => import(\n  '../../_components/list/List.html'\n).then(mod => mod.default)\n","export const importVirtualList = () => import(\n  '../../_components/virtualList/VirtualList.html'\n).then(mod => mod.default)\n","export const importNotificationVirtualListItem = () => import(\n  '../../_components/timeline/NotificationVirtualListItem.html'\n).then(mod => mod.default)\n","export const importStatusVirtualListItem = () => import(\n  '../../_components/timeline/StatusVirtualListItem.html'\n).then(mod => mod.default)\n"],"names":["className","level","SCREEN_READER_ANNOUNCE_DELAY","observe","onClickLoadMore","e","preventDefault","stopPropagation","currentInstance","currentTimeline","this","store","get","virtualListItems","document","querySelector","children","length","focus","console","error","delayedAriaAnnouncementHandle","showLoading","setTimeout","undefined","announceAriaLivePolite","clearTimeout","event","showLoadButton","shown","$timelineInitialized","$runningUpdate","$disableInfiniteScroll","onClick","showMoreLabel","count","formatIntl","virtualProps","mainNavElement","getTopOverlay","getElementById","clientHeight","firstVisibleElementIndex","elements","offsetHeight","topOverlay","first","firstComplete","len","i","element","rect","getBoundingClientRect","top","bottom","keyToElement","key","elementToKey","getAttribute","scope","onKeyDown","target","tagName","type","isArrow","shouldIgnoreEvent","startsWith","spoilersShown","set","changeActiveItem","timeStamp","activeItemKey","checkActiveItem","index","movement","smoothScroll","setActiveItem","scrollY","height","scrollContainer","scrollTop","scrollIntoViewIfNeeded","activeElement","activeArticle","closest","activeItem","activeItemChangeTime","isVisible","preventScroll","err","getElementsByClassName","createMakeProps","instanceName","timelineType","timelineValue","promiseChain","Promise","resolve","async","fetchFromIndexedDB","itemId","res","notification","database","getNotification","status","getStatus","s","getStatusOrNotificationPromise","statusOrNotification","rehydrateStatusOrNotification","getStatusOrNotification","reject","then","initialize","initializeStarted","doubleRAF","timelineInitialized","onScrollTopChanged","onScrollToBottom","runningUpdate","disableInfiniteScroll","timeline","onScrollToTop","shouldShowHeader","setForCurrentTimeline","showHeader","setupStreaming","handleItemIdsToAdd","itemIdsToAdd","setForTimeline","newItemIdsToAdd","oldItemIdsToAdd","scheduleIdleTask","setupAsyncComponents","componentsPromise","components","onNoNeedToScroll","timelinePreinitialized","showMoreAndScrollToTop","timelineItemSummaries","currentTimelineType","currentTimelineValue","firstItemSummary","notificationId","id","statusId","scrollToTop","createStatusOrNotificationUuid","tryToFocusElement","listComponent","listItemComponent","$currentInstance","makeProps","itemIds","LoadingFooter","$showHeader","MoreHeaderVirtualWrapper","headerProps","scrollToItem","Status","headingLevel","focusRealm","label","$currentTimelineType","all","mod","default","results","$currentTimelineValue","timelines","instance","hashtag","$firstTimelineItemId","$filteredTimelineItemSummaries","map","_","$filteredTimelineItemSummariesToAdd"],"sourceRoot":""}
{"version":3,"file":"668.9d490d65e1f1c46b76ee.668.js","mappings":"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","sources":["webpack:///./src/routes/_actions/deleteStatuses.js","webpack:///./src/routes/_actions/statuses.js","webpack:///./src/routes/_actions/followRequests.js","webpack:///./src/routes/_actions/lists.js","webpack:///./src/routes/_api/lists.js","webpack:///./src/routes/_api/followRequests.js","webpack:///./src/routes/_api/timelines.js","webpack:///./src/routes/_api/user.js","webpack:///./src/routes/_components/dialog/asyncDialogs/importShowComposeDialog.js","webpack:///./src/routes/_static/database.js","webpack:///./src/routes/_static/emojiPickerIntl.js","webpack:///./src/routes/_static/wordFilters.js","webpack:///./src/routes/_utils/getIdFromItemSummaries.js","webpack:///./src/routes/_store/computations/timelineComputations.js","webpack:///./src/routes/_store/computations/autosuggestComputations.js","webpack:///./src/routes/_utils/createRegexFromFilters.js","webpack:///./src/routes/_utils/createFilterFunction.js","webpack:///./src/routes/_store/computations/timelineFilterComputations.js","webpack:///./src/routes/_thirdparty/websocket/backoff.js","webpack:///./src/routes/_thirdparty/websocket/websocket.js","webpack:///./src/routes/_api/stream/TimelineStream.js","webpack:///./src/routes/_api/stream/getStreamUrl.js","webpack:///./src/routes/_actions/updateStatus.js","webpack:///./src/routes/_actions/stream/processMessage.js","webpack:///./src/routes/_actions/stream/fillStreamingGap.js","webpack:///./src/routes/_actions/stream/streaming.js","webpack:///./src/routes/_store/observers/instanceObservers.js","webpack:///./src/routes/_store/observers/timelineObservers.js","webpack:///./src/routes/_store/observers/notificationObservers.js","webpack:///./src/routes/_utils/runMediumPriorityTask.js","webpack:///./src/routes/_utils/setFavicon.js","webpack:///./src/routes/_static/autosuggest.js","webpack:///./src/routes/_actions/autosuggestEmojiSearch.js","webpack:///./src/routes/_utils/RequestThrottler.js","webpack:///./src/routes/_utils/PromiseThrottler.js","webpack:///./src/routes/_actions/autosuggestAccountSearch.js","webpack:///./src/routes/_actions/autosuggestHashtagSearch.js","webpack:///./src/routes/_store/observers/autosuggestObservers.js","webpack:///./src/routes/_store/observers/customScrollbarObservers.js","webpack:///./src/routes/_store/observers/cleanup.js","webpack:///./src/routes/_store/observers/showComposeDialogObservers.js","webpack:///./src/routes/_actions/showComposeDialog.js","webpack:///./src/routes/_utils/userAgent/isChromePre87.js","webpack:///./node_modules/is-emoji-supported/dist/esm/is-emoji-supported.js","webpack:///./src/routes/_store/observers/countryFlagEmojiPolyfill.js","webpack:///./node_modules/country-flag-emoji-polyfill/dist/index.modern.js","webpack:///./src/routes/_store/observers/centerNavObservers.js","webpack:///./src/routes/_store/mixins/timelineMixins.js","webpack:///./src/routes/_store/mixins/statusMixins.js","webpack:///./src/routes/_store/mixins/loggedInMixins.js","webpack:///./src/routes/_store/mixins/composeMixins.js","webpack:///./src/routes/_store/mixins/autosuggestMixins.js","webpack:///./src/routes/_store/computations/loggedInComputations.js","webpack:///./src/routes/_store/computations/wordFilterComputations.js","webpack:///./src/routes/_store/computations/badgeComputations.js","webpack:///./src/routes/_store/observers/loggedInObservers.js","webpack:///./src/routes/_store/observers/wordFilterObservers.js","webpack:///./src/routes/_store/observers/notificationPermissionObservers.js","webpack:///./src/routes/_store/observers/customEmojiObservers.js","webpack:///./src/routes/_store/observers/badgeObservers.js","webpack:///./src/routes/_utils/convertCustomEmojiToEmojiPickerFormat.js","webpack:///./src/routes/_utils/emojiDatabase.js","webpack:///./src/routes/_utils/userAgent/isMobile.js"],"sourcesContent":["import { getIdsThatRebloggedThisStatus, getNotificationIdsForStatuses } from './statuses.js'\nimport { store } from '../_store/store.js'\nimport { isEqual } from '../_thirdparty/lodash/objects.js'\nimport { database } from '../_database/database.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\n\nfunction filterItemIdsFromTimelines (instanceName, timelineFilter, idFilter) {\n  const keys = ['timelineItemSummaries', 'timelineItemSummariesToAdd']\n  const summaryFilter = _ => idFilter(_.id)\n\n  keys.forEach(key => {\n    const timelineData = store.getAllTimelineData(instanceName, key)\n    Object.keys(timelineData).forEach(timelineName => {\n      const summaries = timelineData[timelineName]\n      if (!timelineFilter(timelineName)) {\n        return\n      }\n      const filteredSummaries = summaries.filter(summaryFilter)\n      if (!isEqual(summaries, filteredSummaries)) {\n        console.log('deleting an item from timelineName', timelineName, 'for key', key)\n        store.setForTimeline(instanceName, timelineName, {\n          [key]: filteredSummaries\n        })\n      }\n    })\n  })\n}\n\nfunction deleteStatusIdsFromStore (instanceName, idsToDelete) {\n  const idsToDeleteSet = new Set(idsToDelete)\n  const idWasNotDeleted = id => !idsToDeleteSet.has(id)\n  const notNotificationTimeline = timelineName => timelineName !== 'notifications'\n\n  filterItemIdsFromTimelines(instanceName, notNotificationTimeline, idWasNotDeleted)\n}\n\nfunction deleteNotificationIdsFromStore (instanceName, idsToDelete) {\n  const idsToDeleteSet = new Set(idsToDelete)\n  const idWasNotDeleted = id => !idsToDeleteSet.has(id)\n  const isNotificationTimeline = timelineName => timelineName === 'notifications'\n\n  filterItemIdsFromTimelines(instanceName, isNotificationTimeline, idWasNotDeleted)\n}\n\nasync function deleteStatusesAndNotifications (instanceName, statusIdsToDelete, notificationIdsToDelete) {\n  deleteStatusIdsFromStore(instanceName, statusIdsToDelete)\n  deleteNotificationIdsFromStore(instanceName, notificationIdsToDelete)\n  await database.deleteStatusesAndNotifications(instanceName, statusIdsToDelete, notificationIdsToDelete)\n}\n\nasync function doDeleteStatus (instanceName, statusId) {\n  console.log('deleting statusId', statusId)\n  const rebloggedIds = await getIdsThatRebloggedThisStatus(instanceName, statusId)\n  const statusIdsToDelete = Array.from(new Set([statusId].concat(rebloggedIds).filter(Boolean)))\n  const notificationIdsToDelete = Array.from(new Set(await getNotificationIdsForStatuses(instanceName, statusIdsToDelete)))\n  await deleteStatusesAndNotifications(instanceName, statusIdsToDelete, notificationIdsToDelete)\n}\n\nexport function deleteStatus (instanceName, statusId) {\n  scheduleIdleTask(() => {\n    /* no await */ doDeleteStatus(instanceName, statusId)\n  })\n}\n","import { database } from '../_database/database.js'\n\nexport async function getIdThatThisStatusReblogged (instanceName, statusId) {\n  const status = await database.getStatus(instanceName, statusId)\n  return status.reblog && status.reblog.id\n}\n\nexport async function getIdsThatTheseStatusesReblogged (instanceName, statusIds) {\n  const reblogIds = await Promise.all(statusIds.map(async statusId => {\n    return getIdThatThisStatusReblogged(instanceName, statusId)\n  }))\n  return reblogIds.filter(Boolean)\n}\n\nexport async function getIdsThatRebloggedThisStatus (instanceName, statusId) {\n  return database.getReblogsForStatus(instanceName, statusId)\n}\n\nexport async function getNotificationIdsForStatuses (instanceName, statusIds) {\n  return database.getNotificationIdsForStatuses(instanceName, statusIds)\n}\n","import { store } from '../_store/store.js'\nimport { cacheFirstUpdateAfter } from '../_utils/sync.js'\nimport { database } from '../_database/database.js'\nimport { getFollowRequests } from '../_api/followRequests.js'\nimport { get } from '../_utils/lodash-lite.js'\n\nexport async function updateFollowRequestCountIfLockedAccount (instanceName) {\n  const { verifyCredentials, loggedInInstances } = store.get()\n\n  if (!get(verifyCredentials, [instanceName, 'locked'])) {\n    return\n  }\n\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  await cacheFirstUpdateAfter(\n    async () => (await getFollowRequests(instanceName, accessToken)).length,\n    () => database.getFollowRequestCount(instanceName),\n    followReqsCount => database.setFollowRequestCount(instanceName, followReqsCount),\n    followReqsCount => {\n      const { followRequestCounts } = store.get()\n      followRequestCounts[instanceName] = followReqsCount\n      store.set({ followRequestCounts })\n    }\n  )\n}\n","import { store } from '../_store/store.js'\nimport { getLists } from '../_api/lists.js'\nimport { cacheFirstUpdateAfter, cacheFirstUpdateOnlyIfNotInCache } from '../_utils/sync.js'\nimport { database } from '../_database/database.js'\n\nasync function syncLists (instanceName, syncMethod) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  await syncMethod(\n    () => getLists(instanceName, accessToken),\n    () => database.getLists(instanceName),\n    lists => database.setLists(instanceName, lists),\n    lists => {\n      const { instanceLists } = store.get()\n      instanceLists[instanceName] = lists\n      store.set({ instanceLists })\n    }\n  )\n}\n\nexport async function updateListsForInstance (instanceName) {\n  await syncLists(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupListsForInstance (instanceName) {\n  await syncLists(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n","import { get, DEFAULT_TIMEOUT, post, WRITE_TIMEOUT } from '../_utils/ajax.js'\nimport { auth, basename } from './utils.js'\n\nexport function getLists (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/lists`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function createList (instanceName, accessToken, title) {\n  const url = `${basename(instanceName)}/api/v1/lists`\n  return post(url, { title }, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n","import { DEFAULT_TIMEOUT, get, post, WRITE_TIMEOUT, paramsString } from '../_utils/ajax.js'\nimport { auth, basename } from './utils.js'\n\nexport async function getFollowRequests (instanceName, accessToken, limit = 80) {\n  let url = `${basename(instanceName)}/api/v1/follow_requests`\n  url += '?' + paramsString({ limit })\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport async function authorizeFollowRequest (instanceName, accessToken, id) {\n  const url = `${basename(instanceName)}/api/v1/follow_requests/${id}/authorize`\n  return post(url, null, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n\nexport async function rejectFollowRequest (instanceName, accessToken, id) {\n  const url = `${basename(instanceName)}/api/v1/follow_requests/${id}/reject`\n  return post(url, null, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n","import { getWithHeaders, paramsString, DEFAULT_TIMEOUT } from '../_utils/ajax.js'\nimport { auth, basename } from './utils.js'\n\nfunction getTimelineUrlPath (timeline) {\n  switch (timeline) {\n    case 'local':\n    case 'federated':\n      return 'timelines/public'\n    case 'bubble':\n      return 'timelines/bubble'\n    case 'home':\n      return 'timelines/home'\n    case 'notifications':\n    case 'notifications/mentions':\n      return 'notifications'\n    case 'favorites':\n      return 'favourites'\n    case 'direct':\n      return 'conversations'\n    case 'bookmarks':\n      return 'bookmarks'\n  }\n  if (timeline.startsWith('tag/')) {\n    return 'timelines/tag'\n  } else if (timeline.startsWith('account/')) {\n    return 'accounts'\n  } else if (timeline.startsWith('list/')) {\n    return 'timelines/list'\n  }\n  throw new Error(`Invalid timeline type: ${timeline}`)\n}\n\nexport async function getTimeline (instanceName, accessToken, timeline, maxId, since, limit) {\n  const timelineUrlName = getTimelineUrlPath(timeline)\n  let url = `${basename(instanceName)}/api/v1/${timelineUrlName}`\n\n  if (timeline.startsWith('tag/')) {\n    url += '/' + timeline.split('/')[1]\n  } else if (timeline.startsWith('account/')) {\n    url += '/' + timeline.split('/')[1] + '/statuses'\n  } else if (timeline.startsWith('list/')) {\n    url += '/' + timeline.split('/')[1]\n  }\n\n  const params = {}\n  if (since) {\n    params.since_id = since\n  }\n\n  if (maxId) {\n    params.max_id = maxId\n  }\n\n  if (limit) {\n    params.limit = limit\n  }\n\n  if (timeline === 'local') {\n    params.local = true\n  }\n\n  if (timeline.startsWith('account/')) {\n    if (timeline.endsWith('media')) {\n      params.only_media = true\n    } else {\n      params.exclude_replies = !timeline.endsWith('/with_replies')\n    }\n  }\n\n  if (timeline === 'notifications/mentions') {\n    params.exclude_types = ['follow', 'favourite', 'reblog', 'poll', 'admin.sign_up', 'update', 'follow_request', 'admin.report', 'reaction', 'pleroma:emoji_reaction']\n  }\n\n  url += '?' + paramsString(params)\n\n  console.log('fetching url', url)\n  let { json: items, headers } = await getWithHeaders(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n\n  if (timeline === 'direct') {\n    items = items.map(item => item.last_status).filter(Boolean) // ignore falsy last_status'es\n  }\n  return { items, headers }\n}\n","import { get, DEFAULT_TIMEOUT } from '../_utils/ajax.js'\nimport { auth, basename } from './utils.js'\n\nexport function getVerifyCredentials (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/accounts/verify_credentials`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function getAccount (instanceName, accessToken, accountId) {\n  const url = `${basename(instanceName)}/api/v1/accounts/${accountId}`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","export const importShowComposeDialog = () => import(\n  '../creators/showComposeDialog.js'\n).then(mod => mod.default)\n","export const CLEANUP_TIME_AGO = 5 * 24 * 60 * 60 * 1000 // five days ago\nexport const CLEANUP_DELAY = 5 * 60 * 1000 // five minutes\n","import { LOCALE } from './intl.js'\n\nexport const emojiPickerDataSource = `/emoji-${LOCALE}.json`\n\n// this should be undefined for English; it's already bundled with emoji-picker-element\nexport const emojiPickerI18n = process.env.EMOJI_PICKER_I18N\n\n// To avoid creating a new IDB database named emoji-picker-en-US, just\n// reuse the existing default \"en\" one (otherwise people will end up with\n// a stale database taking up useless space)\nexport const emojiPickerLocale = LOCALE === 'en-US' ? 'en' : LOCALE\n","export const WORD_FILTER_CONTEXT_HOME = 'home'\nexport const WORD_FILTER_CONTEXT_NOTIFICATIONS = 'notifications'\nexport const WORD_FILTER_CONTEXT_PUBLIC = 'public'\nexport const WORD_FILTER_CONTEXT_THREAD = 'thread'\nexport const WORD_FILTER_CONTEXT_ACCOUNT = 'account'\n\nexport const WORD_FILTER_CONTEXTS = [\n  WORD_FILTER_CONTEXT_HOME,\n  WORD_FILTER_CONTEXT_NOTIFICATIONS,\n  WORD_FILTER_CONTEXT_PUBLIC,\n  WORD_FILTER_CONTEXT_THREAD,\n  WORD_FILTER_CONTEXT_ACCOUNT\n]\n\n// Someday we can maybe replace this with Intl.DurationFormat\n// https://github.com/tc39/proposal-intl-duration-format\nexport const WORD_FILTER_EXPIRY_OPTIONS = [\n  {\n    value: 0,\n    label: \"Never\"\n  },\n  {\n    value: 1800,\n    label: \"30 minutes\"\n  },\n  {\n    value: 3600,\n    label: \"1 hour\"\n  },\n  {\n    value: 21600,\n    label: \"6 hours\"\n  },\n  {\n    value: 43200,\n    label: \"12 hours\"\n  },\n  {\n    value: 86400,\n    label: \"1 day\"\n  },\n  {\n    value: 604800,\n    label: \"7 days\"\n  }\n]\n\nexport const WORD_FILTER_EXPIRY_DEFAULT = 0\n","export function getFirstIdFromItemSummaries (itemSummaries) {\n  return itemSummaries &&\n    itemSummaries[0] &&\n    itemSummaries[0].id\n}\n\nexport function getLastIdFromItemSummaries (itemSummaries) {\n  return itemSummaries &&\n    itemSummaries[itemSummaries.length - 1] &&\n    itemSummaries[itemSummaries.length - 1].id\n}\n","import { get } from '../../_utils/lodash-lite.js'\nimport { getFirstIdFromItemSummaries, getLastIdFromItemSummaries } from '../../_utils/getIdFromItemSummaries.js'\nimport { mark, stop } from '../../_utils/marks.js'\n\nfunction computeForTimeline (store, key, defaultValue) {\n  store.compute(key,\n    ['currentInstance', 'currentTimeline', `timelineData_${key}`],\n    (currentInstance, currentTimeline, root) => (\n      get(root, [currentInstance, currentTimeline], defaultValue)\n    )\n  )\n}\n\nexport function timelineComputations (store) {\n  mark('timelineComputations')\n  computeForTimeline(store, 'timelineItemSummaries', null)\n  computeForTimeline(store, 'timelineItemSummariesToAdd', null)\n  computeForTimeline(store, 'runningUpdate', false)\n  computeForTimeline(store, 'lastFocusedElementId', null)\n  computeForTimeline(store, 'ignoreBlurEvents', false)\n  computeForTimeline(store, 'showHeader', false)\n  computeForTimeline(store, 'shouldShowHeader', false)\n  computeForTimeline(store, 'timelineItemSummariesAreStale', false)\n  computeForTimeline(store, 'timelineNextPageId', null)\n\n  store.compute('currentTimelineType', ['currentTimeline'], currentTimeline => (\n    currentTimeline && currentTimeline.split('/')[0])\n  )\n  store.compute('currentTimelineValue', ['currentTimeline'], currentTimeline => {\n    if (!currentTimeline) {\n      return undefined\n    }\n    const split = currentTimeline.split('/')\n    const len = split.length\n    if (split[len - 1] === 'with_replies' || split[len - 1] === 'media') {\n      return split[len - 2]\n    }\n    return split[len - 1]\n  })\n  store.compute('firstTimelineItemId', ['timelineItemSummaries'], (timelineItemSummaries) => (\n    getFirstIdFromItemSummaries(timelineItemSummaries)\n  ))\n  store.compute('lastTimelineItemId', ['timelineItemSummaries'], (timelineItemSummaries) => (\n    getLastIdFromItemSummaries(timelineItemSummaries)\n  ))\n  stop('timelineComputations')\n}\n","import { get } from '../../_utils/lodash-lite.js'\nimport { mark, stop } from '../../_utils/marks.js'\n\nconst MIN_PREFIX_LENGTH = 2\n// Technically mastodon accounts allow dots, but it would be weird to do an autosuggest search if it ends with a dot.\n// Also this is rare. https://github.com/tootsuite/mastodon/pull/6844\n// However for emoji search we allow some extra things (e.g. :+1:, :white_heart:)\nconst VALID_CHARS = '[\\\\w\\\\+_\\\\-:]'\nconst PREFIXES = '(?:@|:|#)'\nconst REGEX = new RegExp(`(?:\\\\s|^)(${PREFIXES}${VALID_CHARS}{${MIN_PREFIX_LENGTH},})$`)\n\nfunction computeForAutosuggest (store, key, defaultValue) {\n  store.compute(key,\n    ['currentInstance', 'currentComposeRealm', `autosuggestData_${key}`],\n    (currentInstance, currentComposeRealm, root) => (\n      get(root, [currentInstance, currentComposeRealm], defaultValue)\n    )\n  )\n}\n\nexport function autosuggestComputations (store) {\n  mark('autosuggestComputations')\n  computeForAutosuggest(store, 'composeFocused', false)\n  computeForAutosuggest(store, 'composeSelectionStart', 0)\n  computeForAutosuggest(store, 'autosuggestSelected', 0)\n  computeForAutosuggest(store, 'autosuggestSearchResults', [])\n  computeForAutosuggest(store, 'autosuggestType', null)\n\n  store.compute(\n    'currentComposeText',\n    ['currentComposeData', 'currentComposeRealm'],\n    (currentComposeData, currentComposeRealm) => (\n      get(currentComposeData, [currentComposeRealm, 'text'], '')\n    )\n  )\n\n  store.compute(\n    'autosuggestSearchText',\n    ['currentComposeText', 'composeSelectionStart'],\n    (currentComposeText, composeSelectionStart) => {\n      const selectionStart = composeSelectionStart\n      if (!currentComposeText || selectionStart < MIN_PREFIX_LENGTH) {\n        return ''\n      }\n\n      const textUpToCursor = currentComposeText.substring(0, selectionStart)\n      const match = textUpToCursor.match(REGEX)\n      return (match && match[1]) || ''\n    }\n  )\n\n  store.compute(\n    'autosuggestNumSearchResults',\n    ['autosuggestSearchResults'],\n    (autosuggestSearchResults) => autosuggestSearchResults.length\n  )\n\n  store.compute(\n    'autosuggestShown',\n    ['composeFocused', 'autosuggestSearchText', 'autosuggestNumSearchResults'],\n    (composeFocused, autosuggestSearchText, autosuggestNumSearchResults) => (\n      !!(composeFocused && autosuggestSearchText && autosuggestNumSearchResults)\n    )\n  )\n  stop('autosuggestComputations')\n}\n","// copy-pasta'd from mastodon\n// https://github.com/tootsuite/mastodon/blob/2ff01f7/app/javascript/mastodon/selectors/index.js#L40-L63\nconst escapeRegExp = string =>\n  string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n\nexport const createRegexFromFilters = filters => {\n  return new RegExp(filters.map(filter => {\n    let expr = escapeRegExp(filter.phrase)\n\n    if (filter.whole_word) {\n      if (/^[\\w]/.test(expr)) {\n        expr = `\\\\b${expr}`\n      }\n\n      if (/[\\w]$/.test(expr)) {\n        expr = `${expr}\\\\b`\n      }\n    }\n\n    return expr\n  }).join('|'), 'i')\n}\n","// create a function for filtering timeline item summaries\n\nexport const createFilterFunction = (\n  showReblogs, showReplies, showFollows, showFavs, showMentions, showPolls,\n  showSubscriptions, wordFilterContext\n) => {\n  return item => {\n    if (item.filterContexts && item.filterContexts.includes(wordFilterContext)) {\n      return false\n    }\n\n    switch (item.type) {\n      case 'poll':\n        return showPolls\n      case 'favourite':\n        return showFavs\n      case 'reblog':\n        return showReblogs\n      case 'mention':\n        return showMentions\n      case 'follow':\n        return showFollows\n      case 'status':\n        return showSubscriptions\n    }\n    if (item.reblogId) {\n      return showReblogs\n    } else if (item.replyId) {\n      return showReplies\n    } else {\n      return true\n    }\n  }\n}\n","import {\n  HOME_REBLOGS,\n  HOME_REPLIES,\n  NOTIFICATION_FAVORITES,\n  NOTIFICATION_FOLLOWS, NOTIFICATION_MENTIONS, NOTIFICATION_POLLS,\n  NOTIFICATION_REBLOGS, NOTIFICATION_SUBSCRIPTIONS\n} from '../../_static/instanceSettings.js'\nimport {\n  WORD_FILTER_CONTEXT_ACCOUNT,\n  WORD_FILTER_CONTEXT_HOME,\n  WORD_FILTER_CONTEXT_NOTIFICATIONS,\n  WORD_FILTER_CONTEXT_PUBLIC, WORD_FILTER_CONTEXT_THREAD\n} from '../../_static/wordFilters.js'\nimport { createFilterFunction } from '../../_utils/createFilterFunction.js'\nimport { get } from '../../_utils/lodash-lite.js'\n\n// Compute just the boolean, e.g. 'showPolls', so that we can use that boolean as\n// the input to the timelineFilterFunction computations. This should reduce the need to\n// re-compute the timelineFilterFunction over and over.\nfunction computeTimelineFilter (store, computationName, timelinesToSettingsKeys) {\n  store.compute(\n    computationName,\n    ['currentInstance', 'instanceSettings', 'currentTimeline'],\n    (currentInstance, instanceSettings, currentTimeline) => {\n      const settingsKey = timelinesToSettingsKeys[currentTimeline]\n      return settingsKey ? get(instanceSettings, [currentInstance, settingsKey], true) : true\n    }\n  )\n}\n\n// Ditto for notifications, which we always have to keep track of due to the notification count.\nfunction computeNotificationFilter (store, computationName, key) {\n  store.compute(\n    computationName,\n    ['currentInstance', 'instanceSettings'],\n    (currentInstance, instanceSettings) => {\n      return get(instanceSettings, [currentInstance, key], true)\n    }\n  )\n}\n\nexport function timelineFilterComputations (store) {\n  computeTimelineFilter(store, 'timelineShowReblogs', { home: HOME_REBLOGS, notifications: NOTIFICATION_REBLOGS })\n  computeTimelineFilter(store, 'timelineShowReplies', { home: HOME_REPLIES })\n  computeTimelineFilter(store, 'timelineShowFollows', { notifications: NOTIFICATION_FOLLOWS })\n  computeTimelineFilter(store, 'timelineShowFavs', { notifications: NOTIFICATION_FAVORITES })\n  computeTimelineFilter(store, 'timelineShowMentions', { notifications: NOTIFICATION_MENTIONS })\n  computeTimelineFilter(store, 'timelineShowPolls', { notifications: NOTIFICATION_POLLS })\n  computeTimelineFilter(store, 'timelineShowSubscriptions', { notifications: NOTIFICATION_SUBSCRIPTIONS })\n\n  computeNotificationFilter(store, 'timelineNotificationShowReblogs', NOTIFICATION_REBLOGS)\n  computeNotificationFilter(store, 'timelineNotificationShowFollows', NOTIFICATION_FOLLOWS)\n  computeNotificationFilter(store, 'timelineNotificationShowFavs', NOTIFICATION_FAVORITES)\n  computeNotificationFilter(store, 'timelineNotificationShowMentions', NOTIFICATION_MENTIONS)\n  computeNotificationFilter(store, 'timelineNotificationShowPolls', NOTIFICATION_POLLS)\n  computeNotificationFilter(store, 'timelineNotificationShowSubscriptions', NOTIFICATION_SUBSCRIPTIONS)\n\n  store.compute(\n    'timelineWordFilterContext',\n    ['currentTimeline'],\n    (currentTimeline) => {\n      if (!currentTimeline) {\n        return\n      }\n      if (currentTimeline === 'home' || currentTimeline.startsWith('list/')) {\n        return WORD_FILTER_CONTEXT_HOME\n      }\n      if (currentTimeline === 'notifications' || currentTimeline.startsWith('notifications/')) {\n        return WORD_FILTER_CONTEXT_NOTIFICATIONS\n      }\n      if (currentTimeline === 'federated' || currentTimeline === 'bubble' || currentTimeline === 'local' || currentTimeline.startsWith('tag/')) {\n        return WORD_FILTER_CONTEXT_PUBLIC\n      }\n      if (currentTimeline.startsWith('account/')) {\n        return WORD_FILTER_CONTEXT_ACCOUNT\n      }\n      if (currentTimeline.startsWith('status/')) {\n        return WORD_FILTER_CONTEXT_THREAD\n      }\n      // return undefined otherwise\n    }\n  )\n\n  // This one is based on whatever the current timeline is\n  store.compute(\n    'timelineFilterFunction',\n    [\n      'timelineShowReblogs', 'timelineShowReplies', 'timelineShowFollows',\n      'timelineShowFavs', 'timelineShowMentions', 'timelineShowPolls',\n      'timelineShowSubscriptions', 'timelineWordFilterContext'\n    ],\n    (showReblogs, showReplies, showFollows, showFavs, showMentions, showPolls, showSubscriptions, wordFilterContext) => (\n      createFilterFunction(showReblogs, showReplies, showFollows, showFavs, showMentions, showPolls, showSubscriptions, wordFilterContext)\n    )\n  )\n\n  // The reason there is a completely separate flow just for notifications is that we need to\n  // know which notifications are filtered at all times so that the little number badge is correct.\n  store.compute(\n    'timelineNotificationFilterFunction',\n    [\n      'timelineNotificationShowReblogs', 'timelineNotificationShowFollows',\n      'timelineNotificationShowFavs', 'timelineNotificationShowMentions',\n      'timelineNotificationShowPolls', 'timelineNotificationShowSubscriptions'\n    ],\n    (showReblogs, showFollows, showFavs, showMentions, showPolls, showSubscriptions) => (\n      createFilterFunction(showReblogs, true, showFollows, showFavs, showMentions, showPolls, showSubscriptions, WORD_FILTER_CONTEXT_NOTIFICATIONS)\n    )\n  )\n\n  store.compute(\n    'filteredTimelineItemSummaries',\n    ['timelineItemSummaries', 'timelineFilterFunction'],\n    (timelineItemSummaries, timelineFilterFunction) => {\n      return timelineItemSummaries && timelineItemSummaries.filter(timelineFilterFunction)\n    }\n  )\n\n  store.compute(\n    'filteredTimelineItemSummariesToAdd',\n    ['timelineItemSummariesToAdd', 'timelineFilterFunction'],\n    (timelineItemSummariesToAdd, timelineFilterFunction) => {\n      return timelineItemSummariesToAdd && timelineItemSummariesToAdd.filter(timelineFilterFunction)\n    }\n  )\n\n  store.compute('timelineNotificationItemSummaries',\n    ['timelineData_timelineItemSummariesToAdd', 'timelineFilterFunction', 'currentInstance'],\n    (root, timelineFilterFunction, currentInstance) => (\n      get(root, [currentInstance, 'notifications'])\n    )\n  )\n\n  store.compute(\n    'filteredTimelineNotificationItemSummaries',\n    ['timelineNotificationItemSummaries', 'timelineNotificationFilterFunction'],\n    (timelineNotificationItemSummaries, timelineNotificationFilterFunction) => (\n      timelineNotificationItemSummaries && timelineNotificationItemSummaries.filter(timelineNotificationFilterFunction)\n    )\n  )\n}\n","const MAX_DELAY = 60000 // 60 seconds\nconst INITIAL_DELAY = 100\n\nexport class Backoff {\n  constructor (onReady) {\n    this.attempts = 0\n    this.onReady = onReady\n  }\n\n  backoff () {\n    const delay = this.fibonacci(++this.attempts)\n    console.log('websocket delay', delay)\n    setTimeout(this.onReady, delay)\n  }\n\n  fibonacci (attempt) {\n    let current = 1\n\n    if (attempt > current) {\n      let prev = 1\n      current = 2\n\n      for (let index = 2; index < attempt; index++) {\n        const next = prev + current\n        prev = current\n        current = next\n      }\n    }\n\n    return Math.min(MAX_DELAY, Math.floor(Math.random() * current * INITIAL_DELAY))\n  }\n\n  reset () {\n    this.attempts = 0\n  }\n}\n","// forked from https://github.com/gamestdio/websocket/blob/4111bfa/src/index.js\n\nimport { Backoff } from './backoff.js'\n\nexport class WebSocketClient {\n  /**\n   * @param url DOMString The URL to which to connect; this should be the URL to which the WebSocket server will respond.\n   * @param protocols DOMString|DOMString[] Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol). If you don't specify a protocol string, an empty string is assumed.\n   * @param options options\n   */\n  constructor (url, protocols = [], options = {}) {\n    this.url = url\n    this.protocols = protocols\n\n    this.reconnectEnabled = true\n    this.listeners = {}\n\n    this.backoff = new Backoff(this.onBackoffReady.bind(this))\n\n    if (typeof (options.connect) === 'undefined' || options.connect) {\n      this.open()\n    }\n  }\n\n  open (reconnect = false) {\n    this.isReconnect = reconnect\n\n    // keep binaryType used on previous WebSocket connection\n    const binaryType = this.ws && this.ws.binaryType\n\n    this.ws = new WebSocket(this.url, this.protocols)\n    this.ws.onclose = this.onCloseCallback.bind(this)\n    this.ws.onerror = this.onErrorCallback.bind(this)\n    this.ws.onmessage = this.onMessageCallback.bind(this)\n    this.ws.onopen = this.onOpenCallback.bind(this)\n\n    if (binaryType) {\n      this.ws.binaryType = binaryType\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  onBackoffReady () {\n    this.open(true)\n  }\n\n  /**\n   * @ignore\n   */\n  onCloseCallback (e) {\n    if (!this.isReconnect && this.listeners.onclose) {\n      this.listeners.onclose.apply(null, arguments)\n    }\n    if (this.reconnectEnabled && e.code < 3000) {\n      this.backoff.backoff()\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  onErrorCallback () {\n    if (this.listeners.onerror) {\n      this.listeners.onerror.apply(null, arguments)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  onMessageCallback () {\n    if (this.listeners.onmessage) {\n      this.listeners.onmessage.apply(null, arguments)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  onOpenCallback () {\n    if (this.listeners.onopen) {\n      this.listeners.onopen.apply(null, arguments)\n    }\n\n    if (this.isReconnect && this.listeners.onreconnect) {\n      this.listeners.onreconnect.apply(null, arguments)\n    }\n\n    this.isReconnect = false\n  }\n\n  // Unused\n  // /**\n  //  * The number of bytes of data that have been queued using calls to send()\n  //  * but not yet transmitted to the network. This value does not reset to zero\n  //  * when the connection is closed; if you keep calling send(), this will\n  //  * continue to climb.\n  //  *\n  //  * @type unsigned long\n  //  * @readonly\n  //  */\n  // get bufferedAmount () { return this.ws.bufferedAmount }\n  //\n  /**\n   * The current state of the connection; this is one of the Ready state constants.\n   * @type unsigned short\n   * @readonly\n   */\n  get readyState () { return this.ws.readyState }\n\n  // Unused\n  //\n  // /**\n  //  * A string indicating the type of binary data being transmitted by the\n  //  * connection. This should be either \"blob\" if DOM Blob objects are being\n  //  * used or \"arraybuffer\" if ArrayBuffer objects are being used.\n  //  * @type DOMString\n  //  */\n  // get binaryType () { return this.ws.binaryType }\n  //\n  // set binaryType (binaryType) { this.ws.binaryType = binaryType }\n  //\n  // /**\n  //  * The extensions selected by the server. This is currently only the empty\n  //  * string or a list of extensions as negotiated by the connection.\n  //  * @type DOMString\n  //  */\n  // get extensions () { return this.ws.extensions }\n  //\n  // set extensions (extensions) { this.ws.extensions = extensions }\n  //\n  // /**\n  //  * A string indicating the name of the sub-protocol the server selected;\n  //  * this will be one of the strings specified in the protocols parameter when\n  //  * creating the WebSocket object.\n  //  * @type DOMString\n  //  */\n  // get protocol () { return this.ws.protocol }\n  //\n  // set protocol (protocol) { this.ws.protocol = protocol }\n\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the\n   * connection is already CLOSED, this method does nothing.\n   *\n   * @param code A numeric value indicating the status code explaining why the connection is being closed. If this parameter is not specified, a default value of 1000 (indicating a normal \"transaction complete\" closure) is assumed. See the list of status codes on the CloseEvent page for permitted values.\n   * @param reason A human-readable string explaining why the connection is closing. This string must be no longer than 123 bytes of UTF-8 text (not characters).\n   *\n   * @return void\n   */\n  close (code, reason) {\n    if (typeof code === 'undefined') { code = 1000 }\n\n    this.reconnectEnabled = false\n\n    this.ws.close(code, reason)\n  }\n\n  /**\n   * Transmits data to the server over the WebSocket connection.\n   * @param data DOMString|ArrayBuffer|Blob\n   * @return void\n   */\n  send (data) { this.ws.send(data) }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED. The listener receives a CloseEvent named \"close\".\n   * @param listener EventListener\n   */\n  set onclose (listener) { this.listeners.onclose = listener }\n\n  get onclose () { return this.listeners.onclose }\n\n  /**\n   * An event listener to be called when an error occurs. This is a simple event named \"error\".\n   * @param listener EventListener\n   */\n  set onerror (listener) { this.listeners.onerror = listener }\n\n  get onerror () { return this.listeners.onerror }\n\n  /**\n   * An event listener to be called when a message is received from the server. The listener receives a MessageEvent named \"message\".\n   * @param listener EventListener\n   */\n  set onmessage (listener) { this.listeners.onmessage = listener }\n\n  get onmessage () { return this.listeners.onmessage }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN; this indicates that the connection is ready to send and receive data. The event is a simple one with the name \"open\".\n   * @param listener EventListener\n   */\n  set onopen (listener) { this.listeners.onopen = listener }\n\n  get onopen () { return this.listeners.onopen }\n\n  /**\n   * @param listener EventListener\n   */\n  set onreconnect (listener) { this.listeners.onreconnect = listener }\n\n  get onreconnect () { return this.listeners.onreconnect }\n\n  /**\n   * Reset the backoff function back to initial state\n   */\n  reset () {\n    console.log('websocket reset')\n    this.backoff.reset()\n  }\n\n  /** Reconnect the websocket\n   *\n   */\n  reconnect () {\n    console.log('websocket reconnect')\n    this.onBackoffReady()\n  }\n}\n\n/**\n * The connection is not yet open.\n */\nWebSocketClient.CONNECTING = WebSocket.CONNECTING\n\n/**\n * The connection is open and ready to communicate.\n */\nWebSocketClient.OPEN = WebSocket.OPEN\n\n/**\n * The connection is in the process of closing.\n */\nWebSocketClient.CLOSING = WebSocket.CLOSING\n\n/**\n * The connection is closed or couldn't be opened.\n */\nWebSocketClient.CLOSED = WebSocket.CLOSED\n","import { WebSocketClient } from '../../_thirdparty/websocket/websocket.js'\nimport { lifecycle } from '../../_utils/lifecycle.js'\nimport { getStreamUrl } from './getStreamUrl.js'\nimport { EventEmitter } from 'events-light'\nimport { eventBus } from '../../_utils/eventBus.js'\nimport { safeParse } from '../../_utils/safeParse.js'\n\nexport class TimelineStream extends EventEmitter {\n  constructor (streamingApi, accessToken, timeline) {\n    super()\n    this._streamingApi = streamingApi\n    this._accessToken = accessToken\n    this._timeline = timeline\n    this._onStateChange = this._onStateChange.bind(this)\n    this._onOnline = this._onOnline.bind(this)\n    this._onOffline = this._onOffline.bind(this)\n    this._onForcedOnlineStateChange = this._onForcedOnlineStateChange.bind(this)\n    this._setupWebSocket()\n    this._setupEvents()\n  }\n\n  close () {\n    this._closed = true\n    this._closeWebSocket()\n    this._teardownEvents()\n    // events-light currently does not support removeAllListeners()\n    // https://github.com/patrick-steele-idem/events-light/issues/2\n    for (const event of ['open', 'close', 'reconnect', 'message']) {\n      this.removeAllListeners(event)\n    }\n  }\n\n  _closeWebSocket () {\n    if (this._ws) {\n      this.emit('close')\n      this._ws.onopen = null\n      this._ws.onmessage = null\n      this._ws.onclose = null\n      this._ws.close()\n      this._ws = null\n    }\n  }\n\n  _setupWebSocket () {\n    const url = getStreamUrl(this._streamingApi, this._accessToken, this._timeline)\n    const ws = new WebSocketClient(url)\n\n    ws.onopen = () => {\n      if (!this._opened) {\n        this.emit('open')\n        this._opened = true\n      } else {\n        // we may close or reopen websockets due to freeze/unfreeze events\n        // and we want to fire \"reconnect\" rather than \"open\" in that case\n        this.emit('reconnect')\n      }\n    }\n    ws.onmessage = (e) => this.emit('message', safeParse(e.data))\n    ws.onclose = () => this.emit('close')\n    // The ws \"onreconnect\" event seems unreliable. When the server goes down and comes back up,\n    // it doesn't fire (but \"open\" does). When we freeze and unfreeze, it fires along with the\n    // \"open\" event. The above is my attempt to normalize it.\n\n    this._ws = ws\n  }\n\n  _setupEvents () {\n    lifecycle.addEventListener('statechange', this._onStateChange)\n    eventBus.on('forcedOnline', this._onForcedOnlineStateChange) // only happens in tests\n    window.addEventListener('online', this._onOnline)\n    window.addEventListener('offline', this._onOffline)\n  }\n\n  _teardownEvents () {\n    lifecycle.removeEventListener('statechange', this._onStateChange)\n    eventBus.removeListener('forcedOnline', this._onForcedOnlineStateChange) // only happens in tests\n    window.removeEventListener('online', this._onOnline)\n    window.removeEventListener('offline', this._onOffline)\n  }\n\n  _pause () {\n    if (this._closed) {\n      return\n    }\n    this._closeWebSocket()\n  }\n\n  _unpause () {\n    if (this._closed) {\n      return\n    }\n    this._closeWebSocket()\n    this._setupWebSocket()\n  }\n\n  _onStateChange (event) {\n    // when the page enters or exits a frozen state, pause or resume websocket polling\n    if (event.newState === 'frozen') { // page is frozen\n      console.log('frozen')\n      this._pause()\n    } else if (event.oldState === 'frozen') { // page is unfrozen\n      console.log('unfrozen')\n      this._unpause()\n    }\n    if (event.newState === 'active') { // page is reopened from a background tab\n      console.log('active')\n      this._tryToReconnect()\n    }\n  }\n\n  _onOnline () {\n    console.log('online')\n    this._unpause() // if we're not paused, then this is a no-op\n    this._tryToReconnect() // to be safe, try to reset and reconnect\n  }\n\n  _onOffline () {\n    console.log('offline')\n    this._pause() // in testing, it seems to work better to stop polling when we get this event\n  }\n\n  _onForcedOnlineStateChange (online) {\n    if (online) {\n      console.log('online forced')\n      this._unpause()\n    } else {\n      console.log('offline forced')\n      this._pause()\n    }\n  }\n\n  _tryToReconnect () {\n    console.log('websocket readyState', this._ws && this._ws.readyState)\n    if (this._ws && this._ws.readyState !== WebSocketClient.OPEN) {\n      // if a websocket connection is not currently open, then reset the\n      // backoff counter to ensure that fresh notifications come in faster\n      this._ws.reset()\n      this._ws.reconnect()\n    }\n  }\n}\n","import { paramsString } from '../../_utils/ajax.js'\n\nfunction getStreamName (timeline) {\n  switch (timeline) {\n    case 'local':\n      return 'public:local'\n    case 'federated':\n      return 'public'\n    case 'home':\n      return 'user'\n    case 'notifications':\n      return 'user:notification'\n    case 'direct':\n      return 'direct'\n  }\n  if (timeline.startsWith('tag/')) {\n    return 'hashtag'\n  }\n  if (timeline.startsWith('list/')) {\n    return 'list'\n  }\n}\n\nexport function getStreamUrl (streamingApi, accessToken, timeline) {\n  const url = `${streamingApi}/api/v1/streaming`\n  const streamName = getStreamName(timeline)\n\n  const params = {\n    stream: streamName\n  }\n\n  if (timeline.startsWith('tag/')) {\n    params.tag = timeline.split('/').slice(-1)[0]\n  } else if (timeline.startsWith('list/')) {\n    params.list = timeline.split('/').slice(-1)[0]\n  }\n\n  if (accessToken) {\n    params.access_token = accessToken\n  }\n\n  return url + '?' + paramsString(params)\n}\n","import { database } from '../_database/database.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\n\nasync function doUpdateStatus (instanceName, newStatus) {\n  console.log('updating status', newStatus)\n  await database.updateStatus(instanceName, newStatus)\n}\n\nexport function updateStatus (instanceName, newStatus) {\n  scheduleIdleTask(() => {\n    /* no await */ doUpdateStatus(instanceName, newStatus)\n  })\n}\n","import { mark, stop } from '../../_utils/marks.js'\nimport { deleteStatus } from '../deleteStatuses.js'\nimport { addStatusOrNotification } from '../addStatusOrNotification.js'\nimport { emit } from '../../_utils/eventBus.js'\nimport { updateStatus } from '../updateStatus.js'\n\nconst KNOWN_EVENTS = ['update', 'delete', 'notification', 'conversation', 'filters_changed', 'status.update']\n\nexport function processMessage (instanceName, timelineName, message) {\n  let { event, payload } = (message || {})\n  if (!KNOWN_EVENTS.includes(event)) {\n    console.warn('ignoring message from server', message)\n    return\n  }\n  mark('processMessage')\n  if (['update', 'notification', 'conversation', 'status.update'].includes(event)) {\n    payload = JSON.parse(payload) // only these payloads are JSON-encoded for some reason\n  }\n\n  switch (event) {\n    case 'delete':\n      deleteStatus(instanceName, payload)\n      break\n    case 'update':\n      addStatusOrNotification(instanceName, timelineName, payload)\n      break\n    case 'notification':\n      addStatusOrNotification(instanceName, 'notifications', payload)\n      if (payload.type === 'mention') {\n        addStatusOrNotification(instanceName, 'notifications/mentions', payload)\n      }\n      break\n    case 'conversation':\n      // This is a hack in order to mostly fit the conversation model into\n      // a timeline of statuses. To have a clean implementation we would need to\n      // reproduce what is done for statuses for the conversation.\n      //\n      // It will add new DMs as new conversations instead of updating existing threads\n      if (payload.last_status) {\n        // If the last_status doesn't exist, just ignore it. There's not much we can do in that case\n        addStatusOrNotification(instanceName, timelineName, payload.last_status)\n      }\n      break\n    case 'filters_changed':\n      emit('wordFiltersChanged', instanceName)\n      break\n    case 'status.update':\n      updateStatus(instanceName, payload)\n      break\n  }\n  stop('processMessage')\n}\n","import { addStatusesOrNotifications } from '../addStatusOrNotification.js'\nimport { getTimeline } from '../../_api/timelines.js'\n\nconst TIMELINE_GAP_BATCH_SIZE = 20 // Mastodon timeline API maximum limit\nconst MAX_NUM_REQUESTS = 15 // to avoid getting caught in an infinite loop somehow\n\n// fill in the \"streaming gap\"  i.e. fetch the most recent items so that there isn't\n// a big gap in the timeline if you haven't looked at it in awhile\nexport async function fillStreamingGap (instanceName, accessToken, timelineName, firstTimelineItemId) {\n  let maxId = null\n  let numRequests = 0\n  let newTimelineItems\n\n  do {\n    numRequests++\n    newTimelineItems = (await getTimeline(instanceName, accessToken,\n      timelineName, maxId, firstTimelineItemId, TIMELINE_GAP_BATCH_SIZE)).items\n    if (newTimelineItems.length) {\n      addStatusesOrNotifications(instanceName, timelineName, newTimelineItems)\n      maxId = newTimelineItems[newTimelineItems.length - 1].id\n    }\n  } while (numRequests < MAX_NUM_REQUESTS && newTimelineItems.length === TIMELINE_GAP_BATCH_SIZE)\n}\n","import { TimelineStream } from '../../_api/stream/TimelineStream.js'\nimport { processMessage } from './processMessage.js'\nimport { fillStreamingGap } from './fillStreamingGap.js'\nimport { store } from '../../_store/store.js'\n\nexport function createStream (api, instanceName, accessToken, timelineName, firstStatusId, firstNotificationId) {\n  console.log(`streaming ${instanceName} ${timelineName}: createStream`, 'firstStatusId', firstStatusId,\n    'firstNotificationId', firstNotificationId)\n\n  const fillGap = (timelineName, timelineItemId) => {\n    if (timelineItemId) {\n      console.log(`streaming ${instanceName} ${timelineName}: fillGap since`, timelineItemId)\n      /* no await */ fillStreamingGap(instanceName, accessToken, timelineName, timelineItemId)\n    }\n  }\n\n  const onMessage = message => {\n    processMessage(instanceName, timelineName, message)\n  }\n\n  const onOpen = () => {\n    console.log(`streaming ${instanceName} ${timelineName}: opened`)\n    fillGap(timelineName, firstStatusId)\n    if (timelineName === 'home') {\n      // special case - home timeline stream also handles notifications\n      fillGap('notifications', firstNotificationId)\n    }\n  }\n\n  const onClose = () => {\n    console.log(`streaming ${instanceName} ${timelineName}: closed`)\n  }\n\n  const onReconnect = () => {\n    console.log(`streaming ${instanceName} ${timelineName}: reconnected`)\n    // When reconnecting, we recompute the firstStatusId and firstNotificationId because these may have\n    // changed since we first started streaming.\n    const newFirstStatusId = store.getFirstTimelineItemId(instanceName, timelineName)\n    fillGap(timelineName, newFirstStatusId)\n    if (timelineName === 'home') {\n      // special case - home timeline stream also handles notifications\n      const newFirstNotificationId = store.getFirstTimelineItemId(instanceName, 'notifications')\n      fillGap('notifications', newFirstNotificationId)\n    }\n  }\n\n  return new TimelineStream(api, accessToken, timelineName)\n    .on('message', onMessage)\n    .on('open', onOpen)\n    .on('close', onClose)\n    .on('reconnect', onReconnect)\n}\n","import { updateInstanceInfo, updateVerifyCredentialsForInstance } from '../../_actions/instances.js'\nimport { setupListsForInstance } from '../../_actions/lists.js'\nimport { createStream } from '../../_actions/stream/streaming.js'\nimport { updatePushSubscriptionForInstance } from '../../_actions/pushSubscription.js'\nimport { setupCustomEmojiForInstance } from '../../_actions/emoji.js'\nimport { scheduleIdleTask } from '../../_utils/scheduleIdleTask.js'\nimport { mark, stop } from '../../_utils/marks.js'\nimport { store } from '../store.js'\nimport { updateFollowRequestCountIfLockedAccount } from '../../_actions/followRequests.js'\nimport { setupFiltersForInstance } from '../../_actions/filters.js'\n\n// stream to watch for home timeline updates and notifications\nlet currentInstanceStream\n\nasync function refreshInstanceDataAndStream (store, instanceName) {\n  mark(`refreshInstanceDataAndStream-${instanceName}`)\n  await doRefreshInstanceDataAndStream(store, instanceName)\n  stop(`refreshInstanceDataAndStream-${instanceName}`)\n}\n\nfunction currentInstanceChanged (store, instanceName) {\n  return store.get().currentInstance !== instanceName\n}\n\nasync function doRefreshInstanceDataAndStream (store, instanceName) {\n  if (currentInstanceChanged(store, instanceName)) {\n    return\n  }\n\n  await refreshInstanceData(instanceName)\n\n  if (currentInstanceChanged(store, instanceName)) {\n    return\n  }\n\n  const { currentInstanceInfo } = store.get()\n  if (!currentInstanceInfo) {\n    return\n  }\n\n  stream(store, instanceName, currentInstanceInfo)\n}\n\nasync function refreshInstanceData (instanceName) {\n  // these are all low-priority\n  scheduleIdleTask(() => setupCustomEmojiForInstance(instanceName))\n  scheduleIdleTask(() => setupListsForInstance(instanceName))\n  scheduleIdleTask(() => setupFiltersForInstance(instanceName))\n  scheduleIdleTask(() => updatePushSubscriptionForInstance(instanceName))\n\n  // these are the only critical ones\n  await Promise.all([\n    updateInstanceInfo(instanceName),\n    updateVerifyCredentialsForInstance(instanceName).then(() => {\n      // Once we have the verifyCredentials (so we know if the account is locked), lazily update the follow requests\n      scheduleIdleTask(() => updateFollowRequestCountIfLockedAccount(instanceName))\n    })\n  ])\n}\n\nfunction stream (store, instanceName, currentInstanceInfo) {\n  const { accessToken } = store.get()\n  const streamingApi = currentInstanceInfo.urls.streaming_api\n  const firstStatusId = store.getFirstTimelineItemId(instanceName, 'home')\n  const firstNotificationId = store.getFirstTimelineItemId(instanceName, 'notifications')\n\n  currentInstanceStream = createStream(streamingApi, instanceName, accessToken, 'home',\n    firstStatusId, firstNotificationId)\n\n  if (process.env.NODE_ENV !== 'production') {\n    window.currentInstanceStream = currentInstanceStream\n  }\n}\n\nexport function instanceObservers () {\n  store.observe('currentInstance', async (currentInstance) => {\n    if (!process.browser) {\n      return\n    }\n    if (currentInstanceStream) {\n      currentInstanceStream.close()\n      currentInstanceStream = null\n      if (process.env.NODE_ENV !== 'production') {\n        window.currentInstanceStream = null\n      }\n    }\n    if (!currentInstance) {\n      return\n    }\n\n    scheduleIdleTask(() => refreshInstanceDataAndStream(store, currentInstance))\n  })\n}\n","import { updateInstanceInfo } from '../../_actions/instances.js'\nimport { createStream } from '../../_actions/stream/streaming.js'\nimport { store } from '../store.js'\n\nexport function timelineObservers () {\n  // stream to watch for local/federated/etc. updates. home and notification\n  // updates are handled in timelineObservers.js\n  let currentTimelineStream\n\n  function shutdownPreviousStream () {\n    if (currentTimelineStream) {\n      currentTimelineStream.close()\n      currentTimelineStream = null\n      if (process.env.NODE_ENV !== 'production') {\n        window.currentTimelineStream = null\n      }\n    }\n  }\n\n  function shouldObserveTimeline (timeline) {\n    return timeline &&\n      !(\n        timeline !== 'local' &&\n        timeline !== 'federated' &&\n        timeline !== 'direct' &&\n        !timeline.startsWith('list/') &&\n        !timeline.startsWith('tag/')\n      )\n  }\n\n  store.observe('currentTimeline', async (currentTimeline) => {\n    if (!process.browser) {\n      return\n    }\n\n    shutdownPreviousStream()\n\n    if (!shouldObserveTimeline(currentTimeline)) {\n      return\n    }\n\n    const { currentInstance } = store.get()\n    const { accessToken } = store.get()\n    await updateInstanceInfo(currentInstance)\n\n    const currentTimelineIsUnchanged = () => {\n      const {\n        currentInstance: newCurrentInstance,\n        currentTimeline: newCurrentTimeline\n      } = store.get()\n      return newCurrentInstance === currentInstance &&\n        newCurrentTimeline === currentTimeline\n    }\n\n    if (!currentTimelineIsUnchanged()) {\n      return\n    }\n\n    const firstStatusId = store.getFirstTimelineItemId(currentInstance, currentTimeline)\n    const { currentInstanceInfo } = store.get()\n    const streamingApi = currentInstanceInfo.urls.streaming_api\n\n    currentTimelineStream = createStream(streamingApi, currentInstance, accessToken,\n      currentTimeline, firstStatusId)\n\n    if (process.env.NODE_ENV !== 'production') {\n      window.currentTimelineStream = currentTimelineStream\n    }\n  })\n}\n","import { setFavicon } from '../../_utils/setFavicon.js'\nimport { runMediumPriorityTask } from '../../_utils/runMediumPriorityTask.js'\nimport { store } from '../store.js'\n\nlet currentFaviconHasNotifications = false\n\nexport function notificationObservers () {\n  store.observe('hasNotifications', hasNotifications => {\n    if (!process.browser) {\n      return\n    }\n    runMediumPriorityTask(() => {\n      if (currentFaviconHasNotifications === hasNotifications) {\n        return\n      }\n      setFavicon(`/icons/favicon${hasNotifications ? '-alert' : ''}.ico`)\n      currentFaviconHasNotifications = !currentFaviconHasNotifications\n    })\n  })\n}\n","import { scheduleIdleTask } from './scheduleIdleTask.js'\nimport { store } from '../_store/store.js'\nimport { isMobile } from './userAgent/isMobile.js'\n\n// Rough guess at whether this is a \"mobile\" device or not, for the purposes\n// of \"device class\" estimations\n\n// Run a task that doesn't need to be processed immediately, but should\n// probably be delayed if we're on a mobile device. Also run it sooner\n// if we're in a hidden tab, since browsers throttle or don't run setTimeout/rAF/etc.\nexport function runMediumPriorityTask (fn) {\n  if (store.get().pageVisibilityHidden) {\n    fn()\n  } else if (isMobile()) {\n    scheduleIdleTask(fn)\n  } else {\n    requestAnimationFrame(fn)\n  }\n}\n","// borrowed from https://github.com/HenrikJoreteg/favicon-setter\nexport function setFavicon (href) {\n  const faviconId = 'theFavicon'\n  const oldLink = document.getElementById(faviconId)\n\n  if (oldLink.getAttribute('href') === href) {\n    return\n  }\n\n  const link = document.createElement('link')\n  link.id = faviconId\n  link.rel = 'shortcut icon'\n  link.type = 'image/png'\n  link.href = href\n  document.head.removeChild(oldLink)\n  document.head.appendChild(link)\n}\n","export const SEARCH_RESULTS_LIMIT = 4\n","import { store } from '../_store/store.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport * as emojiDatabase from '../_utils/emojiDatabase.js'\nimport { SEARCH_RESULTS_LIMIT } from '../_static/autosuggest.js'\n\nasync function searchEmoji (searchText) {\n  let emojis = await emojiDatabase.findBySearchQuery(searchText)\n\n  const results = []\n\n  if (searchText.startsWith(':') && searchText.endsWith(':')) {\n    // exact shortcode search\n    const shortcode = searchText.substring(1, searchText.length - 1).toLowerCase()\n    emojis = emojis.filter(_ => _.shortcodes.includes(shortcode))\n  }\n\n  for (const emoji of emojis) {\n    if (results.length === SEARCH_RESULTS_LIMIT) {\n      break\n    }\n    if (emoji.url || emoji.unicode) { // emoji.url is a custom emoji\n      results.push(emoji)\n    }\n  }\n  return results\n}\n\nexport function doEmojiSearch (searchText) {\n  let canceled = false\n\n  scheduleIdleTask(async () => {\n    if (canceled) {\n      return\n    }\n    const results = await searchEmoji(searchText)\n    if (canceled) {\n      return\n    }\n    store.setForCurrentAutosuggest({\n      autosuggestType: 'emoji',\n      autosuggestSelected: 0,\n      autosuggestSearchResults: results\n    })\n  })\n\n  return {\n    cancel: () => {\n      canceled = true\n    }\n  }\n}\n","// Throttle network requests to be a good citizen and not issue an HTTP request on every keystroke\nimport { PromiseThrottler } from './PromiseThrottler.js'\n\nconst promiseThrottler = new PromiseThrottler(200) // Mastodon FE also uses 200ms\n\nexport class RequestThrottler {\n  constructor (fetcher) {\n    this._canceled = false\n    this._controller = typeof AbortController === 'function' && new AbortController()\n    this._fetcher = fetcher\n  }\n\n  async request () {\n    if (this._canceled) {\n      throw new Error('canceled')\n    }\n    await promiseThrottler.next()\n    if (this._canceled) {\n      throw new Error('canceled')\n    }\n    const signal = this._controller && this._controller.signal\n    return this._fetcher(signal)\n  }\n\n  cancel () {\n    this._canceled = true\n    if (this._controller) {\n      this._controller.abort()\n      this._controller = null\n    }\n  }\n}\n","// Utility for throttling in the Lodash style (assuming leading: true and trailing: true) but\n// creates a promise.\nexport class PromiseThrottler {\n  constructor (timeout) {\n    this._timeout = timeout\n    this._promise = Promise.resolve()\n  }\n\n  next () {\n    const res = this._promise\n    // update afterwards, so we get a \"leading\" XHR\n    this._promise = this._promise.then(() => new Promise(resolve => setTimeout(resolve, this._timeout)))\n    return res\n  }\n}\n","import { database } from '../_database/database.js'\nimport { store } from '../_store/store.js'\nimport { search } from '../_api/search.js'\nimport { SEARCH_RESULTS_LIMIT } from '../_static/autosuggest.js'\nimport { concat } from '../_utils/arrays.js'\nimport { uniqBy } from '../_thirdparty/lodash/objects.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { RequestThrottler } from '../_utils/RequestThrottler.js'\n\nconst DATABASE_SEARCH_RESULTS_LIMIT = 30\n\nfunction byUsername (a, b) {\n  const usernameA = a.acct.toLowerCase()\n  const usernameB = b.acct.toLowerCase()\n\n  return usernameA < usernameB ? -1 : usernameA === usernameB ? 0 : 1\n}\n\nfunction byAccountId (a) {\n  return a.id\n}\n\nexport function doAccountSearch (searchText) {\n  let canceled = false\n  let localResults\n  let remoteResults\n  const { currentInstance, accessToken } = store.get()\n  const requestThrottler = new RequestThrottler(doSearchAccountsRemotely)\n\n  async function searchAccountsLocally () {\n    localResults = await database.searchAccountsByUsername(\n      currentInstance, searchText.substring(1), DATABASE_SEARCH_RESULTS_LIMIT)\n  }\n\n  async function searchAccountsRemotely () {\n    remoteResults = await requestThrottler.request()\n  }\n\n  async function doSearchAccountsRemotely (signal) {\n    return (await search(\n      currentInstance, accessToken, searchText, false, SEARCH_RESULTS_LIMIT, false, signal\n    )).accounts\n  }\n\n  function mergeAndTruncateResults () {\n    // Always include local results; they are more likely to be relevant\n    // because the user has seen their content before. Otherwise, sort by username.\n    let results = (localResults || [])\n      .slice()\n      .sort(byUsername)\n      .slice(0, SEARCH_RESULTS_LIMIT)\n\n    if (results.length < SEARCH_RESULTS_LIMIT) {\n      const topRemoteResults = (remoteResults || [])\n        .sort(byUsername)\n        .slice(0, SEARCH_RESULTS_LIMIT - results.length)\n      results = concat(results, topRemoteResults)\n      results = uniqBy(results, byAccountId)\n    }\n\n    return results\n  }\n\n  function onNewResults () {\n    if (canceled) {\n      return\n    }\n    const results = mergeAndTruncateResults()\n    store.setForCurrentAutosuggest({\n      autosuggestType: 'account',\n      autosuggestSelected: 0,\n      autosuggestSearchResults: results\n    })\n  }\n\n  function onError (err) {\n    console.warn('ignored autosuggest error', err)\n  }\n\n  scheduleIdleTask(() => {\n    if (canceled) {\n      return\n    }\n    // run the two searches in parallel\n    searchAccountsLocally().then(onNewResults).catch(onError)\n    searchAccountsRemotely().then(onNewResults).catch(onError)\n  })\n\n  return {\n    cancel: () => {\n      canceled = true\n      requestThrottler.cancel()\n    }\n  }\n}\n","import { search } from '../_api/search.js'\nimport { store } from '../_store/store.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { SEARCH_RESULTS_LIMIT } from '../_static/autosuggest.js'\nimport { RequestThrottler } from '../_utils/RequestThrottler.js'\nimport { sum } from '../_utils/lodash-lite.js'\n\nconst HASHTAG_SEARCH_LIMIT = 10\n\nfunction getUses (historyItem) {\n  return historyItem.uses\n}\n\n// Show the most common hashtags first, then sort by name\nfunction byUsesThenName (a, b) {\n  if (a.history && b.history && a.history.length && b.history.length) {\n    const aCount = sum(a.history.map(getUses))\n    const bCount = sum(b.history.map(getUses))\n    return aCount > bCount ? -1 : aCount < bCount ? 1 : 0\n  }\n  return a.name < b.name ? -1 : a.name > b.name ? 1 : 0\n}\n\nexport function doHashtagSearch (searchText) {\n  const { currentInstance, accessToken } = store.get()\n  const requestThrottler = new RequestThrottler(searchHashtags)\n\n  async function searchHashtags (signal) {\n    const results = await search(\n      currentInstance, accessToken, searchText, false, HASHTAG_SEARCH_LIMIT, true, signal\n    )\n    return results.hashtags.sort(byUsesThenName).slice(0, SEARCH_RESULTS_LIMIT)\n  }\n\n  scheduleIdleTask(async () => {\n    try {\n      const results = await requestThrottler.request()\n      store.setForCurrentAutosuggest({\n        autosuggestType: 'hashtag',\n        autosuggestSelected: 0,\n        autosuggestSearchResults: results\n      })\n    } catch (err) {\n      console.warn('ignored autosuggest error', err)\n    }\n  })\n\n  return {\n    cancel: () => {\n      requestThrottler.cancel()\n    }\n  }\n}\n","import { store } from '../store.js'\nimport { doEmojiSearch } from '../../_actions/autosuggestEmojiSearch.js'\nimport { doAccountSearch } from '../../_actions/autosuggestAccountSearch.js'\nimport { doHashtagSearch } from '../../_actions/autosuggestHashtagSearch.js'\n\nfunction resetAutosuggest () {\n  store.setForCurrentAutosuggest({\n    autosuggestSelected: 0,\n    autosuggestSearchResults: []\n  })\n}\n\nexport function autosuggestObservers () {\n  let lastSearch\n\n  store.observe('autosuggestSearchText', async autosuggestSearchText => {\n    // cancel any inflight XHRs or other operations\n    if (lastSearch) {\n      lastSearch.cancel()\n      lastSearch = null\n    }\n    // autosuggestSelecting indicates that the user has pressed Enter or clicked on an item\n    // and the results are being processed. Returning early avoids a flash of searched content.\n    const { composeFocused } = store.get()\n    const autosuggestSelecting = store.getForCurrentAutosuggest('autosuggestSelecting')\n    if (!composeFocused || !autosuggestSearchText || autosuggestSelecting) {\n      resetAutosuggest()\n      return\n    }\n\n    if (autosuggestSearchText.startsWith(':')) { // emoji\n      lastSearch = doEmojiSearch(autosuggestSearchText)\n    } else if (autosuggestSearchText.startsWith('#')) { // hashtag\n      lastSearch = doHashtagSearch(autosuggestSearchText)\n    } else { // account\n      lastSearch = doAccountSearch(autosuggestSearchText)\n    }\n  })\n}\n","import { store } from '../store.js'\n\nconst theScrollbarStyle = process.browser && document.getElementById('theScrollbarStyle')\n\nexport function customScrollbarObservers () {\n  store.observe('disableCustomScrollbars', disableCustomScrollbars => {\n    if (!process.browser) {\n      return\n    }\n\n    // disables or enables the style\n    theScrollbarStyle.setAttribute('media', disableCustomScrollbars ? 'only x' : 'all')\n  }, { init: false }) // init:false because the inline script takes care of it\n}\n","import { store } from '../store.js'\nimport { scheduleIdleTask } from '../../_utils/scheduleIdleTask.js'\nimport { CLEANUP_DELAY, CLEANUP_TIME_AGO } from '../../_static/database.js'\nimport { scheduleInterval } from '../../_utils/scheduleInterval.js'\n\nfunction doCleanup () {\n  // Periodically clean up drafts in localStorage, so they don't grow without bound.\n  // Only do this for replies, so not for the home timeline or the compose modal.\n  const now = Date.now()\n  let changeCount = 0\n  const { composeData } = store.get()\n  for (const instanceComposeData of Object.values(composeData)) {\n    for (const [realm, timelineComposeData] of Object.entries(instanceComposeData)) {\n      if (realm === 'home' || realm === 'dialog') {\n        continue\n      }\n      const ts = timelineComposeData.ts || 0 // if no timestamp set, just assume it's very old (migration behavior)\n      if (now - ts > CLEANUP_TIME_AGO) {\n        delete instanceComposeData[realm]\n        changeCount++\n      }\n    }\n  }\n  console.log('deleted', changeCount, 'old drafts')\n  if (changeCount) {\n    store.set({ composeData })\n  }\n}\n\nfunction doCleanupLazily () {\n  scheduleIdleTask(doCleanup)\n}\n\nexport function cleanup () {\n  scheduleInterval(doCleanupLazily, CLEANUP_DELAY, /* runOnActive */ false)\n}\n","import { store } from '../store.js'\nimport { showComposeDialog } from '../../_actions/showComposeDialog.js'\n\n// If the user is logged in, and if the Service Worker handled a POST and set special data\n// in IndexedDB, then we want to handle it on the home page.\nexport function showComposeDialogObservers () {\n  let observedOnce = false\n  store.observe('currentVerifyCredentials', async verifyCredentials => {\n    if (verifyCredentials && !observedOnce) {\n      // when the verifyCredentials object is available, we can check to see\n      // if the user is trying to share something (or we got here from a shortcut), then share it\n      observedOnce = true\n      const { currentPage } = store.get()\n      if (currentPage === 'home' && new URLSearchParams(location.search).get('compose') === 'true') {\n        await showComposeDialog()\n      }\n    }\n  })\n}\n","import { store } from '../_store/store.js'\nimport { importShowComposeDialog } from '../_components/dialog/asyncDialogs/importShowComposeDialog.js'\nimport { database } from '../_database/database.js'\nimport { doMediaUpload } from './media.js'\n\n// show a compose dialog, typically invoked by the Web Share API or a PWA shortcut\nexport async function showComposeDialog () {\n  const { isUserLoggedIn } = store.get()\n  if (!isUserLoggedIn) {\n    return\n  }\n  const importShowComposeDialogPromise = importShowComposeDialog() // start promise early\n\n  const data = await database.getWebShareData()\n\n  if (data) {\n    await database.deleteWebShareData() // only need this data once; it came from Web Share (service worker)\n  }\n\n  console.log('share data', data)\n  const { title, text, url, file } = (data || {})\n\n  // url is currently ignored on Android, but one can dream\n  // https://web.dev/web-share-target/#verifying-shared-content\n  const composeText = [title, text, url].filter(Boolean).join('\\n\\n')\n  const [showComposeDialog, twitterPost] = await Promise.all([importShowComposeDialogPromise, Promise.resolve(new URLSearchParams(location.search).get('retweet')).then(rt => rt && fetch(Object.assign(new URL(rt), { hostname: 'birdlink.easrng.workers.dev' }).href)).then(e => e.text()).catch(e => console.warn('failed to load tweet', e))])\n\n  store.clearComposeData('dialog')\n  store.setComposeData('dialog', { text: composeText || twitterPost })\n  store.save()\n\n  showComposeDialog()\n  if (file) { // start the upload once the dialog is in view so it shows the loading spinner and everything\n    /* no await */ doMediaUpload('dialog', file)\n  }\n}\n","import { isChrome } from './isChrome.js'\nimport { thunk } from '../thunk.js'\n\n// https://caniuse.com/cookie-store-api\nexport const isChromePre87 = thunk(() => (process.browser && isChrome() && typeof cookieStore === 'undefined'))\n","/**\n * @var {Object} cache\n */\nvar cache = new Map();\n/**\n * Check if emoji is supported with cache\n *\n * @params {string} unicode\n * @returns {boolean}\n */\nfunction isEmojiSupported(unicode) {\n    if (cache.has(unicode)) {\n        return cache.get(unicode);\n    }\n    var supported = isSupported(unicode);\n    cache.set(unicode, supported);\n    return supported;\n}\n/**\n * Request to handle cache directly\n *\n * @params {Map} store\n */\nfunction setCacheHandler(store) {\n    cache = store;\n}\n/**\n * Check if the two pixels parts are perfectly the sames\n *\n * @params {string} unicode\n * @returns {boolean}\n */\nvar isSupported = (function () {\n    var ctx = null;\n    try {\n        ctx = document.createElement('canvas').getContext('2d');\n    }\n    catch (_a) { }\n    // Not in browser env\n    if (!ctx) {\n        return function () { return false; };\n    }\n    var CANVAS_HEIGHT = 25;\n    var CANVAS_WIDTH = 20;\n    var textSize = Math.floor(CANVAS_HEIGHT / 2);\n    // Initialize convas context\n    ctx.font = textSize + 'px Arial, Sans-Serif';\n    ctx.textBaseline = 'top';\n    ctx.canvas.width = CANVAS_WIDTH * 2;\n    ctx.canvas.height = CANVAS_HEIGHT;\n    return function (unicode) {\n        ctx.clearRect(0, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT);\n        // Draw in red on the left\n        ctx.fillStyle = '#FF0000';\n        ctx.fillText(unicode, 0, 22);\n        // Draw in blue on right\n        ctx.fillStyle = '#0000FF';\n        ctx.fillText(unicode, CANVAS_WIDTH, 22);\n        var a = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT).data;\n        var count = a.length;\n        var i = 0;\n        // Search the first visible pixel\n        for (; i < count && !a[i + 3]; i += 4)\n            ;\n        // No visible pixel\n        if (i >= count) {\n            return false;\n        }\n        // Emoji has immutable color, so we check the color of the emoji in two different colors\n        // the result show be the same.\n        var x = CANVAS_WIDTH + ((i / 4) % CANVAS_WIDTH);\n        var y = Math.floor(i / 4 / CANVAS_WIDTH);\n        var b = ctx.getImageData(x, y, 1, 1).data;\n        if (a[i] !== b[0] || a[i + 2] !== b[2]) {\n            return false;\n        }\n        // Some emojis are a contraction of different ones, so if it's not\n        // supported, it will show multiple characters\n        if (ctx.measureText(unicode).width >= CANVAS_WIDTH) {\n            return false;\n        }\n        // Supported\n        return true;\n    };\n})();\n\nexport { isEmojiSupported, setCacheHandler };\n//# sourceMappingURL=is-emoji-supported.js.map\n","import { polyfillCountryFlagEmojis } from 'country-flag-emoji-polyfill'\nimport { store } from '../store.js'\n\nlet polyfilled = false\n\nconst COUNTRY_FLAG_FONT_URL = '/TwemojiCountryFlags.woff2'\n\nexport function countryFlagEmojiPolyfill () {\n  if (!polyfilled) {\n    polyfilled = true\n    const numStylesBefore = document.head.querySelectorAll('style').length\n    polyfillCountryFlagEmojis('Twemoji Mozilla', COUNTRY_FLAG_FONT_URL)\n    const numStylesAfter = document.head.querySelectorAll('style').length\n    // if a style was added, then the polyfill was activated\n    const polyfillActivated = numStylesAfter !== numStylesBefore\n    if (polyfillActivated) {\n      const style = document.createElement('style')\n      style.textContent = `\n        @font-face {\n          font-family: CountryFlagEmojiPolyfill;\n          src: url(${JSON.stringify(COUNTRY_FLAG_FONT_URL)});\n        }\n      `\n      document.head.appendChild(style)\n      // \"Twemoji Mozilla\" is for emoji-picker-element, since it lists that font first.\n      // \"CountryFlagEmojiPolyfill\" is for us so we can set it before everything else in our own font family lists.\n    }\n    store.set({ polyfilledCountryFlagEmoji: polyfillActivated })\n  }\n}\n","import{isEmojiSupported as n}from\"is-emoji-supported\";function t(t=\"Twemoji Country Flags\",e=\"https://cdn.jsdelivr.net/npm/country-flag-emoji-polyfill@0.1/dist/TwemojiCountryFlags.woff2\"){if(n(\"\")&&!n(\"\")){const n=document.createElement(\"style\");return n.textContent=`@font-face {\\n      font-family: \"${t}\";\\n      unicode-range: U+1F1E6-1F1FF, U+1F3F4, U+E0062-E0063, U+E0065, U+E0067,\\n        U+E006C, U+E006E, U+E0073-E0074, U+E0077, U+E007F;\\n      src: url('${e}') format('woff2');\\n      font-display: swap;\\n    }`,document.head.appendChild(n),!0}return!1}export{t as polyfillCountryFlagEmojis};\n//# sourceMappingURL=index.modern.js.map\n","import { store } from '../store.js'\n\nconst centerNavStyle = process.browser && document.getElementById('theCenterNavStyle')\n\nexport function centerNavObservers () {\n  store.observe('centerNav', centerNav => {\n    if (!process.browser) {\n      return\n    }\n\n    // disables or enables the style\n    centerNavStyle.setAttribute('media', centerNav ? 'all' : 'only x')\n  }, { init: false }) // init:false because the inline script takes care of it\n}\n","import { pickBy, get } from '../../_utils/lodash-lite.js'\nimport { getFirstIdFromItemSummaries } from '../../_utils/getIdFromItemSummaries.js'\n\nfunction reorder (timelineName, summaries) {\n  const backupSummaries = summaries\n  try {\n    if (!timelineName.startsWith('status/')) {\n      return summaries\n    }\n    const replyChildren = {}\n    for (const summary of summaries) {\n      if (summary.replyId) {\n        replyChildren[summary.replyId] = replyChildren[summary.replyId] || []\n        replyChildren[summary.replyId].push(summary)\n      }\n    }\n    function flatten (summary, level = 0) {\n      const subtree = summary.id === timelineName.slice('status/'.length)\n      if (subtree) {\n        level = 0\n      }\n      const statuses = [{ ...summary, level }, ...(replyChildren[summary.id] || []).map(e => flatten(e, level + 1))].flat()\n      if (subtree) {\n        statuses[0].subtree = statuses[0].subtree || {}\n        statuses[0].subtree.start = true\n        statuses[statuses.length - 1].subtree = statuses[statuses.length - 1].subtree || {}\n        statuses[statuses.length - 1].subtree.end = true\n      }\n      return statuses\n    }\n    const reordered = summaries.length > 0 ? flatten(summaries[0]) : []\n    const reorderedIds = new Set(reordered.map(e => e.id))\n    const floating = []\n    for (const summary of summaries) {\n      if (!reorderedIds.has(summary.id)) {\n        floating.push(summary)\n        console.warn('reorder is missing a status. this could be a bug or it could not be. who knows.', { summary, summaries, reordered, timelineName, replyChildren })\n      }\n    }\n    return [...reordered, ...floating]\n  } catch (e) {\n    console.error(e)\n    return backupSummaries\n  }\n}\n\nexport function timelineMixins (Store) {\n  Store.prototype.setForTimeline = function (instanceName, timelineName, obj) {\n    const valuesToSet = {}\n    for (const key of Object.keys(obj)) {\n      if (key === 'timelineItemSummaries') {\n        obj[key] = reorder(timelineName, obj[key])\n      }\n      const rootKey = `timelineData_${key}`\n      const root = this.get()[rootKey] || {}\n      const instanceData = root[instanceName] = root[instanceName] || {}\n      instanceData[timelineName] = obj[key]\n      valuesToSet[rootKey] = root\n    }\n\n    this.set(valuesToSet)\n  }\n\n  Store.prototype.getForTimeline = function (instanceName, timelineName, key) {\n    const rootKey = `timelineData_${key}`\n    const root = this.get()[rootKey]\n    return get(root, [instanceName, timelineName])\n  }\n\n  Store.prototype.getAllTimelineData = function (instanceName, key) {\n    const root = this.get()[`timelineData_${key}`] || {}\n    return root[instanceName] || {}\n  }\n\n  Store.prototype.getFirstTimelineItemId = function (instanceName, timelineName) {\n    const summaries = this.getForTimeline(instanceName, timelineName, 'timelineItemSummaries')\n    return getFirstIdFromItemSummaries(summaries)\n  }\n\n  Store.prototype.setForCurrentTimeline = function (obj) {\n    const { currentInstance, currentTimeline } = this.get()\n    this.setForTimeline(currentInstance, currentTimeline, obj)\n  }\n\n  Store.prototype.getThreads = function (instanceName) {\n    const instanceData = this.getAllTimelineData(instanceName, 'timelineItemSummaries')\n\n    return pickBy(instanceData, (value, key) => {\n      return key.startsWith('status/')\n    })\n  }\n\n  Store.prototype.clearTimelineDataForInstance = function (instanceName) {\n    const changes = {}\n    Object.entries(this.get()).forEach(([key, value]) => {\n      if (key.startsWith('timelineData_') && value) {\n        delete value[instanceName]\n        changes[key] = value\n      }\n    })\n    this.set(changes)\n  }\n}\n","function getStatusModifications (store, instanceName) {\n  const { statusModifications } = store.get()\n  statusModifications[instanceName] = Object.assign({\n    favorites: {},\n    reblogs: {},\n    pins: {},\n    bookmarks: {},\n    reactions: {}\n  }, statusModifications[instanceName] || {})\n  return statusModifications\n}\n\nfunction setStatusModification (store, instanceName, statusId, key, value) {\n  const statusModifications = getStatusModifications(store, instanceName)\n  statusModifications[instanceName][key][statusId] = value\n  store.set({ statusModifications })\n}\n\nexport function statusMixins (Store) {\n  Store.prototype.setStatusFavorited = function (instanceName, statusId, favorited) {\n    setStatusModification(this, instanceName, statusId, 'favorites', favorited)\n  }\n\n  Store.prototype.setStatusReblogged = function (instanceName, statusId, reblogged) {\n    setStatusModification(this, instanceName, statusId, 'reblogs', reblogged)\n  }\n\n  Store.prototype.setStatusPinned = function (instanceName, statusId, pinned) {\n    setStatusModification(this, instanceName, statusId, 'pins', pinned)\n  }\n\n  Store.prototype.setStatusBookmarked = function (instanceName, statusId, bookmarked) {\n    setStatusModification(this, instanceName, statusId, 'bookmarks', bookmarked)\n  }\n\n  Store.prototype.setStatusReacted = function (instanceName, statusId, reaction, state) {\n    setStatusModification(this, instanceName, statusId + '-' + reaction.name, 'reactions', state)\n  }\n}\n","import { timelineMixins } from './timelineMixins.js'\nimport { statusMixins } from './statusMixins.js'\nimport { autosuggestMixins } from './autosuggestMixins.js'\nimport { composeMixins } from './composeMixins.js'\nimport { PinaforeStore as Store } from '../store.js'\n\nexport function loggedInMixins () {\n  composeMixins(Store)\n  timelineMixins(Store)\n  statusMixins(Store)\n  autosuggestMixins(Store)\n}\n","import { get } from '../../_utils/lodash-lite.js'\n\nexport function composeMixins (Store) {\n  Store.prototype.setComposeData = function (realm, obj) {\n    const { composeData, currentInstance } = this.get()\n    const instanceNameData = composeData[currentInstance] = composeData[currentInstance] || {}\n    instanceNameData[realm] = Object.assign(\n      instanceNameData[realm] || {},\n      { ts: Date.now() },\n      obj\n    )\n    this.set({ composeData })\n  }\n\n  Store.prototype.getComposeData = function (realm, key) {\n    const { composeData, currentInstance } = this.get()\n    return get(composeData, [currentInstance, realm, key])\n  }\n\n  Store.prototype.clearComposeData = function (realm) {\n    const { composeData, currentInstance } = this.get()\n    if (composeData && composeData[currentInstance]) {\n      delete composeData[currentInstance][realm]\n    }\n    this.set({ composeData })\n  }\n}\n","import { get } from '../../_utils/lodash-lite.js'\n\nexport function autosuggestMixins (Store) {\n  Store.prototype.setForAutosuggest = function (instanceName, realm, obj) {\n    const valuesToSet = {}\n    for (const key of Object.keys(obj)) {\n      const rootKey = `autosuggestData_${key}`\n      const root = this.get()[rootKey] || {}\n      const instanceData = root[instanceName] = root[instanceName] || {}\n      instanceData[realm] = obj[key]\n      valuesToSet[rootKey] = root\n    }\n\n    this.set(valuesToSet)\n  }\n\n  Store.prototype.setForCurrentAutosuggest = function (obj) {\n    const { currentInstance, currentComposeRealm } = this.get()\n    this.setForAutosuggest(currentInstance, currentComposeRealm, obj)\n  }\n\n  Store.prototype.getForCurrentAutosuggest = function (key) {\n    const { currentInstance, currentComposeRealm } = this.get()\n    return get(this.get()[`autosuggestData_${key}`], [currentInstance, currentComposeRealm])\n  }\n\n  Store.prototype.clearAutosuggestDataForInstance = function (instanceName) {\n    const changes = {}\n    Object.entries(this.get()).forEach(([key, value]) => {\n      if (key.startsWith('autosuggestData_') && value) {\n        delete value[instanceName]\n        changes[key] = value\n      }\n    })\n    this.set(changes)\n  }\n}\n","// like loggedInObservers.js, these can be lazy-loaded once the user is actually logged in\nimport { timelineComputations } from './timelineComputations.js'\nimport { autosuggestComputations } from './autosuggestComputations.js'\nimport { store } from '../store.js'\nimport { wordFilterComputations } from './wordFilterComputations.js'\nimport { badgeComputations } from './badgeComputations.js'\nimport { timelineFilterComputations } from './timelineFilterComputations.js'\nimport { mark, stop } from '../../_utils/marks.js'\n\nexport function loggedInComputations () {\n  mark('loggedInComputations')\n  wordFilterComputations(store)\n  timelineComputations(store)\n  timelineFilterComputations(store)\n  badgeComputations(store)\n  autosuggestComputations(store)\n  stop('loggedInComputations')\n}\n","import { createRegexFromFilters } from '../../_utils/createRegexFromFilters.js'\nimport { WORD_FILTER_CONTEXTS } from '../../_static/wordFilters.js'\n\nexport function wordFilterComputations (store) {\n  // unexpiredInstanceFilters is calculated based on `now` and `instanceFilters`,\n  // but it's computed with observers rather than compute() to avoid excessive recalcs\n  store.compute(\n    'currentFilters',\n    ['unexpiredInstanceFilters', 'currentInstance'],\n    (unexpiredInstanceFilters, currentInstance) => unexpiredInstanceFilters[currentInstance] || []\n  )\n\n  store.compute('unexpiredInstanceFilterRegexes', ['unexpiredInstanceFilters'], unexpiredInstanceFilters => {\n    return Object.fromEntries(Object.entries(unexpiredInstanceFilters).map(([instanceName, filters]) => {\n      const contextsToRegex = Object.fromEntries(WORD_FILTER_CONTEXTS.map(context => {\n        const filtersForThisContext = filters.filter(_ => _.context.includes(context))\n        if (!filtersForThisContext.length) {\n          return undefined // don't bother even adding it to the map\n        }\n        const regex = createRegexFromFilters(filtersForThisContext)\n        return [context, regex]\n      }).filter(Boolean))\n      return [instanceName, contextsToRegex]\n    }))\n  })\n}\n","import { get } from '../../_utils/lodash-lite.js'\n\nexport function badgeComputations (store) {\n  store.compute('numberOfNotifications',\n    ['filteredTimelineNotificationItemSummaries', 'disableNotificationBadge'],\n    (filteredTimelineNotificationItemSummaries, disableNotificationBadge) => (\n      (!disableNotificationBadge && filteredTimelineNotificationItemSummaries)\n        ? filteredTimelineNotificationItemSummaries.length\n        : 0\n    )\n  )\n  store.compute('hasNotifications',\n    ['numberOfNotifications', 'currentPage'],\n    (numberOfNotifications, currentPage) => (\n      currentPage !== 'notifications' && !!numberOfNotifications\n    )\n  )\n\n  store.compute('numberOfFollowRequests',\n    ['followRequestCounts', 'currentInstance', 'disableFollowRequestCount'],\n    (followRequestCounts, currentInstance, disableFollowRequestCount) => disableFollowRequestCount ? 0 : get(followRequestCounts, [currentInstance], 0)\n  )\n\n  store.compute('hasFollowRequests',\n    ['numberOfFollowRequests'],\n    (numberOfFollowRequests) => !!numberOfFollowRequests\n  )\n\n  store.compute('badgeNumber',\n    ['numberOfFollowRequests', 'numberOfNotifications'],\n    (numberOfFollowRequests, numberOfNotifications) => (numberOfFollowRequests + numberOfNotifications)\n  )\n}\n","import { instanceObservers } from './instanceObservers.js'\nimport { timelineObservers } from './timelineObservers.js'\nimport { notificationObservers } from './notificationObservers.js'\nimport { autosuggestObservers } from './autosuggestObservers.js'\nimport { notificationPermissionObservers } from './notificationPermissionObservers.js'\nimport { customScrollbarObservers } from './customScrollbarObservers.js'\nimport { customEmojiObservers } from './customEmojiObservers.js'\nimport { cleanup } from './cleanup.js'\nimport { wordFilterObservers } from './wordFilterObservers.js'\nimport { showComposeDialogObservers } from './showComposeDialogObservers.js'\nimport { badgeObservers } from './badgeObservers.js'\nimport { countryFlagEmojiPolyfill } from './countryFlagEmojiPolyfill.js'\nimport { centerNavObservers } from './centerNavObservers.js'\n\n// These observers can be lazy-loaded when the user is actually logged in.\n// Prevents circular dependencies and reduces the size of main.js\nexport function loggedInObservers () {\n  instanceObservers()\n  timelineObservers()\n  wordFilterObservers()\n  notificationObservers()\n  autosuggestObservers()\n  notificationPermissionObservers()\n  customScrollbarObservers()\n  centerNavObservers()\n  customEmojiObservers()\n  showComposeDialogObservers()\n  badgeObservers()\n  cleanup()\n  countryFlagEmojiPolyfill()\n}\n","import { on } from '../../_utils/eventBus.js'\nimport { updateFiltersForInstance } from '../../_actions/filters.js'\nimport { store } from '../store.js'\nimport { isEqual } from '../../_thirdparty/lodash/objects.js'\nimport { computeFilterContextsForStatusOrNotification } from '../../_utils/computeFilterContextsForStatusOrNotification.js'\nimport { database } from '../../_database/database.js'\nimport { mark, stop } from '../../_utils/marks.js'\n\nexport function wordFilterObservers () {\n  if (!process.browser) {\n    return\n  }\n  on('wordFiltersChanged', instanceName => {\n    /* no await */ updateFiltersForInstance(instanceName)\n  })\n\n  // compute `unexpiredInstanceFilters` based on `now` and `instanceFilters`. `now` updates every 10 seconds.\n  function updateUnexpiredInstanceFiltersIfUnchanged (now, instanceFilters) {\n    const unexpiredInstanceFilters = Object.fromEntries(Object.entries(instanceFilters).map(([instanceName, filters]) => {\n      const unexpiredFilters = filters.filter(filter => (\n        !filter.expires_at || new Date(filter.expires_at).getTime() >= now\n      ))\n      return [instanceName, unexpiredFilters]\n    }))\n\n    // don't force an update/recalc if nothing changed\n    if (!isEqual(store.get().unexpiredInstanceFilters, unexpiredInstanceFilters)) {\n      console.log('updated unexpiredInstanceFilters', unexpiredInstanceFilters)\n      store.set({ unexpiredInstanceFilters })\n    }\n  }\n\n  store.observe('now', now => {\n    const { instanceFilters } = store.get()\n    updateUnexpiredInstanceFiltersIfUnchanged(now, instanceFilters)\n  })\n\n  store.observe('instanceFilters', instanceFilters => {\n    const { now } = store.get()\n    updateUnexpiredInstanceFiltersIfUnchanged(now, instanceFilters)\n  })\n\n  store.observe('unexpiredInstanceFilterRegexes', async unexpiredInstanceFilterRegexes => {\n    console.log('unexpiredInstanceFilterRegexes changed, recomputing filterContexts')\n    mark('update timeline item summary filter contexts')\n    // Whenever the filters change, we need to re-compute the filterContexts on the TimelineSummaries.\n    // This is a bit of an odd design, but we do it for perf. See timelineItemToSummary.js for details.\n    let {\n      timelineData_timelineItemSummaries: timelineItemSummaries,\n      timelineData_timelineItemSummariesToAdd: timelineItemSummariesToAdd\n    } = store.get()\n\n    timelineItemSummaries = timelineItemSummaries || {}\n    timelineItemSummariesToAdd = timelineItemSummariesToAdd || {}\n\n    let somethingChanged = false\n\n    await Promise.all(Object.entries(unexpiredInstanceFilterRegexes).map(async ([instanceName, contextsToRegex]) => {\n      const timelinesToSummaries = timelineItemSummaries[instanceName] || {}\n      const timelinesToSummariesToAdd = timelineItemSummariesToAdd[instanceName] || {}\n      const summariesToUpdate = [\n        ...(Object.values(timelinesToSummaries).flat()),\n        ...(Object.values(timelinesToSummariesToAdd).flat())\n      ]\n      console.log(`Attempting to update filters for ${summariesToUpdate.length} item summaries`)\n      await Promise.all(summariesToUpdate.map(async summary => {\n        try {\n          const isNotification = summary.type\n          const item = await (isNotification\n            ? database.getNotification(instanceName, summary.id)\n            : database.getStatus(instanceName, summary.id)\n          )\n          const newFilterContexts = computeFilterContextsForStatusOrNotification(item, contextsToRegex)\n          if (!isEqual(summary.filterContexts, newFilterContexts)) {\n            somethingChanged = true\n            summary.filterContexts = newFilterContexts\n          }\n        } catch (err) {\n          console.error(err)\n          // not stored in the database anymore, just ignore\n        }\n      }))\n    }))\n\n    // The previous was an async operation, so the timelinesItemSummaries or timelineItemSummariesToAdd\n    // may have changed. But we need to make sure that the filterContexts are updated in the store\n    // So just force an update here.\n    if (somethingChanged) {\n      console.log('Word filters changed, forcing an update')\n      // eslint-disable-next-line camelcase\n      const { timelineData_timelineItemSummaries, timelineData_timelineItemSummariesToAdd } = store.get()\n      // eslint-disable-next-line camelcase\n      store.set({ timelineData_timelineItemSummaries, timelineData_timelineItemSummariesToAdd })\n    }\n    stop('update timeline item summary filter contexts')\n  }, { init: false })\n}\n","import { store } from '../store.js'\n\nexport function notificationPermissionObservers () {\n  if (!process.browser || !navigator.permissions || !navigator.permissions.query) {\n    return\n  }\n\n  navigator.permissions.query({ name: 'notifications' }).then(permission => {\n    store.set({ notificationPermission: permission.state })\n\n    permission.onchange = event => {\n      store.set({ notificationPermission: event.target.state })\n    }\n  })\n}\n","import { store } from '../store.js'\nimport * as emojiDatabase from '../../_utils/emojiDatabase.js'\nimport { convertCustomEmojiToEmojiPickerFormat } from '../../_utils/convertCustomEmojiToEmojiPickerFormat.js'\n\nexport function customEmojiObservers () {\n  if (!process.browser) {\n    return\n  }\n\n  function setEmoji (currentEmoji, autoplayGifs) {\n    const customEmojiInEmojiPickerFormat = convertCustomEmojiToEmojiPickerFormat(currentEmoji, autoplayGifs)\n    emojiDatabase.setCustomEmoji(customEmojiInEmojiPickerFormat)\n  }\n\n  store.observe('currentCustomEmoji', currentCustomEmoji => {\n    setEmoji(currentCustomEmoji, store.get().autoplayGifs)\n  }, { init: false })\n\n  store.observe('autoplayGifs', autoplayGifs => {\n    setEmoji(store.get().currentCustomEmoji, autoplayGifs)\n  }, { init: false })\n}\n","import { store } from '../store.js'\nimport { isChromePre87 } from '../../_utils/userAgent/isChromePre87.js'\n\nexport function badgeObservers () {\n  if (!process.browser) {\n    return\n  }\n  // Chrome 86 on Linux in Circle CI seems to hang just by checking for this... not worth supporting.\n  if (isChromePre87() || !('setAppBadge' in navigator)) {\n    return\n  }\n  store.observe('badgeNumber', badgeNumber => {\n    if (badgeNumber) {\n      navigator.setAppBadge(badgeNumber)\n    } else {\n      navigator.clearAppBadge()\n    }\n  })\n}\n","export function convertCustomEmojiToEmojiPickerFormat (customEmoji, autoplayGifs) {\n  if (!customEmoji) {\n    return []\n  }\n  return customEmoji.filter(emoji => emoji.visible_in_picker).map(emoji => ({\n    name: emoji.shortcode,\n    shortcodes: [emoji.shortcode],\n    url: autoplayGifs ? emoji.url : emoji.static_url,\n    category: emoji.category\n  }))\n}\n","import Database from 'emoji-picker-element/database.js'\nimport { lifecycle } from './lifecycle.js'\nimport { emojiPickerLocale, emojiPickerDataSource } from '../_static/emojiPickerIntl.js'\n\nlet database\n\nfunction applySkinToneToEmoji (emoji, skinTone) {\n  if (!emoji || emoji.url) { // nonexistent or custom emoji\n    return emoji\n  }\n  const res = {\n    unicode: emoji.unicode,\n    shortcodes: emoji.shortcodes\n  }\n  if (skinTone > 0 && emoji.skins) { // non-default skin tone\n    const tone = emoji.skins.find(_ => _.tone === skinTone)\n    if (tone) {\n      res.unicode = tone.unicode\n    }\n  }\n  return res\n}\n\nexport function init () {\n  if (!database) {\n    database = new Database({\n      locale: emojiPickerLocale,\n      dataSource: emojiPickerDataSource\n    })\n  }\n}\n\nexport function setCustomEmoji (customEmoji) {\n  init()\n  database.customEmoji = customEmoji\n}\n\nexport async function findByUnicodeOrName (unicodeOrName) {\n  init()\n  return database.getEmojiByUnicodeOrName(unicodeOrName)\n}\n\nexport async function findBySearchQuery (query) {\n  init()\n  const [emojis, skinTone] = await Promise.all([\n    database.getEmojiBySearchQuery(query),\n    database.getPreferredSkinTone()\n  ])\n  return emojis.map(emoji => applySkinToneToEmoji(emoji, skinTone))\n}\n\nif (process.browser) {\n  lifecycle.addEventListener('statechange', event => {\n    if (event.newState === 'frozen' && database) { // page is frozen, close IDB connections\n      console.log('closed emoji DB')\n      database.close()\n    }\n  })\n}\n","import { thunk } from '../thunk.js'\n\nexport const isMobile = thunk(() => process.browser && navigator.userAgent.match(/(?:iPhone|iPod|iPad|Android|KAIOS)/))\n"],"names":["filterItemIdsFromTimelines","instanceName","timelineFilter","idFilter","summaryFilter","_","id","forEach","key","timelineData","store","getAllTimelineData","Object","keys","timelineName","summaries","filteredSummaries","filter","setForTimeline","async","deleteStatusesAndNotifications","statusIdsToDelete","notificationIdsToDelete","idsToDelete","idsToDeleteSet","Set","has","deleteStatusIdsFromStore","deleteNotificationIdsFromStore","doDeleteStatus","statusId","rebloggedIds","getReblogsForStatus","getIdsThatRebloggedThisStatus","Array","from","concat","Boolean","statusIds","getNotificationIdsForStatuses","deleteStatus","scheduleIdleTask","updateFollowRequestCountIfLockedAccount","verifyCredentials","loggedInInstances","get","accessToken","access_token","length","getFollowRequestCount","followReqsCount","setFollowRequestCount","followRequestCounts","set","syncLists","syncMethod","url","timeout","getLists","database","lists","setLists","instanceLists","updateListsForInstance","setupListsForInstance","getFollowRequests","limit","getTimeline","timeline","maxId","since","timelineUrlName","startsWith","Error","getTimelineUrlPath","split","params","since_id","max_id","local","endsWith","only_media","exclude_replies","exclude_types","json","items","headers","map","item","last_status","getVerifyCredentials","getAccount","accountId","importShowComposeDialog","then","mod","default","CLEANUP_TIME_AGO","CLEANUP_DELAY","emojiPickerDataSource","emojiPickerI18n","emojiPickerLocale","WORD_FILTER_CONTEXT_HOME","WORD_FILTER_CONTEXT_NOTIFICATIONS","WORD_FILTER_CONTEXT_PUBLIC","WORD_FILTER_CONTEXT_THREAD","WORD_FILTER_CONTEXT_ACCOUNT","WORD_FILTER_CONTEXTS","WORD_FILTER_EXPIRY_OPTIONS","value","label","WORD_FILTER_EXPIRY_DEFAULT","getFirstIdFromItemSummaries","itemSummaries","computeForTimeline","defaultValue","compute","currentInstance","currentTimeline","root","MIN_PREFIX_LENGTH","REGEX","RegExp","computeForAutosuggest","currentComposeRealm","createRegexFromFilters","filters","expr","phrase","replace","whole_word","test","join","createFilterFunction","showReblogs","showReplies","showFollows","showFavs","showMentions","showPolls","showSubscriptions","wordFilterContext","filterContexts","includes","type","reblogId","replyId","computeTimelineFilter","computationName","timelinesToSettingsKeys","instanceSettings","settingsKey","computeNotificationFilter","Backoff","constructor","onReady","this","attempts","backoff","delay","fibonacci","setTimeout","attempt","current","prev","index","next","Math","min","floor","random","reset","WebSocketClient","protocols","options","reconnectEnabled","listeners","onBackoffReady","bind","connect","open","reconnect","isReconnect","binaryType","ws","WebSocket","onclose","onCloseCallback","onerror","onErrorCallback","onmessage","onMessageCallback","onopen","onOpenCallback","e","apply","arguments","code","onreconnect","readyState","close","reason","send","data","listener","CONNECTING","OPEN","CLOSING","CLOSED","TimelineStream","EventEmitter","streamingApi","super","_streamingApi","_accessToken","_timeline","_onStateChange","_onOnline","_onOffline","_onForcedOnlineStateChange","_setupWebSocket","_setupEvents","_closed","_closeWebSocket","_teardownEvents","event","removeAllListeners","_ws","emit","stream","getStreamName","tag","slice","list","getStreamUrl","_opened","safeParse","lifecycle","addEventListener","eventBus","on","window","removeEventListener","removeListener","_pause","_unpause","newState","oldState","_tryToReconnect","online","updateStatus","newStatus","doUpdateStatus","KNOWN_EVENTS","TIMELINE_GAP_BATCH_SIZE","MAX_NUM_REQUESTS","createStream","api","firstStatusId","firstNotificationId","fillGap","timelineItemId","firstTimelineItemId","newTimelineItems","numRequests","fillStreamingGap","message","payload","JSON","parse","d","addStatusOrNotification","s","console","warn","processMessage","newFirstStatusId","getFirstTimelineItemId","newFirstNotificationId","currentInstanceStream","refreshInstanceDataAndStream","currentInstanceChanged","Promise","all","refreshInstanceData","currentInstanceInfo","urls","streaming_api","doRefreshInstanceDataAndStream","timelineObservers","currentTimelineStream","observe","newCurrentInstance","newCurrentTimeline","currentTimelineIsUnchanged","currentFaviconHasNotifications","notificationObservers","hasNotifications","fn","href","faviconId","oldLink","document","getElementById","getAttribute","link","createElement","rel","head","removeChild","appendChild","setFavicon","pageVisibilityHidden","isMobile","requestAnimationFrame","SEARCH_RESULTS_LIMIT","doEmojiSearch","searchText","canceled","results","emojis","emojiDatabase","shortcode","substring","toLowerCase","shortcodes","emoji","unicode","push","searchEmoji","setForCurrentAutosuggest","autosuggestType","autosuggestSelected","autosuggestSearchResults","cancel","promiseThrottler","_timeout","_promise","resolve","res","RequestThrottler","fetcher","_canceled","_controller","AbortController","_fetcher","request","signal","abort","DATABASE_SEARCH_RESULTS_LIMIT","byUsername","a","b","usernameA","acct","usernameB","byAccountId","doAccountSearch","localResults","remoteResults","requestThrottler","search","accounts","onNewResults","sort","topRemoteResults","mergeAndTruncateResults","onError","err","searchAccountsByUsername","searchAccountsLocally","catch","searchAccountsRemotely","HASHTAG_SEARCH_LIMIT","getUses","historyItem","uses","byUsesThenName","history","aCount","bCount","name","autosuggestObservers","lastSearch","composeFocused","autosuggestSelecting","getForCurrentAutosuggest","autosuggestSearchText","hashtags","doHashtagSearch","theScrollbarStyle","doCleanup","now","Date","changeCount","composeData","instanceComposeData","values","realm","timelineComposeData","entries","ts","doCleanupLazily","showComposeDialogObservers","observedOnce","currentPage","URLSearchParams","location","isUserLoggedIn","importShowComposeDialogPromise","getWebShareData","deleteWebShareData","title","text","file","composeText","showComposeDialog","twitterPost","rt","fetch","assign","URL","hostname","clearComposeData","setComposeData","save","isChromePre87","isChrome","i","cookieStore","cache","Map","isEmojiSupported","supported","isSupported","ctx","getContext","_a","CANVAS_WIDTH","textSize","CANVAS_HEIGHT","font","textBaseline","canvas","width","height","clearRect","fillStyle","fillText","getImageData","count","x","y","measureText","polyfilled","COUNTRY_FLAG_FONT_URL","countryFlagEmojiPolyfill","numStylesBefore","querySelectorAll","t","n","textContent","polyfillActivated","style","stringify","polyfilledCountryFlagEmoji","centerNavStyle","reorder","backupSummaries","replyChildren","summary","flatten","level","subtree","statuses","flat","start","end","reordered","reorderedIds","floating","error","setStatusModification","statusModifications","favorites","reblogs","pins","bookmarks","reactions","getStatusModifications","Store","prototype","obj","instanceNameData","getComposeData","valuesToSet","rootKey","getForTimeline","setForCurrentTimeline","getThreads","instanceData","clearTimelineDataForInstance","changes","timelineMixins","setStatusFavorited","favorited","setStatusReblogged","reblogged","setStatusPinned","pinned","setStatusBookmarked","bookmarked","setStatusReacted","reaction","state","statusMixins","setForAutosuggest","clearAutosuggestDataForInstance","autosuggestMixins","unexpiredInstanceFilters","fromEntries","context","filtersForThisContext","regex","wordFilterComputations","len","timelineItemSummaries","timelineComputations","home","notifications","timelineFilterFunction","timelineItemSummariesToAdd","timelineNotificationItemSummaries","timelineNotificationFilterFunction","timelineFilterComputations","filteredTimelineNotificationItemSummaries","disableNotificationBadge","numberOfNotifications","disableFollowRequestCount","numberOfFollowRequests","badgeComputations","currentComposeData","currentComposeText","composeSelectionStart","selectionStart","match","autosuggestNumSearchResults","autosuggestComputations","updateUnexpiredInstanceFiltersIfUnchanged","instanceFilters","expires_at","getTime","timelineData_timelineItemSummaries","timelineData_timelineItemSummariesToAdd","somethingChanged","unexpiredInstanceFilterRegexes","contextsToRegex","timelinesToSummaries","timelinesToSummariesToAdd","summariesToUpdate","isNotification","getNotification","getStatus","newFilterContexts","computeFilterContextsForStatusOrNotification","init","wordFilterObservers","navigator","permissions","query","permission","notificationPermission","onchange","target","disableCustomScrollbars","setAttribute","centerNav","setEmoji","currentEmoji","autoplayGifs","customEmojiInEmojiPickerFormat","convertCustomEmojiToEmojiPickerFormat","currentCustomEmoji","customEmojiObservers","badgeNumber","setAppBadge","clearAppBadge","scheduleInterval","customEmoji","visible_in_picker","static_url","category","locale","dataSource","setCustomEmoji","findByUnicodeOrName","unicodeOrName","getEmojiByUnicodeOrName","findBySearchQuery","skinTone","getEmojiBySearchQuery","getPreferredSkinTone","skins","tone","find","applySkinToneToEmoji","userAgent"],"sourceRoot":""}
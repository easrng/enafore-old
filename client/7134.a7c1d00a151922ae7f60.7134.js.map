{"version":3,"file":"7134.a7c1d00a151922ae7f60.7134.js","mappings":"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","sources":["webpack:///./src/routes/_database/constants.js","webpack:///./src/routes/_database/cache.js","webpack:///./src/routes/_thirdparty/idb-keyval/idb-keyval.js","webpack:///./src/routes/_database/knownInstances.js","webpack:///./src/routes/_database/migrations.js","webpack:///./src/routes/_database/databaseLifecycle.js","webpack:///./src/routes/_database/helpers.js","webpack:///./src/routes/_database/keys.js","webpack:///./src/routes/_database/accounts.js","webpack:///./src/routes/_database/clear.js","webpack:///./src/routes/_database/timelines/lookup.js","webpack:///./src/routes/_database/timelines/cacheStatus.js","webpack:///./src/routes/_database/utils.js","webpack:///./src/routes/_database/cleanup.js","webpack:///./src/routes/_database/timelines/insertion.js","webpack:///./src/routes/_database/timelines/fetchAccount.js","webpack:///./src/routes/_database/timelines/fetchStatus.js","webpack:///./src/routes/_database/timelines/pinnedStatuses.js","webpack:///./src/routes/_database/timelines/fetchNotification.js","webpack:///./src/routes/_database/timelines/pagination.js","webpack:///./src/routes/_database/timelines/getStatusOrNotification.js","webpack:///./src/routes/_database/timelines/updateStatus.js","webpack:///./src/routes/_database/timelines/deletion.js","webpack:///./src/routes/_database/meta.js","webpack:///./src/routes/_database/relationships.js","webpack:///./src/routes/_static/share.js","webpack:///./src/routes/_database/webShare.js","webpack:///./src/routes/_database/theme.js","webpack:///./src/routes/_database/mediaUploadFileCache.js","webpack:///./src/routes/_static/database.js","webpack:///./src/routes/_static/timelines.js","webpack:///./src/routes/_thirdparty/quick-lru/quick-lru.js","webpack:///./src/routes/_utils/statusIdSorting.js"],"sourcesContent":["export const STATUSES_STORE = 'statuses-v4'\nexport const STATUS_TIMELINES_STORE = 'status_timelines-v4'\nexport const META_STORE = 'meta-v4'\nexport const ACCOUNTS_STORE = 'accounts-v4'\nexport const RELATIONSHIPS_STORE = 'relationships-v4'\nexport const NOTIFICATIONS_STORE = 'notifications-v4'\nexport const NOTIFICATION_TIMELINES_STORE = 'notification_timelines-v4'\nexport const PINNED_STATUSES_STORE = 'pinned_statuses-v4'\nexport const THREADS_STORE = 'threads-v4'\n\nexport const TIMESTAMP = '__pinafore_ts'\nexport const ACCOUNT_ID = '__pinafore_acct_id'\nexport const STATUS_ID = '__pinafore_status_id'\nexport const REBLOG_ID = '__pinafore_reblog_id'\nexport const USERNAME_LOWERCASE = '__pinafore_acct_lc'\n\nexport const DB_VERSION_INITIAL = 9\nexport const DB_VERSION_SEARCH_ACCOUNTS = 10\nexport const DB_VERSION_SNOWFLAKE_IDS = 12 // 11 skipped because of mistake deployed to dev.pinafore.social\n\n// Using an object for these so that unit tests can change them\nexport const DB_VERSION_CURRENT = { version: 12 }\nexport const CURRENT_TIME = { now: () => Date.now() }\n","import { QuickLRU } from '../_thirdparty/quick-lru/quick-lru.js'\n\nexport const statusesCache = {\n  maxSize: 100,\n  caches: {}\n}\nexport const accountsCache = {\n  maxSize: 50,\n  caches: {}\n}\nexport const relationshipsCache = {\n  maxSize: 20,\n  caches: {}\n}\nexport const metaCache = {\n  maxSize: 20,\n  caches: {}\n}\nexport const notificationsCache = {\n  maxSize: 50,\n  caches: {}\n}\n\nif (process.browser && process.env.NODE_ENV !== 'production') {\n  (typeof self !== 'undefined' ? self : window).cacheStats = {\n    statuses: statusesCache,\n    accounts: accountsCache,\n    relationships: relationshipsCache,\n    meta: metaCache,\n    notifications: notificationsCache\n  }\n}\n\nfunction getOrCreateInstanceCache (cache, instanceName) {\n  let cached = cache.caches[instanceName]\n  if (!cached) {\n    cached = cache.caches[instanceName] = new QuickLRU({ maxSize: cache.maxSize })\n  }\n  return cached\n}\n\nexport function clearCache (cache, instanceName) {\n  delete cache.caches[instanceName]\n}\nexport function clearAllCaches (instanceName) {\n  const allCaches = [statusesCache, accountsCache, relationshipsCache, metaCache, notificationsCache]\n  for (const cache of allCaches) {\n    clearCache(cache, instanceName)\n  }\n}\nexport function setInCache (cache, instanceName, key, value) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  return instanceCache.set(key, value)\n}\n\nexport function getInCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  return instanceCache.get(key)\n}\n\nexport function hasInCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  const res = instanceCache.has(key)\n  if (process.env.NODE_ENV !== 'production') {\n    if (res) {\n      cache.hits = (cache.hits || 0) + 1\n    } else {\n      cache.misses = (cache.misses || 0) + 1\n    }\n  }\n  return res\n}\n\nexport function deleteFromCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  instanceCache.delete(key)\n}\n","// Forked from https://github.com/jakearchibald/idb-keyval/commit/ea7d507\n// Adds a function for closing the database, ala https://github.com/jakearchibald/idb-keyval/pull/65\n// Also hooks it into the lifecycle frozen event\nimport { lifecycle } from '../../_utils/lifecycle.js'\n\nclass Store {\n  constructor (dbName = 'keyval-store', storeName = 'keyval') {\n    this.storeName = storeName\n    this._dbName = dbName\n    this._storeName = storeName\n    this._init()\n  }\n\n  _withIDBStore (type, callback) {\n    this._init()\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, type)\n      transaction.oncomplete = () => resolve()\n      transaction.onabort = transaction.onerror = () => reject(transaction.error)\n      callback(transaction.objectStore(this.storeName))\n    }))\n  }\n\n  _init () {\n    if (this._dbp) {\n      return\n    }\n    this._dbp = new Promise((resolve, reject) => {\n      const openreq = indexedDB.open(this._dbName, 1)\n      openreq.onerror = () => reject(openreq.error)\n      openreq.onsuccess = () => resolve(openreq.result)\n      // First time setup: create an empty object store\n      openreq.onupgradeneeded = () => {\n        openreq.result.createObjectStore(this._storeName)\n      }\n    })\n  }\n\n  _close () {\n    this._init()\n    return this._dbp.then(db => {\n      db.close()\n      this._dbp = undefined\n    })\n  }\n}\n\nlet store\n\nfunction getDefaultStore () {\n  if (!store) {\n    store = new Store()\n  }\n  return store\n}\n\nfunction get (key) {\n  const store = getDefaultStore()\n  let req\n  return store._withIDBStore('readonly', store => {\n    req = store.get(key)\n  }).then(() => req.result)\n}\n\nfunction set (key, value) {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.put(value, key)\n  })\n}\n\nfunction del (key) {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.delete(key)\n  })\n}\n\nfunction clear () {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.clear()\n  })\n}\n\nfunction keys () {\n  const store = getDefaultStore()\n  const keys = []\n  return store._withIDBStore('readonly', store => {\n    // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\n    // And openKeyCursor isn't supported by Safari.\n    (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\n      if (!this.result) {\n        return\n      }\n      keys.push(this.result.key)\n      this.result.continue()\n    }\n  }).then(() => keys)\n}\n\nfunction close () {\n  const store = getDefaultStore()\n  return store._close()\n}\n\nif (process.browser) {\n  lifecycle.addEventListener('statechange', async event => {\n    if (event.newState === 'frozen') { // page is frozen, close IDB connections\n      await close()\n      console.log('closed keyval DB')\n    }\n  })\n}\n\nexport { Store, get, set, del, clear, keys, close }\n","import { set, keys, del } from '../_thirdparty/idb-keyval/idb-keyval.js'\n\nconst PREFIX = 'known-instance-'\n\nexport async function getKnownInstances () {\n  return (await keys())\n    .filter(_ => _.startsWith(PREFIX))\n    .map(_ => _.substring(PREFIX.length))\n}\n\nexport async function addKnownInstance (instanceName) {\n  return set(PREFIX + instanceName, true)\n}\n\nexport async function deleteKnownInstance (instanceName) {\n  return del(PREFIX + instanceName)\n}\n","import {\n  ACCOUNTS_STORE, DB_VERSION_SNOWFLAKE_IDS, DB_VERSION_INITIAL,\n  DB_VERSION_SEARCH_ACCOUNTS, META_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE, PINNED_STATUSES_STORE,\n  REBLOG_ID, RELATIONSHIPS_STORE,\n  STATUS_ID,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE, THREADS_STORE,\n  TIMESTAMP, USERNAME_LOWERCASE\n} from './constants.js'\nimport { toReversePaddedBigInt } from '../_utils/statusIdSorting.js'\n\nfunction initialMigration (db, tx, done) {\n  function createObjectStore (name, init, indexes) {\n    const store = init\n      ? db.createObjectStore(name, init)\n      : db.createObjectStore(name)\n    if (indexes) {\n      Object.keys(indexes).forEach(indexKey => {\n        store.createIndex(indexKey, indexes[indexKey])\n      })\n    }\n  }\n\n  createObjectStore(STATUSES_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP,\n    [REBLOG_ID]: REBLOG_ID\n  })\n  createObjectStore(STATUS_TIMELINES_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(NOTIFICATIONS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP,\n    [STATUS_ID]: STATUS_ID\n  })\n  createObjectStore(NOTIFICATION_TIMELINES_STORE, null, {\n    notificationId: ''\n  })\n  createObjectStore(ACCOUNTS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP\n  })\n  createObjectStore(RELATIONSHIPS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP\n  })\n  createObjectStore(THREADS_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(PINNED_STATUSES_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(META_STORE)\n  done()\n}\n\nfunction addSearchAccountsMigration (db, tx, done) {\n  tx.objectStore(ACCOUNTS_STORE)\n    .createIndex(USERNAME_LOWERCASE, USERNAME_LOWERCASE)\n  done()\n}\n\nfunction snowflakeIdsMigration (db, tx, done) {\n  const stores = [STATUS_TIMELINES_STORE, NOTIFICATION_TIMELINES_STORE]\n  let storeDoneCount = 0\n\n  // Here we have to convert the old \"reversePaddedBigInt\" format to the new\n  // one which is compatible with Pleroma-style snowflake IDs.\n  stores.forEach(store => {\n    const objectStore = tx.objectStore(store)\n    const cursor = objectStore.openCursor()\n    cursor.onsuccess = e => {\n      const { result } = e.target\n      if (result) {\n        const { key, value } = result\n        // key is timeline name plus delimiter plus reverse padded big int\n        const newKey = key.split('\\u0000')[0] + '\\u0000' + toReversePaddedBigInt(value)\n\n        objectStore.delete(key).onsuccess = () => {\n          objectStore.add(value, newKey).onsuccess = () => {\n            result.continue()\n          }\n        }\n      } else {\n        if (++storeDoneCount === stores.length) {\n          done()\n        }\n      }\n    }\n  })\n}\n\nexport const migrations = [\n  {\n    version: DB_VERSION_INITIAL,\n    migration: initialMigration\n  },\n  {\n    version: DB_VERSION_SEARCH_ACCOUNTS,\n    migration: addSearchAccountsMigration\n  },\n  {\n    version: DB_VERSION_SNOWFLAKE_IDS,\n    migration: snowflakeIdsMigration\n  }\n]\n","import { DB_VERSION_CURRENT } from './constants.js'\nimport { addKnownInstance, deleteKnownInstance } from './knownInstances.js'\nimport { migrations } from './migrations.js'\nimport { clearAllCaches } from './cache.js'\nimport { lifecycle } from '../_utils/lifecycle.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { del } from '../_thirdparty/idb-keyval/idb-keyval.js'\n\nconst openReqs = {}\nconst databaseCache = {}\n\nfunction createDatabase (instanceName) {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(instanceName, DB_VERSION_CURRENT.version)\n    openReqs[instanceName] = req\n    req.onerror = reject\n    req.onblocked = () => {\n      console.error('idb blocked')\n    }\n    req.onupgradeneeded = (e) => {\n      const db = req.result\n      const tx = e.currentTarget.transaction\n\n      const migrationsToDo = migrations.filter(({ version }) => e.oldVersion < version)\n\n      function doNextMigration () {\n        if (!migrationsToDo.length) {\n          return\n        }\n        const { migration } = migrationsToDo.shift()\n        migration(db, tx, doNextMigration)\n      }\n      doNextMigration()\n    }\n    req.onsuccess = () => resolve(req.result)\n  })\n}\n\nexport async function getDatabase (instanceName) {\n  if (!instanceName) {\n    throw new Error('instanceName is undefined in getDatabase()')\n  }\n  if (!databaseCache[instanceName]) {\n    databaseCache[instanceName] = await createDatabase(instanceName)\n    await addKnownInstance(instanceName)\n  }\n  return databaseCache[instanceName]\n}\n\nexport async function dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(storeName, readOnlyOrReadWrite)\n    const store = typeof storeName === 'string'\n      ? tx.objectStore(storeName)\n      : storeName.map(name => tx.objectStore(name))\n    let res\n    cb(store, (result) => {\n      res = result\n    })\n\n    tx.oncomplete = () => resolve(res)\n    tx.onerror = () => reject(tx.error)\n  })\n}\n\nexport function deleteDatabase (instanceName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    const openReq = openReqs[instanceName]\n    if (openReq && openReq.result) {\n      openReq.result.close()\n    }\n    delete openReqs[instanceName]\n    delete databaseCache[instanceName]\n    const req = indexedDB.deleteDatabase(instanceName)\n    req.onsuccess = () => resolve()\n    req.onerror = () => reject(req.error)\n    req.onblocked = () => console.error(`database ${instanceName} blocked`)\n  }).then(() => deleteKnownInstance(instanceName))\n    .then(() => clearAllCaches(instanceName))\n}\n\nexport function closeDatabase (instanceName) {\n  // close any open requests\n  const openReq = openReqs[instanceName]\n  if (openReq && openReq.result) {\n    openReq.result.close()\n  }\n  delete openReqs[instanceName]\n  delete databaseCache[instanceName]\n  clearAllCaches(instanceName)\n}\n\nif (process.browser) {\n  lifecycle.addEventListener('statechange', event => {\n    if (event.newState === 'frozen') { // page is frozen, close IDB connections\n      Object.keys(openReqs).forEach(instanceName => {\n        closeDatabase(instanceName)\n        console.log('closed instance DBs')\n      })\n    }\n  })\n\n  // Clean up files that Tesseract.js may have stored. Originally we allowed it to store\n  // stuff in IDB, but now we don't.\n  // TODO: we can remove this after it's been deployed for a while\n  scheduleIdleTask(() => del('./eng.traineddata'))\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle.js'\nimport { getInCache, hasInCache, setInCache } from './cache.js'\nimport {\n  ACCOUNT_ID, REBLOG_ID, STATUS_ID, TIMESTAMP, USERNAME_LOWERCASE, CURRENT_TIME\n} from './constants.js'\n\nexport async function getGenericEntityWithId (store, cache, instanceName, id) {\n  if (hasInCache(cache, instanceName, id)) {\n    return getInCache(cache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const result = await dbPromise(db, store, 'readonly', (store, callback) => {\n    store.get(id).onsuccess = (e) => callback(e.target.result)\n  })\n  setInCache(cache, instanceName, id, result)\n  return result\n}\n\nexport async function setGenericEntityWithId (store, cache, instanceName, entity) {\n  setInCache(cache, instanceName, entity.id, entity)\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, store, 'readwrite', (store) => {\n    store.put(entity)\n  })\n}\n\nexport function cloneForStorage (obj) {\n  const res = {}\n  const keys = Object.keys(obj)\n  for (const key of keys) {\n    const value = obj[key]\n    // save storage space by skipping nulls, 0s, falses, empty strings, and empty arrays\n    if (!value || (Array.isArray(value) && value.length === 0)) {\n      continue\n    }\n    switch (key) {\n      case 'account':\n        res[ACCOUNT_ID] = value.id\n        break\n      case 'status':\n        res[STATUS_ID] = value.id\n        break\n      case 'reblog':\n        res[REBLOG_ID] = value.id\n        break\n      case 'acct':\n        res[key] = value\n        res[USERNAME_LOWERCASE] = value.toLowerCase()\n        break\n      default:\n        res[key] = value\n        break\n    }\n  }\n  res[TIMESTAMP] = CURRENT_TIME.now()\n  return res\n}\n","import { toReversePaddedBigInt, zeroPad } from '../_utils/statusIdSorting.js'\n\n//\n// timelines\n//\n\nexport function createTimelineId (timeline, id) {\n  // reverse chronological order, prefixed by timeline\n  return timeline + '\\u0000' + toReversePaddedBigInt(id)\n}\n\nexport function createTimelineKeyRange (timeline, maxId) {\n  const negBigInt = maxId && toReversePaddedBigInt(maxId)\n  const start = negBigInt ? (timeline + '\\u0000' + negBigInt) : (timeline + '\\u0000')\n  const end = timeline + '\\u0000\\uffff'\n  return IDBKeyRange.bound(start, end, true, true)\n}\n\n//\n// threads\n//\n\nexport function createThreadId (statusId, i) {\n  return statusId + '\\u0000' + zeroPad(i, 5)\n}\n\nexport function createThreadKeyRange (statusId) {\n  return IDBKeyRange.bound(\n    statusId + '\\u0000',\n    statusId + '\\u0000\\uffff'\n  )\n}\n\n//\n// pinned statues\n//\n\nexport function createPinnedStatusId (accountId, i) {\n  return accountId + '\\u0000' + zeroPad(i, 3)\n}\n\nexport function createPinnedStatusKeyRange (accountId) {\n  return IDBKeyRange.bound(\n    accountId + '\\u0000',\n    accountId + '\\u0000\\uffff'\n  )\n}\n\n//\n// accounts\n//\n\nexport function createAccountUsernamePrefixKeyRange (accountUsernamePrefix) {\n  return IDBKeyRange.bound(\n    accountUsernamePrefix,\n    accountUsernamePrefix + '\\uffff'\n  )\n}\n","import { ACCOUNTS_STORE, USERNAME_LOWERCASE } from './constants.js'\nimport { accountsCache } from './cache.js'\nimport { cloneForStorage, getGenericEntityWithId, setGenericEntityWithId } from './helpers.js'\nimport { dbPromise, getDatabase } from './databaseLifecycle.js'\nimport { createAccountUsernamePrefixKeyRange } from './keys.js'\n\nexport async function getAccount (instanceName, accountId) {\n  return getGenericEntityWithId(ACCOUNTS_STORE, accountsCache, instanceName, accountId)\n}\n\nexport async function setAccount (instanceName, account) {\n  return setGenericEntityWithId(ACCOUNTS_STORE, accountsCache, instanceName, cloneForStorage(account))\n}\n\nexport async function searchAccountsByUsername (instanceName, usernamePrefix, limit) {\n  limit = limit || 20\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, ACCOUNTS_STORE, 'readonly', (accountsStore, callback) => {\n    const keyRange = createAccountUsernamePrefixKeyRange(usernamePrefix.toLowerCase())\n    accountsStore.index(USERNAME_LOWERCASE).getAll(keyRange, limit).onsuccess = e => {\n      callback(e.target.result)\n    }\n  })\n}\n","import { accountsCache, clearCache, metaCache, statusesCache } from './cache.js'\nimport { deleteDatabase } from './databaseLifecycle.js'\n\nexport async function clearDatabaseForInstance (instanceName) {\n  clearCache(statusesCache, instanceName)\n  clearCache(accountsCache, instanceName)\n  clearCache(metaCache, instanceName)\n  await deleteDatabase(instanceName)\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport { STATUSES_STORE, STATUS_ID, REBLOG_ID, NOTIFICATIONS_STORE } from '../constants.js'\n\nexport async function getReblogsForStatus (instanceName, id) {\n  const db = await getDatabase(instanceName)\n  await dbPromise(db, STATUSES_STORE, 'readonly', (statusesStore, callback) => {\n    statusesStore.index(REBLOG_ID).getAll(IDBKeyRange.only(id)).onsuccess = e => {\n      callback(e.target.result)\n    }\n  })\n}\n\nexport async function getNotificationIdsForStatuses (instanceName, statusIds) {\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, NOTIFICATIONS_STORE, 'readonly', (notificationsStore, callback) => {\n    const res = []\n    callback(res)\n    statusIds.forEach(statusId => {\n      const req = notificationsStore.index(STATUS_ID).getAllKeys(IDBKeyRange.only(statusId))\n      req.onsuccess = e => {\n        for (const id of e.target.result) {\n          res.push(id)\n        }\n      }\n    })\n  })\n}\n","import {\n  accountsCache, setInCache, statusesCache\n} from '../cache.js'\n\nexport function cacheStatus (status, instanceName) {\n  setInCache(statusesCache, instanceName, status.id, status)\n  setInCache(accountsCache, instanceName, status.account.id, status.account)\n  if (status.reblog) {\n    setInCache(accountsCache, instanceName, status.reblog.account.id, status.reblog.account)\n  }\n}\n","export function deleteAll (store, index, keyRange) {\n  index.getAllKeys(keyRange).onsuccess = e => {\n    for (const result of e.target.result) {\n      store.delete(result)\n    }\n  }\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle.js'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  PINNED_STATUSES_STORE,\n  RELATIONSHIPS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE,\n  TIMESTAMP\n} from './constants.js'\nimport { debounce } from '../_thirdparty/lodash/timers.js'\nimport { mark, stop } from '../_utils/marks.js'\nimport { deleteAll } from './utils.js'\nimport { createPinnedStatusKeyRange, createThreadKeyRange } from './keys.js'\nimport { getKnownInstances } from './knownInstances.js'\nimport { noop } from '../_utils/lodash-lite.js'\nimport { CLEANUP_DELAY, CLEANUP_TIME_AGO } from '../_static/database.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\n\nconst BATCH_SIZE = 20\n\nfunction batchedGetAll (callGetAll, callback) {\n  function nextBatch () {\n    callGetAll().onsuccess = function (e) {\n      const results = e.target.result\n      callback(results)\n      if (results.length) {\n        nextBatch()\n      }\n    }\n  }\n  nextBatch()\n}\n\nfunction cleanupStatuses (statusesStore, statusTimelinesStore, threadsStore, cutoff) {\n  batchedGetAll(\n    () => statusesStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(statusId => {\n        statusesStore.delete(statusId)\n        deleteAll(\n          statusTimelinesStore,\n          statusTimelinesStore.index('statusId'),\n          IDBKeyRange.only(statusId)\n        )\n        deleteAll(\n          threadsStore,\n          threadsStore,\n          createThreadKeyRange(statusId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupNotifications (notificationsStore, notificationTimelinesStore, cutoff) {\n  batchedGetAll(\n    () => notificationsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(notificationId => {\n        notificationsStore.delete(notificationId)\n        deleteAll(\n          notificationTimelinesStore,\n          notificationTimelinesStore.index('notificationId'),\n          IDBKeyRange.only(notificationId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupAccounts (accountsStore, pinnedStatusesStore, cutoff) {\n  batchedGetAll(\n    () => accountsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(accountId => {\n        accountsStore.delete(accountId)\n        deleteAll(\n          pinnedStatusesStore,\n          pinnedStatusesStore,\n          createPinnedStatusKeyRange(accountId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupRelationships (relationshipsStore, cutoff) {\n  batchedGetAll(\n    () => relationshipsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(relationshipId => {\n        relationshipsStore.delete(relationshipId)\n      })\n    }\n  )\n}\n\nexport async function cleanup (instanceName) {\n  console.log('cleanup', instanceName)\n  mark(`cleanup:${instanceName}`)\n  const db = await getDatabase(instanceName)\n  const storeNames = [\n    STATUSES_STORE,\n    STATUS_TIMELINES_STORE,\n    NOTIFICATIONS_STORE,\n    NOTIFICATION_TIMELINES_STORE,\n    ACCOUNTS_STORE,\n    RELATIONSHIPS_STORE,\n    THREADS_STORE,\n    PINNED_STATUSES_STORE\n  ]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [\n      statusesStore,\n      statusTimelinesStore,\n      notificationsStore,\n      notificationTimelinesStore,\n      accountsStore,\n      relationshipsStore,\n      threadsStore,\n      pinnedStatusesStore\n    ] = stores\n\n    const cutoff = Date.now() - CLEANUP_TIME_AGO\n\n    cleanupStatuses(statusesStore, statusTimelinesStore, threadsStore, cutoff)\n    cleanupNotifications(notificationsStore, notificationTimelinesStore, cutoff)\n    cleanupAccounts(accountsStore, pinnedStatusesStore, cutoff)\n    cleanupRelationships(relationshipsStore, cutoff)\n  })\n  stop(`cleanup:${instanceName}`)\n}\n\nfunction doCleanup (instanceName) {\n  scheduleIdleTask(() => cleanup(instanceName))\n}\n\nasync function scheduledCleanup () {\n  console.log('scheduledCleanup')\n  const knownInstances = await getKnownInstances()\n  for (const instance of knownInstances) {\n    doCleanup(instance)\n  }\n}\n\n// we have unit tests that test indexedDB; we don't want this thing to run forever\nexport const scheduleCleanup = process.browser ? debounce(scheduledCleanup, CLEANUP_DELAY) : noop\n","import { difference } from '../../_thirdparty/lodash/objects.js'\nimport { times } from '../../_utils/lodash-lite.js'\nimport { cloneForStorage } from '../helpers.js'\nimport { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport { accountsCache, notificationsCache, setInCache, statusesCache } from '../cache.js'\nimport { scheduleCleanup } from '../cleanup.js'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants.js'\nimport {\n  createThreadId,\n  createThreadKeyRange,\n  createTimelineId\n} from '../keys.js'\nimport { cacheStatus } from './cacheStatus.js'\n\nexport function putStatus (statusesStore, status) {\n  statusesStore.put(cloneForStorage(status))\n}\n\nexport function putAccount (accountsStore, account) {\n  accountsStore.put(cloneForStorage(account))\n}\n\nexport function putNotification (notificationsStore, notification) {\n  notificationsStore.put(cloneForStorage(notification))\n}\n\nexport function storeAccount (accountsStore, account) {\n  putAccount(accountsStore, account)\n}\n\nexport function storeStatus (statusesStore, accountsStore, status) {\n  putStatus(statusesStore, status)\n  putAccount(accountsStore, status.account)\n  if (status.reblog) {\n    putStatus(statusesStore, status.reblog)\n    putAccount(accountsStore, status.reblog.account)\n  }\n}\n\nexport function storeNotification (notificationsStore, statusesStore, accountsStore, notification) {\n  if (notification.status) {\n    storeStatus(statusesStore, accountsStore, notification.status)\n  }\n  storeAccount(accountsStore, notification.account)\n  putNotification(notificationsStore, notification)\n}\n\nasync function insertTimelineNotifications (instanceName, timeline, notifications) {\n  for (const notification of notifications) {\n    setInCache(notificationsCache, instanceName, notification.id, notification)\n    setInCache(accountsCache, instanceName, notification.account.id, notification.account)\n    if (notification.status) {\n      setInCache(statusesCache, instanceName, notification.status.id, notification.status)\n    }\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [NOTIFICATION_TIMELINES_STORE, NOTIFICATIONS_STORE, ACCOUNTS_STORE, STATUSES_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [timelineStore, notificationsStore, accountsStore, statusesStore] = stores\n    for (const notification of notifications) {\n      storeNotification(notificationsStore, statusesStore, accountsStore, notification)\n      timelineStore.put(notification.id, createTimelineId(timeline, notification.id))\n    }\n  })\n}\n\nasync function insertTimelineStatuses (instanceName, timeline, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [STATUS_TIMELINES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [timelineStore, statusesStore, accountsStore] = stores\n    for (const status of statuses) {\n      storeStatus(statusesStore, accountsStore, status)\n      timelineStore.put(status.id, createTimelineId(timeline, status.id))\n    }\n  })\n}\n\nasync function insertStatusThread (instanceName, statusId, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [THREADS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [threadsStore, statusesStore, accountsStore] = stores\n    threadsStore.getAllKeys(createThreadKeyRange(statusId)).onsuccess = e => {\n      const existingKeys = e.target.result\n      const newKeys = times(statuses.length, i => createThreadId(statusId, i))\n      const keysToDelete = difference(existingKeys, newKeys)\n      for (const key of keysToDelete) {\n        threadsStore.delete(key)\n      }\n    }\n    statuses.forEach((otherStatus, i) => {\n      storeStatus(statusesStore, accountsStore, otherStatus)\n      threadsStore.put(otherStatus.id, createThreadId(statusId, i))\n    })\n  })\n}\n\nexport async function insertTimelineItems (instanceName, timeline, timelineItems) {\n  console.log('insertTimelineItems', instanceName, timeline, timelineItems)\n  /* no await */ scheduleCleanup()\n  if (timeline === 'notifications' || timeline === 'notifications/mentions') {\n    return insertTimelineNotifications(instanceName, timeline, timelineItems)\n  } else if (timeline.startsWith('status/')) {\n    const statusId = timeline.split('/').slice(-1)[0]\n    return insertStatusThread(instanceName, statusId, timelineItems)\n  } else {\n    return insertTimelineStatuses(instanceName, timeline, timelineItems)\n  }\n}\n\nexport async function insertStatus (instanceName, status) {\n  cacheStatus(status, instanceName)\n  const db = await getDatabase(instanceName)\n  await dbPromise(db, [STATUSES_STORE, ACCOUNTS_STORE], 'readwrite', ([statusesStore, accountsStore]) => {\n    storeStatus(statusesStore, accountsStore, status)\n  })\n}\n","export function fetchAccount (accountsStore, id, callback) {\n  accountsStore.get(id).onsuccess = e => {\n    callback(e.target.result)\n  }\n}\n","import { fetchAccount } from './fetchAccount.js'\nimport { ACCOUNT_ID, REBLOG_ID } from '../constants.js'\n\nexport function fetchStatus (statusesStore, accountsStore, id, callback) {\n  statusesStore.get(id).onsuccess = e => {\n    const status = e.target.result\n    callback(status)\n    if (!status) {\n      return\n    }\n    fetchAccount(accountsStore, status[ACCOUNT_ID], account => {\n      status.account = account\n    })\n    if (status[REBLOG_ID]) {\n      fetchStatus(statusesStore, accountsStore, status[REBLOG_ID], reblog => {\n        status.reblog = reblog\n      })\n    }\n  }\n}\n","import { cacheStatus } from './cacheStatus.js'\nimport { getDatabase, dbPromise } from '../databaseLifecycle.js'\nimport { PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE } from '../constants.js'\nimport { createPinnedStatusId, createPinnedStatusKeyRange } from '../keys.js'\nimport { storeStatus } from './insertion.js'\nimport { fetchStatus } from './fetchStatus.js'\n\nexport async function insertPinnedStatuses (instanceName, accountId, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [pinnedStatusesStore, statusesStore, accountsStore] = stores\n\n    const keyRange = createPinnedStatusKeyRange(accountId)\n    pinnedStatusesStore.getAll(keyRange).onsuccess = e => {\n      // if there was e.g. 1 pinned status before and 2 now, then we need to delete the old one\n      const existingPinnedStatuses = e.target.result\n      for (let i = statuses.length; i < existingPinnedStatuses.length; i++) {\n        pinnedStatusesStore.delete(createPinnedStatusKeyRange(accountId, i))\n      }\n      statuses.forEach((status, i) => {\n        storeStatus(statusesStore, accountsStore, status)\n        pinnedStatusesStore.put(status.id, createPinnedStatusId(accountId, i))\n      })\n    }\n  })\n}\n\nexport async function getPinnedStatuses (instanceName, accountId) {\n  const storeNames = [PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [pinnedStatusesStore, statusesStore, accountsStore] = stores\n    const keyRange = createPinnedStatusKeyRange(accountId)\n    pinnedStatusesStore.getAll(keyRange).onsuccess = e => {\n      const pinnedResults = e.target.result\n      const res = new Array(pinnedResults.length)\n      pinnedResults.forEach((statusId, i) => {\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          res[i] = status\n        })\n      })\n      callback(res)\n    }\n  })\n}\n","import { fetchAccount } from './fetchAccount.js'\nimport { ACCOUNT_ID, STATUS_ID } from '../constants.js'\nimport { fetchStatus } from './fetchStatus.js'\n\nexport function fetchNotification (notificationsStore, statusesStore, accountsStore, id, callback) {\n  notificationsStore.get(id).onsuccess = e => {\n    const notification = e.target.result\n    callback(notification)\n    if (!notification) {\n      return\n    }\n    fetchAccount(accountsStore, notification[ACCOUNT_ID], account => {\n      notification.account = account\n    })\n    if (notification[STATUS_ID]) {\n      fetchStatus(statusesStore, accountsStore, notification[STATUS_ID], status => {\n        notification.status = status\n      })\n    }\n  }\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants.js'\nimport {\n  createThreadKeyRange,\n  createTimelineKeyRange\n} from '../keys.js'\nimport { fetchStatus } from './fetchStatus.js'\nimport { fetchNotification } from './fetchNotification.js'\nimport { TIMELINE_BATCH_SIZE } from '../../_static/timelines.js'\n\nasync function getNotificationTimeline (instanceName, timeline, maxId, limit) {\n  const storeNames = [NOTIFICATION_TIMELINES_STORE, NOTIFICATIONS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [timelineStore, notificationsStore, statusesStore, accountsStore] = stores\n    const keyRange = createTimelineKeyRange(timeline, maxId)\n\n    timelineStore.getAll(keyRange, limit).onsuccess = e => {\n      const timelineResults = e.target.result\n      const res = new Array(timelineResults.length)\n      timelineResults.forEach((notificationId, i) => {\n        fetchNotification(notificationsStore, statusesStore, accountsStore, notificationId, notification => {\n          res[i] = notification\n        })\n      })\n      callback(res)\n    }\n  })\n}\n\nasync function getStatusTimeline (instanceName, timeline, maxId, limit) {\n  const storeNames = [STATUS_TIMELINES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [timelineStore, statusesStore, accountsStore] = stores\n    const getReq = timelineStore.getAll(createTimelineKeyRange(timeline, maxId), limit)\n    getReq.onsuccess = e => {\n      const timelineResults = e.target.result\n      const res = new Array(timelineResults.length)\n      timelineResults.forEach((statusId, i) => {\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          res[i] = status\n        })\n      })\n      callback(res)\n    }\n  })\n}\n\nasync function getStatusThread (instanceName, statusId) {\n  const storeNames = [THREADS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [threadsStore, statusesStore, accountsStore] = stores\n    const keyRange = createThreadKeyRange(statusId)\n    threadsStore.getAll(keyRange).onsuccess = e => {\n      const thread = e.target.result\n      if (thread.length) {\n        const res = new Array(thread.length)\n        callback(res)\n        thread.forEach((otherStatusId, i) => {\n          fetchStatus(statusesStore, accountsStore, otherStatusId, status => {\n            res[i] = status\n          })\n        })\n      } else {\n        // thread not cached; just make a \"fake\" thread with only one status in it\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          const res = [status]\n          callback(res)\n        })\n      }\n    }\n  })\n}\n\nexport async function getTimeline (instanceName, timeline, maxId, limit) {\n  maxId = maxId || null\n  limit = limit || TIMELINE_BATCH_SIZE\n  if (timeline === 'notifications' || timeline === 'notifications/mentions') {\n    return getNotificationTimeline(instanceName, timeline, maxId, limit)\n  } else if (timeline.startsWith('status/')) {\n    const statusId = timeline.split('/').slice(-1)[0]\n    return getStatusThread(instanceName, statusId)\n  } else {\n    return getStatusTimeline(instanceName, timeline, maxId, limit)\n  }\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport { getInCache, hasInCache, notificationsCache, setInCache, statusesCache } from '../cache.js'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATIONS_STORE,\n  STATUSES_STORE\n} from '../constants.js'\nimport { fetchStatus } from './fetchStatus.js'\nimport { fetchNotification } from './fetchNotification.js'\n\nexport async function getStatus (instanceName, id) {\n  if (hasInCache(statusesCache, instanceName, id)) {\n    return getInCache(statusesCache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [STATUSES_STORE, ACCOUNTS_STORE]\n  const result = await dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [statusesStore, accountsStore] = stores\n    fetchStatus(statusesStore, accountsStore, id, callback)\n  })\n  setInCache(statusesCache, instanceName, id, result)\n  return result\n}\n\nexport async function getNotification (instanceName, id) {\n  if (hasInCache(notificationsCache, instanceName, id)) {\n    return getInCache(notificationsCache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [NOTIFICATIONS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const result = await dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [notificationsStore, statusesStore, accountsStore] = stores\n    fetchNotification(notificationsStore, statusesStore, accountsStore, id, callback)\n  })\n  setInCache(notificationsCache, instanceName, id, result)\n  return result\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport { getInCache, hasInCache, statusesCache } from '../cache.js'\nimport { STATUSES_STORE } from '../constants.js'\nimport { cacheStatus } from './cacheStatus.js'\nimport { putStatus } from './insertion.js'\nimport { cloneForStorage } from '../helpers.js'\n\n//\n// update statuses\n//\n\nasync function doUpdateStatus (instanceName, statusId, updateFunc) {\n  const db = await getDatabase(instanceName)\n  if (hasInCache(statusesCache, instanceName, statusId)) {\n    const status = getInCache(statusesCache, instanceName, statusId)\n    updateFunc(status)\n    cacheStatus(status, instanceName)\n  }\n  return dbPromise(db, STATUSES_STORE, 'readwrite', (statusesStore) => {\n    statusesStore.get(statusId).onsuccess = e => {\n      const status = e.target.result\n      updateFunc(status)\n      putStatus(statusesStore, status)\n    }\n  })\n}\n\nexport async function setStatusFavorited (instanceName, statusId, favorited) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    const delta = (favorited ? 1 : 0) - (status.favourited ? 1 : 0)\n    status.favourited = favorited\n    status.favourites_count = (status.favourites_count || 0) + delta\n  })\n}\n\nexport async function setStatusReblogged (instanceName, statusId, reblogged) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    const delta = (reblogged ? 1 : 0) - (status.reblogged ? 1 : 0)\n    status.reblogged = reblogged\n    status.reblogs_count = (status.reblogs_count || 0) + delta\n  })\n}\n\nexport async function setStatusPinned (instanceName, statusId, pinned) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    status.pinned = pinned\n  })\n}\n\nexport async function setStatusMuted (instanceName, statusId, muted) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    status.muted = muted\n  })\n}\n\nexport async function setStatusBookmarked (instanceName, statusId, bookmarked) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    status.bookmarked = bookmarked\n  })\n}\n\n// For the full list, see https://docs.joinmastodon.org/methods/statuses/#edit\nconst PROPS_THAT_CAN_BE_EDITED = ['content', 'spoiler_text', 'sensitive', 'language', 'media_ids', 'poll']\n\nexport async function updateStatus (instanceName, newStatus) {\n  const clonedNewStatus = cloneForStorage(newStatus)\n  return doUpdateStatus(instanceName, newStatus.id, status => {\n    // We can't use a simple Object.assign() to merge because a prop might have been deleted\n    for (const prop of PROPS_THAT_CAN_BE_EDITED) {\n      if (!(prop in clonedNewStatus)) {\n        delete status[prop]\n      } else {\n        status[prop] = clonedNewStatus[prop]\n      }\n    }\n  })\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport {\n  deleteFromCache, notificationsCache,\n  statusesCache\n} from '../cache.js'\nimport {\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE, PINNED_STATUSES_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants.js'\nimport {\n  createThreadKeyRange\n} from '../keys.js'\nimport { deleteAll } from '../utils.js'\n\nexport async function deleteStatusesAndNotifications (instanceName, statusIds, notificationIds) {\n  for (const statusId of statusIds) {\n    deleteFromCache(statusesCache, instanceName, statusId)\n  }\n  for (const notificationId of notificationIds) {\n    deleteFromCache(notificationsCache, instanceName, notificationId)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [\n    STATUSES_STORE,\n    STATUS_TIMELINES_STORE,\n    NOTIFICATIONS_STORE,\n    NOTIFICATION_TIMELINES_STORE,\n    PINNED_STATUSES_STORE,\n    THREADS_STORE\n  ]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [\n      statusesStore,\n      statusTimelinesStore,\n      notificationsStore,\n      notificationTimelinesStore,\n      pinnedStatusesStore,\n      threadsStore\n    ] = stores\n\n    function deleteStatus (statusId) {\n      statusesStore.delete(statusId)\n      deleteAll(\n        pinnedStatusesStore,\n        pinnedStatusesStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        statusTimelinesStore,\n        statusTimelinesStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        threadsStore,\n        threadsStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        threadsStore,\n        threadsStore,\n        createThreadKeyRange(statusId)\n      )\n    }\n\n    function deleteNotification (notificationId) {\n      notificationsStore.delete(notificationId)\n      deleteAll(\n        notificationTimelinesStore,\n        notificationTimelinesStore.index('notificationId'),\n        IDBKeyRange.only(notificationId)\n      )\n    }\n\n    for (const statusId of statusIds) {\n      deleteStatus(statusId)\n    }\n    for (const notificationId of notificationIds) {\n      deleteNotification(notificationId)\n    }\n  })\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle.js'\nimport { META_STORE } from './constants.js'\nimport { metaCache, hasInCache, getInCache, setInCache } from './cache.js'\n\nasync function getMetaProperty (instanceName, key) {\n  if (hasInCache(metaCache, instanceName, key)) {\n    return getInCache(metaCache, instanceName, key)\n  }\n  const db = await getDatabase(instanceName)\n  const result = await dbPromise(db, META_STORE, 'readonly', (store, callback) => {\n    store.get(key).onsuccess = (e) => {\n      callback(e.target.result)\n    }\n  })\n  setInCache(metaCache, instanceName, key, result)\n  return result\n}\n\nasync function setMetaProperty (instanceName, key, value) {\n  setInCache(metaCache, instanceName, key, value)\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, META_STORE, 'readwrite', (store) => {\n    store.put(value, key)\n  })\n}\n\nexport async function getInstanceVerifyCredentials (instanceName) {\n  return getMetaProperty(instanceName, 'verifyCredentials')\n}\n\nexport async function setInstanceVerifyCredentials (instanceName, value) {\n  return setMetaProperty(instanceName, 'verifyCredentials', value)\n}\n\nexport async function getInstanceInfo (instanceName) {\n  return getMetaProperty(instanceName, 'instance')\n}\n\nexport async function setInstanceInfo (instanceName, value) {\n  return setMetaProperty(instanceName, 'instance', value)\n}\n\nexport async function getLists (instanceName) {\n  return getMetaProperty(instanceName, 'lists')\n}\n\nexport async function setLists (instanceName, value) {\n  return setMetaProperty(instanceName, 'lists', value)\n}\n\nexport async function getCustomEmoji (instanceName) {\n  return getMetaProperty(instanceName, 'customEmoji')\n}\n\nexport async function setCustomEmoji (instanceName, value) {\n  return setMetaProperty(instanceName, 'customEmoji', value)\n}\n\nexport async function getFollowRequestCount (instanceName) {\n  return getMetaProperty(instanceName, 'followRequestCount')\n}\n\nexport async function setFollowRequestCount (instanceName, value) {\n  return setMetaProperty(instanceName, 'followRequestCount', value)\n}\n\nexport async function getFilters (instanceName) {\n  return getMetaProperty(instanceName, 'filters')\n}\n\nexport async function setFilters (instanceName, value) {\n  return setMetaProperty(instanceName, 'filters', value)\n}\n","import { cloneForStorage, getGenericEntityWithId, setGenericEntityWithId } from './helpers.js'\nimport { RELATIONSHIPS_STORE } from './constants.js'\nimport { relationshipsCache } from './cache.js'\n\nexport async function getRelationship (instanceName, accountId) {\n  return getGenericEntityWithId(RELATIONSHIPS_STORE, relationshipsCache, instanceName, accountId)\n}\n\nexport async function setRelationship (instanceName, relationship) {\n  return setGenericEntityWithId(RELATIONSHIPS_STORE, relationshipsCache, instanceName, cloneForStorage(relationship))\n}\n","export const WEB_SHARE_TARGET_DATA_IDB_KEY = 'web-share-data'\n","import { get, set, close, del } from '../_thirdparty/idb-keyval/idb-keyval.js'\nimport { WEB_SHARE_TARGET_DATA_IDB_KEY } from '../_static/share.js'\n\nexport function deleteWebShareData () {\n  return del(WEB_SHARE_TARGET_DATA_IDB_KEY)\n}\n\nexport function setWebShareData (data) {\n  return set(WEB_SHARE_TARGET_DATA_IDB_KEY, data)\n}\n\nexport function getWebShareData () {\n  return get(WEB_SHARE_TARGET_DATA_IDB_KEY)\n}\n\nexport function closeKeyValIDBConnection () {\n  return close()\n}\n","import { get, set, del } from '../_thirdparty/idb-keyval/idb-keyval.js'\n\ndel('theme-color')\n\nexport function setLastTheme (data) {\n  return set('theme', data)\n}\n\nexport function getLastTheme () {\n  return get('theme')\n}\n\nexport function setIconColors (data) {\n  return set('iconColors', data)\n}\n\nexport function getIconColors () {\n  return get('iconColors')\n}\n","// Keep an LRU cache of recently-uploaded files for OCR.\n// We keep them in IDB to avoid tainted canvas errors after a refresh.\n\nimport { get, set, keys, del } from '../_thirdparty/idb-keyval/idb-keyval.js'\nimport { store } from '../_store/store.js'\n\nconst PREFIX = 'media-cache-'\nconst DELIMITER = '-cache-'\nexport const DELETE_AFTER = 604800000 // 7 days\n\nlet deleteAfter = DELETE_AFTER\n\nfunction keyToData (key) {\n  key = key.substring(PREFIX.length)\n  const index = key.indexOf(DELIMITER)\n  // avoiding str.split() to not have to worry about ids containing the delimiter string somehow\n  return [key.substring(0, index), key.substring(index + DELIMITER.length)]\n}\n\nfunction dataToKey (timestamp, id) {\n  return `${PREFIX}${timestamp}${DELIMITER}${id}`\n}\n\nasync function getAllKeys () {\n  return (await keys()).filter(key => key.startsWith(PREFIX)).sort()\n}\n\nexport async function getCachedMediaFile (id) {\n  const allKeys = await getAllKeys()\n\n  for (const key of allKeys) {\n    const otherId = keyToData(key)[1]\n    if (id === otherId) {\n      return get(key)\n    }\n  }\n}\n\nexport async function setCachedMediaFile (id, file) {\n  const allKeys = await getAllKeys()\n\n  if (allKeys.map(keyToData).map(_ => _[1]).includes(id)) {\n    return // do nothing, it's already in there\n  }\n\n  const { maxStatusMediaAttachments } = store.get()\n\n  while (allKeys.length >= maxStatusMediaAttachments) {\n    // already sorted in chronological order, so delete the oldest\n    await del(allKeys.shift())\n  }\n\n  // delete anything that's too old, while we're at it\n  for (const key of allKeys) {\n    const timestamp = keyToData(key)[0]\n    if (Date.now() - Date.parse(timestamp) >= deleteAfter) {\n      await del(key)\n    }\n  }\n\n  const key = dataToKey(new Date().toISOString(), id)\n\n  await set(key, file)\n}\n\nexport async function deleteCachedMediaFile (id) {\n  const allKeys = await getAllKeys()\n\n  for (const key of allKeys) {\n    const otherId = keyToData(key)[1]\n    if (otherId === id) {\n      await del(key)\n    }\n  }\n}\n\n// The following are only used in tests\n\nexport async function getAllCachedFileIds () {\n  return (await getAllKeys()).map(keyToData).map(_ => _[1])\n}\n\nexport function setDeleteCachedMediaFilesAfter (newDeleteAfter) {\n  deleteAfter = newDeleteAfter\n}\n","export const CLEANUP_TIME_AGO = 5 * 24 * 60 * 60 * 1000 // five days ago\nexport const CLEANUP_DELAY = 5 * 60 * 1000 // five minutes\n","export const TIMELINE_BATCH_SIZE = 20\n\nexport const timelines = {\n  home: { name: 'home', label: \"Home\" },\n  local: { name: 'local', label: \"Local\" },\n  bubble: { name: 'bubble', label: \"Bubble\" },\n  federated: { name: 'federated', label: \"Federated\" }\n}\n","// Forked from https://github.com/sindresorhus/quick-lru/blob/16d15d470a8eb87c2a7dd5b80892d9b74f1acd3c/index.js\n// Adds the ability to listen for 'evict' events using an EventEmitter, also removes some unused code\n\nimport eventsLightPackage from 'events-light'\nconst { EventEmitter } = eventsLightPackage\n\nexport class QuickLRU extends EventEmitter {\n  constructor (options = {}) {\n    super()\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0')\n    }\n\n    this.maxSize = options.maxSize\n    this.cache = new Map()\n    this.oldCache = new Map()\n    this._size = 0\n  }\n\n  _set (key, value) {\n    this.cache.set(key, value)\n    this._size++\n\n    if (this._size >= this.maxSize) {\n      this._size = 0\n      if (this.listenerCount('evict')) {\n        for (const key of this.oldCache.keys()) {\n          if (!this.cache.has(key)) {\n            this.emit('evict', this.oldCache.get(key), key)\n          }\n        }\n      }\n      this.oldCache = this.cache\n      this.cache = new Map()\n    }\n  }\n\n  get (key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      const value = this.oldCache.get(key)\n      this.oldCache.delete(key)\n      this._set(key, value)\n      return value\n    }\n  }\n\n  set (key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value)\n    } else {\n      this._set(key, value)\n    }\n\n    return this\n  }\n\n  has (key) {\n    return this.cache.has(key) || this.oldCache.has(key)\n  }\n\n  // unused\n  // peek (key) {\n  //   if (this.cache.has(key)) {\n  //     return this.cache.get(key)\n  //   }\n  //\n  //   if (this.oldCache.has(key)) {\n  //     return this.oldCache.get(key)\n  //   }\n  // }\n\n  delete (key) {\n    const deleted = this.cache.delete(key)\n    if (deleted) {\n      this._size--\n    }\n\n    return this.oldCache.delete(key) || deleted\n  }\n\n  clear () {\n    this.cache.clear()\n    this.oldCache.clear()\n    this._size = 0\n  }\n\n  getAllKeys () {\n    const set = new Set()\n    for (const key of this.cache.keys()) {\n      set.add(key)\n    }\n    for (const key of this.oldCache.keys()) {\n      set.add(key)\n    }\n    return set\n  }\n\n  // unused\n  // * keys() {\n  //   for (const [key] of this) {\n  //     yield key;\n  //   }\n  // }\n  //\n  // * values() {\n  //   for (const [, value] of this) {\n  //     yield value;\n  //   }\n  // }\n  //\n  // * [Symbol.iterator]() {\n  //   for (const item of this.cache) {\n  //     yield item;\n  //   }\n  //\n  //   for (const item of this.oldCache) {\n  //     const [key] = item;\n  //     if (!this.cache.has(key)) {\n  //       yield item;\n  //     }\n  //   }\n  // }\n  //\n  // get size () {\n  //   let oldCacheSize = 0\n  //   for (const key of this.oldCache.keys()) {\n  //     if (!this.cache.has(key)) {\n  //       oldCacheSize++\n  //     }\n  //   }\n  //\n  //   return this._size + oldCacheSize\n  // }\n}\n","// Pleroma uses base62 IDs, Mastodon uses 0-9 big ints encoded as strings.\n// Using base62 for both works, since the first 10 characters of base62\n// are 0-9.\n\nimport { padStart } from './lodash-lite.js'\n\n// Pleroma uses the 0-9A-Za-z alphabet for base62, which is the same as ASCII, which\n// is the same as JavaScript sort order and IndexedDB order.\nconst MIN_CHAR_CODE = 48 // '0'.charCodeAt(0)\nconst MAX_CHAR_CODE = 122 // 'z'.charCodeAt(0)\nconst MAX_ID_LENGTH = 30 // assume that Mastodon/Pleroma IDs won't get any bigger than this\n\nexport function zeroPad (str, toSize) {\n  return padStart(str, toSize, '0')\n}\n\nexport function toPaddedBigInt (id) {\n  return zeroPad(id, MAX_ID_LENGTH)\n}\n\nexport function toReversePaddedBigInt (id) {\n  const padded = toPaddedBigInt(id)\n  let reversed = ''\n  for (let i = 0; i < padded.length; i++) {\n    const charCode = padded.charCodeAt(i)\n    const inverseCharCode = MIN_CHAR_CODE + MAX_CHAR_CODE - charCode\n    reversed += String.fromCharCode(inverseCharCode)\n  }\n  return reversed\n}\n\nexport function compareTimelineItemSummaries (left, right) {\n  const leftPadded = toPaddedBigInt(left.id)\n  const rightPadded = toPaddedBigInt(right.id)\n  return leftPadded < rightPadded ? -1 : leftPadded === rightPadded ? 0 : 1\n}\n"],"names":["STATUSES_STORE","STATUS_TIMELINES_STORE","META_STORE","ACCOUNTS_STORE","RELATIONSHIPS_STORE","NOTIFICATIONS_STORE","NOTIFICATION_TIMELINES_STORE","PINNED_STATUSES_STORE","THREADS_STORE","TIMESTAMP","ACCOUNT_ID","STATUS_ID","REBLOG_ID","USERNAME_LOWERCASE","DB_VERSION_CURRENT","version","CURRENT_TIME","now","Date","statusesCache","maxSize","caches","accountsCache","relationshipsCache","metaCache","notificationsCache","getOrCreateInstanceCache","cache","instanceName","cached","clearCache","clearAllCaches","allCaches","setInCache","key","value","set","getInCache","get","hasInCache","has","deleteFromCache","delete","Store","constructor","dbName","storeName","this","_dbName","_storeName","_init","_withIDBStore","type","callback","_dbp","then","db","Promise","resolve","reject","transaction","oncomplete","onabort","onerror","error","objectStore","openreq","indexedDB","open","onsuccess","result","onupgradeneeded","createObjectStore","_close","close","undefined","store","getDefaultStore","req","put","del","keys","openKeyCursor","openCursor","call","push","continue","lifecycle","addEventListener","async","event","newState","PREFIX","migrations","migration","tx","done","name","init","indexes","Object","forEach","indexKey","createIndex","keyPath","statusId","notificationId","stores","storeDoneCount","e","target","newKey","split","add","length","openReqs","databaseCache","getDatabase","Error","onblocked","console","currentTarget","migrationsToDo","filter","oldVersion","doNextMigration","shift","createDatabase","addKnownInstance","dbPromise","readOnlyOrReadWrite","cb","map","res","deleteDatabase","openReq","deleteKnownInstance","getGenericEntityWithId","id","setGenericEntityWithId","entity","cloneForStorage","obj","Array","isArray","toLowerCase","createTimelineId","timeline","createTimelineKeyRange","maxId","negBigInt","start","end","IDBKeyRange","bound","createThreadId","i","createThreadKeyRange","createPinnedStatusKeyRange","accountId","getAccount","setAccount","account","searchAccountsByUsername","usernamePrefix","limit","accountsStore","keyRange","accountUsernamePrefix","index","getAll","clearDatabaseForInstance","getReblogsForStatus","statusesStore","only","getNotificationIdsForStatuses","statusIds","notificationsStore","getAllKeys","cacheStatus","status","reblog","closeDatabase","scheduleIdleTask","deleteAll","BATCH_SIZE","batchedGetAll","callGetAll","nextBatch","results","cleanup","storeNames","statusTimelinesStore","notificationTimelinesStore","relationshipsStore","threadsStore","pinnedStatusesStore","cutoff","upperBound","cleanupStatuses","cleanupNotifications","cleanupAccounts","relationshipId","cleanupRelationships","s","doCleanup","scheduleCleanup","knownInstances","_","startsWith","substring","getKnownInstances","instance","putStatus","putAccount","storeStatus","storeNotification","notification","storeAccount","putNotification","insertTimelineItems","timelineItems","notifications","timelineStore","insertTimelineNotifications","statuses","existingKeys","newKeys","keysToDelete","otherStatus","insertStatusThread","slice","insertTimelineStatuses","insertStatus","fetchAccount","fetchStatus","insertPinnedStatuses","existingPinnedStatuses","createPinnedStatusId","getPinnedStatuses","pinnedResults","fetchNotification","getTimeline","timelineResults","getNotificationTimeline","thread","otherStatusId","getStatusThread","getStatusTimeline","getStatus","getNotification","doUpdateStatus","updateFunc","setStatusFavorited","favorited","delta","favourited","favourites_count","setStatusReblogged","reblogged","reblogs_count","setStatusPinned","pinned","setStatusMuted","muted","setStatusBookmarked","bookmarked","PROPS_THAT_CAN_BE_EDITED","updateStatus","newStatus","clonedNewStatus","prop","deleteStatusesAndNotifications","notificationIds","deleteStatus","deleteNotification","getMetaProperty","setMetaProperty","getInstanceVerifyCredentials","setInstanceVerifyCredentials","getInstanceInfo","setInstanceInfo","getLists","setLists","getCustomEmoji","setCustomEmoji","getFollowRequestCount","setFollowRequestCount","getFilters","setFilters","getRelationship","setRelationship","relationship","WEB_SHARE_TARGET_DATA_IDB_KEY","deleteWebShareData","setWebShareData","data","getWebShareData","closeKeyValIDBConnection","setLastTheme","getLastTheme","setIconColors","getIconColors","DELIMITER","DELETE_AFTER","deleteAfter","keyToData","indexOf","sort","getCachedMediaFile","allKeys","setCachedMediaFile","file","includes","maxStatusMediaAttachments","timestamp","parse","dataToKey","toISOString","deleteCachedMediaFile","getAllCachedFileIds","setDeleteCachedMediaFilesAfter","newDeleteAfter","CLEANUP_TIME_AGO","CLEANUP_DELAY","TIMELINE_BATCH_SIZE","timelines","home","label","local","bubble","federated","EventEmitter","QuickLRU","options","super","TypeError","Map","oldCache","_size","_set","listenerCount","emit","deleted","clear","Set","MIN_CHAR_CODE","MAX_CHAR_CODE","MAX_ID_LENGTH","zeroPad","str","toSize","toPaddedBigInt","toReversePaddedBigInt","padded","reversed","charCode","charCodeAt","inverseCharCode","String","fromCharCode","compareTimelineItemSummaries","left","right","leftPadded","rightPadded"],"sourceRoot":""}
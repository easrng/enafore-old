{"version":3,"file":"4255.dad85bce6e8f17f8ca93.4255.js","mappings":"iIAca,CACP,SAAAA,CAAWC,GAGT,MAAM,IAAEC,EAAG,OAAEC,GAAWF,EACxB,IAAK,CAAC,UAAW,aAAaG,SAASF,GACrC,OAEF,IAAKC,EAAOE,UAAUC,SAAS,sBAC7B,OAEF,MAAMC,EAAUC,MAAMC,KAAKC,KAAKC,KAAKC,WAAWC,uBAAuB,uBACjEC,EAAMP,EAAQQ,OAEdC,GAAYF,GADJG,KAAKC,IAAI,EAAGX,EAAQY,WAAUC,GAAkD,SAAxCA,EAAOC,aAAa,oBAChC,YAARnB,GAAqB,EAAI,KAAOY,EAClEP,EAAQS,GAAUM,QAClBf,EAAQS,GAAUO,QAClBtB,EAAEuB,iBACFvB,EAAEwB,iBACR,G,oEAEe,CACXC,UAAW,I,wKA/BA1B,UAAU2B,E,qNAJFD,W,yDAERE,Q,wBACDC,S,2GAHSH,a,kDAERE,O,qCACDC,S,gaAmCC,OAAEd,EAAM,GAAEe,I,OACnB,QAAMf,GAAQgB,GAAS,sBAAsBD,KAAMC,MAASC,KAAK,I,8ICbxD,CACXN,UAAW,I,2uBA5BeI,GAAE,MAAGC,M,uCACFE,QAAU,UAAY,eAAa,MAAGP,UAAS,mB,oDAE9DE,O,UACLA,O,2BACOK,Q,kGALUH,GAAE,MAAGC,S,kEACFE,QAAU,UAAY,eAAa,MAAGP,UAAS,qB,mDAE9DE,O,UACLA,O,uCACOK,Q,2QCHfC,eAAeC,EAAuBC,EAAgBC,EAAWC,EAAWC,GACjF,MAAMC,EAAiBJ,IACvB,IAAIK,EACJ,IACEA,QAAmBJ,GACrB,CAAE,MAAOK,GACPC,QAAQC,MAAM,mBAAoBF,EACpC,CAAE,QACID,GACFF,EAAYE,GAEd,MAAMI,EAAwBL,EAAeM,MAAKC,IACjCT,EAAUS,GACzBR,EAAYQ,EAAe,IAExBN,SACGI,CAEV,CACF,CAIOX,eAAec,EAAkCZ,EAAgBC,EAAWC,EAAWC,GAC5F,IAAIE,EACJ,IACEA,QAAmBJ,GACrB,CAAE,MAAOK,GACPC,QAAQC,MAAM,mBAAoBF,EACpC,CACA,GAAID,EACFF,EAAYE,OACP,CACL,MAAMM,QAAwBX,IACfE,EAAUS,GACzBR,EAAYQ,EACd,CACF,C","sources":["webpack:///./src/routes/_components/radio/RadioGroup.html","webpack:///./src/routes/_components/radio/RadioGroupButton.html","webpack:///./src/routes/_utils/sync.js"],"sourcesContent":["<!-- Modeled after https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/examples/radio/radio.html -->\n<div class=\"radio-group {className}\"\n     role=\"radiogroup\"\n     aria-label={label}\n     aria-owns={ariaOwns}\n     on:keydown=\"onKeyDown(event)\"\n     ref:radiogroup\n>\n  <slot></slot>\n</div>\n<script>\n  import { times } from '../../_utils/lodash-lite.js'\n\n  export default {\n    methods: {\n      onKeyDown (e) {\n        // ArrowUp and ArrowDown should change the focused/checked radio button per\n        // https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/examples/radio/radio.html\n        const { key, target } = e\n        if (!['ArrowUp', 'ArrowDown'].includes(key)) {\n          return\n        }\n        if (!target.classList.contains('radio-group-button')) {\n          return\n        }\n        const buttons = Array.from(this.refs.radiogroup.getElementsByClassName('radio-group-button'))\n        const len = buttons.length\n        const index = Math.max(0, buttons.findIndex(button => button.getAttribute('aria-checked') === 'true'))\n        const newIndex = (len + (index + (key === 'ArrowUp' ? -1 : 1))) % len // increment/decrement and wrap around\n        buttons[newIndex].focus()\n        buttons[newIndex].click()\n        e.preventDefault()\n        e.stopPropagation()\n      }\n    },\n    data: () => ({\n      className: ''\n    }),\n    computed: {\n      ariaOwns: ({ length, id }) => (\n        times(length, index => `radio-group-button-${id}-${index}`).join(' ')\n      )\n    }\n  }\n</script>\n","<button id=\"radio-group-button-{id}-{index}\"\n        class=\"radio-group-button {checked ? 'checked' : 'not-checked'} {className}\"\n        role=\"radio\"\n        aria-label={label}\n        title={label}\n        aria-checked={checked}\n        on:click\n>\n  <slot></slot>\n</button>\n<style>\n  .radio-group-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border: 0;\n    background: none;\n  }\n  .radio-group-button:hover {\n    background: none;\n  }\n  .radio-group-button:active {\n    background: none;\n  }\n</style>\n<script>\n  export default {\n    data: () => ({\n      className: ''\n    })\n  }\n</script>\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n"],"names":["onKeyDown","e","key","target","includes","classList","contains","buttons","Array","from","this","refs","radiogroup","getElementsByClassName","len","length","newIndex","Math","max","findIndex","button","getAttribute","focus","click","preventDefault","stopPropagation","className","event","label","ariaOwns","id","index","join","checked","async","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","err","console","error","fetchAndUpdatePromise","then","networkResponse","cacheFirstUpdateOnlyIfNotInCache"],"sourceRoot":""}
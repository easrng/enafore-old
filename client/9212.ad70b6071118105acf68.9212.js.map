{"version":3,"file":"9212.ad70b6071118105acf68.9212.js","mappings":"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","sources":["webpack:///./src/routes/_utils/googleTranslate.js","webpack:///./src/routes/_utils/googleTranslateHTML.js"],"sourcesContent":["import getGoogleTranslateHTML from './googleTranslateHTML.js'\nimport { languageList } from 'lingva-scraper/dist/utils/language.js'\nexport const languageNames = languageList.all\nexport const translate = getGoogleTranslateHTML(async function translate (text, to, from) {\n  const data = (await (await fetch('https://lingva.garudalinux.org/api/graphql', {\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      query: 'query($q:String!,$s:String!,$t:String!){translation(query:$q,source:$s,target:$t){source{detected{code}}target{text}}}',\n      variables: {\n        q: text,\n        s: from,\n        t: to\n      }\n    }),\n    method: 'POST'\n  })).json()).data.translation\n  return {\n    detected: data.source.detected.code,\n    text: data.target.text,\n    to,\n    from\n  }\n})\n","import DOMPurify from 'dompurify'\nimport escapeHtml from 'escape-html'\nconst ELEMENT_NODE = 1\nconst TEXT_NODE = 3\nexport default (translate) =>\n  async function googleTranslateHTML (html, to, from = 'auto') {\n    const parser = new DOMParser()\n    const doc = parser.parseFromString(html, 'text/html')\n    const nodes = doc.body.childNodes\n    function isInline (node) {\n      return !node || node.nodeType !== ELEMENT_NODE || getComputedStyle(node).display.startsWith('inline')\n    }\n    function getAttributes (element) {\n      const attributes = {}\n      for (let i = 0; i < element.attributes.length; i++) {\n        const attribute = element.attributes[i]\n        attributes[attribute.name] = attribute.value\n      }\n      return attributes\n    }\n    let nodeIdCounter = 0\n    function flattenNode (node) {\n      if (node.nodeType === ELEMENT_NODE) {\n        node.setAttribute('data-id', nodeIdCounter++)\n        const tag = {\n          tagName: node.tagName,\n          attributes: getAttributes(node)\n        }\n        if (node.childNodes.length < 1) {\n          node.appendChild(doc.createTextNode(''))\n        }\n        return [\n          { tag, open: true },\n          ...[...node.childNodes].map((e) => flattenNode(e)),\n          { close: true }\n        ].flat()\n      } else if (node.nodeType === node.TEXT_NODE) {\n        return node.data\n      }\n    }\n    const flattenedWithTags = [...nodes].map((e) => flattenNode(e)).flat()\n    let tagStack = []\n    let counter = 0\n    const tagStacks = {}\n    const numberified = []\n    for (let e of flattenedWithTags) {\n      if (typeof e === 'object') {\n        if (e.open) {\n          tagStack.push(e.tag)\n        } else if (e.close) {\n          tagStack.pop()\n        }\n      } else {\n        const id = counter++\n        tagStacks[id] = [...tagStack].reverse()\n        e = escapeHtml(e).replace(/(&[^;]+;)/g, '<a>$1</a>')\n        numberified.push(\n          tagStack.length > 0 ? ['<a i=' + id + '>', e, '</a>'] : [e]\n        )\n      }\n    }\n    const translated = await translate(\n      numberified.flat().join('') + '<a></a>',\n      to,\n      from\n    )\n    const translatedDoc = parser.parseFromString(translated.text.replace(/<\\s+(?:(\\/)\\s*)?a([\\s>])/g, '<$1a$2'), 'text/html')\n    const translatedFlattenedWithTags = [...translatedDoc.body.childNodes]\n      .map((e) => flattenNode(e))\n      .flat()\n    const out = []\n    tagStack = []\n    for (const e of translatedFlattenedWithTags) {\n      if (typeof e === 'object') {\n        if (e.open) {\n          tagStack.push(e.tag)\n        } else if (e.close) {\n          tagStack.pop()\n        }\n      } else {\n        if (tagStack.length < 1) {\n          out.push(e)\n        } else {\n          const id = tagStack[0].attributes.i\n          let t = e\n          const rtags = id ? tagStacks[id] : []\n          for (const tag of rtags) {\n            const newLayer = translatedDoc.createElement(tag.tagName)\n            for (const attr in tag.attributes) { newLayer.setAttribute(attr, tag.attributes[attr]) }\n            newLayer.append(t)\n            t = newLayer\n          }\n          out.push(t)\n        }\n      }\n    }\n    function mergeSiblingElements (node) {\n      if (node.firstChild) {\n        mergeSiblingElements(node.firstChild)\n      }\n      // base case: if the node has no siblings, return the node\n      if (!node.nextSibling) {\n        return node\n      }\n      // check if the node and its sibling have the same data-id attribute\n      const nodeInline = isInline(node)\n      while (\n        node.nextSibling.nodeType === TEXT_NODE &&\n        (nodeInline ? node.nextSibling.data === '' : !node.nextSibling.data.trim())\n      ) {\n        node.nextSibling.remove()\n        if (!node.nextSibling) {\n          return node\n        }\n      }\n      if (\n        node.nextSibling.nodeType === ELEMENT_NODE &&\n        node.nodeType === ELEMENT_NODE &&\n        node.getAttribute('data-id') ===\n          node.nextSibling.getAttribute('data-id')\n      ) {\n        // if they do, merge the sibling into the node by moving all of its child nodes into the node\n        while (node.nextSibling.firstChild) {\n          node.appendChild(node.nextSibling.firstChild)\n        }\n        // remove the sibling from the DOM\n        node.parentNode.removeChild(node.nextSibling)\n        // call the function again with the node as the argument, to check for any further siblings with the same data-id attribute\n        return mergeSiblingElements(node)\n      } else {\n        // if the node and its sibling do not have the same data-id attribute, call the function with the sibling as the argument\n        return mergeSiblingElements(node.nextSibling)\n      }\n    }\n    const div = doc.createElement('div')\n    div.append(...out)\n    mergeSiblingElements(div.firstChild)\n    const spoilerEle = div.querySelector('.spoiler_text')\n    let spoiler\n    if (spoilerEle) {\n      spoiler = DOMPurify.sanitize(spoilerEle.innerHTML.trimEnd())\n      spoilerEle.remove()\n    }\n    return {\n      spoiler,\n      html: DOMPurify.sanitize(div.innerHTML),\n      detected: translated.detected\n    }\n  }\n"],"names":["languageNames","all","translate","async","html","to","from","parser","DOMParser","doc","parseFromString","nodes","body","childNodes","getAttributes","element","attributes","i","length","attribute","name","value","nodeIdCounter","flattenNode","node","nodeType","setAttribute","tag","tagName","appendChild","createTextNode","open","map","e","close","flat","TEXT_NODE","data","flattenedWithTags","tagStack","counter","tagStacks","numberified","push","pop","id","reverse","replace","translated","join","translatedDoc","text","translatedFlattenedWithTags","out","t","rtags","newLayer","createElement","attr","append","div","mergeSiblingElements","firstChild","nextSibling","nodeInline","getComputedStyle","display","startsWith","isInline","trim","remove","getAttribute","parentNode","removeChild","spoilerEle","querySelector","spoiler","sanitize","innerHTML","trimEnd","detected","fetch","headers","JSON","stringify","query","variables","q","s","method","json","translation","source","code","target"],"sourceRoot":""}
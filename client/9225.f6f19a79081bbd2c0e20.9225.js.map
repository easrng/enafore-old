{"version":3,"file":"9225.f6f19a79081bbd2c0e20.9225.js","mappings":"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","sources":["webpack:///./src/routes/_components/virtualList/virtualListStore.js","webpack:///./src/routes/_utils/reselect.js","webpack:///./src/routes/_utils/RealmStore.js"],"sourcesContent":["import { mark, stop } from '../../_utils/marks.js'\nimport { RealmStore } from '../../_utils/RealmStore.js'\nimport { reselect } from '../../_utils/reselect.js'\n\nconst RENDER_BUFFER_FACTOR = 2.5\n\nclass VirtualListStore extends RealmStore {\n  constructor (state) {\n    super(state, /* maxSize */ 10)\n  }\n\n  // TODO: this is hacky\n  clearRealmByPrefix (prefix) {\n    const { realms } = this.get()\n    if (!realms) {\n      return\n    }\n    for (const key of realms.getAllKeys()) {\n      if (key.startsWith(prefix)) {\n        console.log('deleted realm', key)\n        realms.delete(key)\n      }\n    }\n    this.set({ realms })\n  }\n}\n\nconst virtualListStore = new VirtualListStore()\n\nvirtualListStore.computeForRealm('items', null)\nvirtualListStore.computeForRealm('showFooter', false)\nvirtualListStore.computeForRealm('footerHeight', 0)\nvirtualListStore.computeForRealm('showHeader', false)\nvirtualListStore.computeForRealm('headerHeight', 0)\nvirtualListStore.computeForRealm('scrollTop', 0)\nvirtualListStore.computeForRealm('scrollHeight', 0)\nvirtualListStore.computeForRealm('offsetHeight', 0)\nvirtualListStore.computeForRealm('listOffset', 0)\nvirtualListStore.computeForRealm('itemHeights', {})\n\nvirtualListStore.compute('rawVisibleItems',\n  ['items', 'scrollTop', 'itemHeights', 'offsetHeight', 'showHeader', 'headerHeight', 'listOffset'],\n  (items, scrollTop, itemHeights, offsetHeight, showHeader, headerHeight, listOffset) => {\n    if (process.browser && process.env.NODE_ENV !== 'production') {\n      window.rawVisibleItemsComputed = (window.rawVisibleItemsComputed || 0) + 1\n    }\n    mark('compute visibleItems')\n    if (!items) {\n      return null\n    }\n    const effectiveScrollTop = scrollTop - listOffset\n    const renderBuffer = RENDER_BUFFER_FACTOR * offsetHeight\n    const visibleItems = []\n    let totalOffset = showHeader ? headerHeight : 0\n    const len = items.length\n    let i = -1\n    while (++i < len) {\n      const key = items[i]\n      const height = itemHeights[key] || 0\n      const currentOffset = totalOffset\n      totalOffset += height\n      const isAboveViewport = (currentOffset < effectiveScrollTop)\n      if (isAboveViewport) {\n        if ((effectiveScrollTop - height - renderBuffer) > currentOffset) {\n          continue // above the area we want to render\n        }\n      } else {\n        if (currentOffset > (effectiveScrollTop + offsetHeight + renderBuffer)) {\n          break // below the area we want to render\n        }\n      }\n      visibleItems.push({\n        offset: currentOffset,\n        key,\n        index: i\n      })\n    }\n    stop('compute visibleItems')\n    return visibleItems\n  })\n\nreselect(virtualListStore, 'visibleItems', 'rawVisibleItems')\n\nvirtualListStore.compute('heightWithoutFooter',\n  ['items', 'itemHeights', 'showHeader', 'headerHeight'],\n  (items, itemHeights, showHeader, headerHeight) => {\n    if (!items) {\n      return 0\n    }\n    let sum = showHeader ? headerHeight : 0\n    let i = -1\n    const len = items.length\n    while (++i < len) {\n      sum += itemHeights[items[i]] || 0\n    }\n    return sum\n  })\n\nvirtualListStore.compute('height',\n  ['heightWithoutFooter', 'showFooter', 'footerHeight'],\n  (heightWithoutFooter, showFooter, footerHeight) => {\n    return showFooter ? (heightWithoutFooter + footerHeight) : heightWithoutFooter\n  })\n\nvirtualListStore.compute('length', ['items'], (items) => items ? items.length : 0)\n\nvirtualListStore.compute('allVisibleItemsHaveHeight',\n  ['visibleItems', 'itemHeights'],\n  (visibleItems, itemHeights) => {\n    if (!visibleItems) {\n      return false\n    }\n    for (const visibleItem of visibleItems) {\n      if (!itemHeights[visibleItem.key]) {\n        return false\n      }\n    }\n    return true\n  })\n\nif (process.browser) {\n  window.__virtualListStore = virtualListStore // for debugging\n\n  if (process.env.NODE_ENV !== 'production') { // for extra debugging\n    virtualListStore.on('state', ({ changed }) => {\n      if (changed.visibleItems) {\n        window.visibleItemsChangedCount = (window.visibleItemsChangedCount || 0) + 1\n      }\n      if (changed.rawVisibleItems) {\n        window.rawVisibleItemsChangedCount = (window.rawVisibleItemsChangedCount || 0) + 1\n      }\n    })\n  }\n}\n\nexport {\n  virtualListStore\n}\n","// Avoid re-renders by caching the most recent value of an array\n// or an object, using an approach similar to https://github.com/reactjs/reselect.\n// This avoids the issue where Svelte may keep re-rendering because it doesn't\n// know if an object/array has changed or not.\n\nimport { isEqual } from '../_thirdparty/lodash/objects.js'\n\nif (process.browser && process.env.NODE_ENV !== 'production') {\n  window.reselectStats = {}\n}\n\nexport function reselect (store, outputKey, inputKey) {\n  let prevValue\n  let nextValue\n  let count = 0\n  const countKey = `${outputKey}_reselectCount`\n\n  store.compute(countKey, [inputKey], input => {\n    if (process.browser && process.env.NODE_ENV !== 'production') {\n      window.reselectStats[inputKey] = window.reselectStats[inputKey] || { numInputChanges: 0, numOutputChanges: 0 }\n      window.reselectStats[inputKey].numInputChanges++\n    }\n    if (!isEqual(prevValue, input)) {\n      nextValue = input\n      count++\n    }\n    return count\n  })\n\n  store.compute(outputKey, [countKey], () => {\n    if (process.browser && process.env.NODE_ENV !== 'production') {\n      window.reselectStats[inputKey].numOutputChanges++\n    }\n    prevValue = nextValue\n    nextValue = null\n    return prevValue\n  })\n}\n","// A store where you can divide data into \"realms\" that are backed with an LRU cache.\n// Each realm has self-contained data that you can set with setForRealm() and compute\n// with computeForRealm(). The maxSize determines how many realms to keep in the LRU cache.\nimport { QuickLRU } from '../_thirdparty/quick-lru/quick-lru.js'\nimport { mark, stop } from './marks.js'\nimport { requestPostAnimationFrame } from './requestPostAnimationFrame.js'\nimport * as storePackage from 'svelte/store.umd.js'\n\nconst { Store } = storePackage\n\nexport class RealmStore extends Store {\n  constructor (init, maxSize) {\n    super(init)\n    this.set({ realms: new QuickLRU({ maxSize }) })\n    this._batches = {}\n  }\n\n  setCurrentRealm (realm) {\n    this.set({ currentRealm: realm })\n  }\n\n  setForRealm (obj) {\n    const { currentRealm, realms } = this.get()\n    realms.set(currentRealm, Object.assign(realms.get(currentRealm) || {}, obj))\n    this.set({ realms })\n  }\n\n  computeForRealm (key, defaultValue) {\n    this.compute(key,\n      ['realms', 'currentRealm'],\n      (realms, currentRealm) => {\n        const realmData = realms.get(currentRealm)\n        return (realmData && realmData[key]) || defaultValue\n      })\n  }\n\n  /*\n   * Update several values at once in a realm, assuming the key points\n   * to a plain old javascript object.\n   */\n  batchUpdateForRealm (key, subKey, value) {\n    const { currentRealm } = this.get()\n    let realmBatches = this._batches[currentRealm]\n    if (!realmBatches) {\n      realmBatches = this._batches[currentRealm] = {}\n    }\n    let batch = realmBatches[key]\n    if (!batch) {\n      batch = realmBatches[key] = {}\n    }\n    batch[subKey] = value\n\n    requestPostAnimationFrame(() => {\n      const batch = this._batches[currentRealm] && this._batches[currentRealm][key]\n      if (!batch) {\n        return\n      }\n      const updatedKeys = Object.keys(batch)\n      if (!updatedKeys.length) {\n        return\n      }\n      mark('batchUpdate')\n      const obj = this.get()[key]\n      for (const otherKey of updatedKeys) {\n        obj[otherKey] = batch[otherKey]\n      }\n      delete this._batches[currentRealm][key]\n      const { realms } = this.get()\n      realms.set(currentRealm, Object.assign(realms.get(currentRealm) || {}, { [key]: obj }))\n      this.set({ realms })\n      stop('batchUpdate')\n    })\n  }\n}\n"],"names":["VirtualListStore","RealmStore","constructor","state","super","clearRealmByPrefix","prefix","realms","this","get","key","getAllKeys","startsWith","delete","set","virtualListStore","computeForRealm","compute","items","scrollTop","itemHeights","offsetHeight","showHeader","headerHeight","listOffset","effectiveScrollTop","renderBuffer","visibleItems","totalOffset","len","length","i","height","currentOffset","push","offset","index","s","store","outputKey","inputKey","prevValue","nextValue","count","countKey","input","reselect","sum","heightWithoutFooter","showFooter","footerHeight","visibleItem","window","__virtualListStore","Store","init","maxSize","_batches","setCurrentRealm","realm","currentRealm","setForRealm","obj","Object","assign","defaultValue","realmData","batchUpdateForRealm","subKey","value","realmBatches","batch","updatedKeys","keys","otherKey"],"sourceRoot":""}
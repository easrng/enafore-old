{"version":3,"file":"3999.e1e874f8c4b566a0b9f3.3999.js","mappings":"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","sources":["webpack:///./node_modules/pointer-tracker/dist/PointerTracker.mjs","webpack:///./node_modules/pinch-zoom-element/dist/pinch-zoom.es.js"],"sourcesContent":["class Pointer {\r\n    constructor(nativePointer) {\r\n        /** Unique ID for this pointer */\r\n        this.id = -1;\r\n        this.nativePointer = nativePointer;\r\n        this.pageX = nativePointer.pageX;\r\n        this.pageY = nativePointer.pageY;\r\n        this.clientX = nativePointer.clientX;\r\n        this.clientY = nativePointer.clientY;\r\n        if (self.Touch && nativePointer instanceof Touch) {\r\n            this.id = nativePointer.identifier;\r\n        }\r\n        else if (isPointerEvent(nativePointer)) {\r\n            // is PointerEvent\r\n            this.id = nativePointer.pointerId;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an expanded set of Pointers for high-resolution inputs.\r\n     */\r\n    getCoalesced() {\r\n        if ('getCoalescedEvents' in this.nativePointer) {\r\n            const events = this.nativePointer\r\n                .getCoalescedEvents()\r\n                .map((p) => new Pointer(p));\r\n            // Firefox sometimes returns an empty list here. I'm not sure it's doing the right thing.\r\n            // https://github.com/w3c/pointerevents/issues/409\r\n            if (events.length > 0)\r\n                return events;\r\n        }\r\n        return [this];\r\n    }\r\n}\r\nconst isPointerEvent = (event) => 'pointerId' in event;\r\nconst isTouchEvent = (event) => 'changedTouches' in event;\r\nconst noop = () => { };\r\n/**\r\n * Track pointers across a particular element\r\n */\r\nclass PointerTracker {\r\n    /**\r\n     * Track pointers across a particular element\r\n     *\r\n     * @param element Element to monitor.\r\n     * @param options\r\n     */\r\n    constructor(_element, { start = () => true, move = noop, end = noop, rawUpdates = false, avoidPointerEvents = false, } = {}) {\r\n        this._element = _element;\r\n        /**\r\n         * State of the tracked pointers when they were pressed/touched.\r\n         */\r\n        this.startPointers = [];\r\n        /**\r\n         * Latest state of the tracked pointers. Contains the same number of pointers, and in the same\r\n         * order as this.startPointers.\r\n         */\r\n        this.currentPointers = [];\r\n        /**\r\n         * Firefox has a bug where touch-based pointer events have a `buttons` of 0, when this shouldn't\r\n         * happen. https://bugzilla.mozilla.org/show_bug.cgi?id=1729440\r\n         *\r\n         * Usually we treat `buttons === 0` as no-longer-pressed. This set allows us to exclude these\r\n         * buggy Firefox events.\r\n         */\r\n        this._excludeFromButtonsCheck = new Set();\r\n        /**\r\n         * Listener for mouse/pointer starts.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerStart = (event) => {\r\n            if (isPointerEvent(event) && event.buttons === 0) {\r\n                // This is the buggy Firefox case. See _excludeFromButtonsCheck.\r\n                this._excludeFromButtonsCheck.add(event.pointerId);\r\n            }\r\n            else if (!(event.buttons & 1 /* LeftMouseOrTouchOrPenDown */)) {\r\n                return;\r\n            }\r\n            const pointer = new Pointer(event);\r\n            // If we're already tracking this pointer, ignore this event.\r\n            // This happens with mouse events when multiple buttons are pressed.\r\n            if (this.currentPointers.some((p) => p.id === pointer.id))\r\n                return;\r\n            if (!this._triggerPointerStart(pointer, event))\r\n                return;\r\n            // Add listeners for additional events.\r\n            // The listeners may already exist, but no harm in adding them again.\r\n            if (isPointerEvent(event)) {\r\n                const capturingElement = event.target && 'setPointerCapture' in event.target\r\n                    ? event.target\r\n                    : this._element;\r\n                capturingElement.setPointerCapture(event.pointerId);\r\n                this._element.addEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.addEventListener('pointerup', this._pointerEnd);\r\n                this._element.addEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.addEventListener('mousemove', this._move);\r\n                window.addEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchstart.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchStart = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerStart(new Pointer(touch), event);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for pointer/mouse/touch move events.\r\n         */\r\n        this._move = (event) => {\r\n            if (!isTouchEvent(event) &&\r\n                (!isPointerEvent(event) ||\r\n                    !this._excludeFromButtonsCheck.has(event.pointerId)) &&\r\n                event.buttons === 0 /* None */) {\r\n                // This happens in a number of buggy cases where the browser failed to deliver a pointerup\r\n                // or pointercancel. If we see the pointer moving without any buttons down, synthesize an end.\r\n                // https://github.com/w3c/pointerevents/issues/407\r\n                // https://github.com/w3c/pointerevents/issues/408\r\n                this._pointerEnd(event);\r\n                return;\r\n            }\r\n            const previousPointers = this.currentPointers.slice();\r\n            const changedPointers = isTouchEvent(event)\r\n                ? Array.from(event.changedTouches).map((t) => new Pointer(t))\r\n                : [new Pointer(event)];\r\n            const trackedChangedPointers = [];\r\n            for (const pointer of changedPointers) {\r\n                const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n                if (index === -1)\r\n                    continue; // Not a pointer we're tracking\r\n                trackedChangedPointers.push(pointer);\r\n                this.currentPointers[index] = pointer;\r\n            }\r\n            if (trackedChangedPointers.length === 0)\r\n                return;\r\n            this._moveCallback(previousPointers, trackedChangedPointers, event);\r\n        };\r\n        /**\r\n         * Call the end callback for this pointer.\r\n         *\r\n         * @param pointer Pointer\r\n         * @param event Related event\r\n         */\r\n        this._triggerPointerEnd = (pointer, event) => {\r\n            // Main button still down?\r\n            // With mouse events, you get a mouseup per mouse button, so the left button might still be down.\r\n            if (!isTouchEvent(event) &&\r\n                event.buttons & 1 /* LeftMouseOrTouchOrPenDown */) {\r\n                return false;\r\n            }\r\n            const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n            // Not a pointer we're interested in?\r\n            if (index === -1)\r\n                return false;\r\n            this.currentPointers.splice(index, 1);\r\n            this.startPointers.splice(index, 1);\r\n            this._excludeFromButtonsCheck.delete(pointer.id);\r\n            // The event.type might be a 'move' event due to workarounds for weird mouse behaviour.\r\n            // See _move for details.\r\n            const cancelled = !(event.type === 'mouseup' ||\r\n                event.type === 'touchend' ||\r\n                event.type === 'pointerup');\r\n            this._endCallback(pointer, event, cancelled);\r\n            return true;\r\n        };\r\n        /**\r\n         * Listener for mouse/pointer ends.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerEnd = (event) => {\r\n            if (!this._triggerPointerEnd(new Pointer(event), event))\r\n                return;\r\n            if (isPointerEvent(event)) {\r\n                if (this.currentPointers.length)\r\n                    return;\r\n                this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.removeEventListener('pointerup', this._pointerEnd);\r\n                this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.removeEventListener('mousemove', this._move);\r\n                window.removeEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchend.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchEnd = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerEnd(new Pointer(touch), event);\r\n            }\r\n        };\r\n        this._startCallback = start;\r\n        this._moveCallback = move;\r\n        this._endCallback = end;\r\n        this._rawUpdates = rawUpdates && 'onpointerrawupdate' in window;\r\n        // Add listeners\r\n        if (self.PointerEvent && !avoidPointerEvents) {\r\n            this._element.addEventListener('pointerdown', this._pointerStart);\r\n        }\r\n        else {\r\n            this._element.addEventListener('mousedown', this._pointerStart);\r\n            this._element.addEventListener('touchstart', this._touchStart);\r\n            this._element.addEventListener('touchmove', this._move);\r\n            this._element.addEventListener('touchend', this._touchEnd);\r\n            this._element.addEventListener('touchcancel', this._touchEnd);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stop() {\r\n        this._element.removeEventListener('pointerdown', this._pointerStart);\r\n        this._element.removeEventListener('mousedown', this._pointerStart);\r\n        this._element.removeEventListener('touchstart', this._touchStart);\r\n        this._element.removeEventListener('touchmove', this._move);\r\n        this._element.removeEventListener('touchend', this._touchEnd);\r\n        this._element.removeEventListener('touchcancel', this._touchEnd);\r\n        this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n        this._element.removeEventListener('pointerup', this._pointerEnd);\r\n        this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n        window.removeEventListener('mousemove', this._move);\r\n        window.removeEventListener('mouseup', this._pointerEnd);\r\n    }\r\n    /**\r\n     * Call the start callback for this pointer, and track it if the user wants.\r\n     *\r\n     * @param pointer Pointer\r\n     * @param event Related event\r\n     * @returns Whether the pointer is being tracked.\r\n     */\r\n    _triggerPointerStart(pointer, event) {\r\n        if (!this._startCallback(pointer, event))\r\n            return false;\r\n        this.currentPointers.push(pointer);\r\n        this.startPointers.push(pointer);\r\n        return true;\r\n    }\r\n}\n\nexport { PointerTracker as default };\n","import PointerTracker from 'pointer-tracker';\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \"pinch-zoom {\\n  display: block;\\n  overflow: hidden;\\n  touch-action: none;\\n  --scale: 1;\\n  --x: 0;\\n  --y: 0;\\n}\\n\\npinch-zoom > * {\\n  transform: translate(var(--x), var(--y)) scale(var(--scale));\\n  transform-origin: 0 0;\\n  will-change: transform;\\n}\\n\";\nstyleInject(css);\n\nconst minScaleAttr = 'min-scale';\r\nfunction getDistance(a, b) {\r\n    if (!b)\r\n        return 0;\r\n    return Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);\r\n}\r\nfunction getMidpoint(a, b) {\r\n    if (!b)\r\n        return a;\r\n    return {\r\n        clientX: (a.clientX + b.clientX) / 2,\r\n        clientY: (a.clientY + b.clientY) / 2,\r\n    };\r\n}\r\nfunction getAbsoluteValue(value, max) {\r\n    if (typeof value === 'number')\r\n        return value;\r\n    if (value.trimRight().endsWith('%')) {\r\n        return max * parseFloat(value) / 100;\r\n    }\r\n    return parseFloat(value);\r\n}\r\n// I'd rather use DOMMatrix/DOMPoint here, but the browser support isn't good enough.\r\n// Given that, better to use something everything supports.\r\nlet cachedSvg;\r\nfunction getSVG() {\r\n    return cachedSvg || (cachedSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'));\r\n}\r\nfunction createMatrix() {\r\n    return getSVG().createSVGMatrix();\r\n}\r\nfunction createPoint() {\r\n    return getSVG().createSVGPoint();\r\n}\r\nconst MIN_SCALE = 0.01;\r\nclass PinchZoom extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        // Current transform.\r\n        this._transform = createMatrix();\r\n        // Watch for children changes.\r\n        // Note this won't fire for initial contents,\r\n        // so _stageElChange is also called in connectedCallback.\r\n        new MutationObserver(() => this._stageElChange())\r\n            .observe(this, { childList: true });\r\n        // Watch for pointers\r\n        const pointerTracker = new PointerTracker(this, {\r\n            start: (pointer, event) => {\r\n                // We only want to track 2 pointers at most\r\n                if (pointerTracker.currentPointers.length === 2 || !this._positioningEl)\r\n                    return false;\r\n                event.preventDefault();\r\n                return true;\r\n            },\r\n            move: (previousPointers) => {\r\n                this._onPointerMove(previousPointers, pointerTracker.currentPointers);\r\n            },\r\n        });\r\n        this.addEventListener('wheel', event => this._onWheel(event));\r\n    }\r\n    static get observedAttributes() { return [minScaleAttr]; }\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n        if (name === minScaleAttr) {\r\n            if (this.scale < this.minScale) {\r\n                this.setTransform({ scale: this.minScale });\r\n            }\r\n        }\r\n    }\r\n    get minScale() {\r\n        const attrValue = this.getAttribute(minScaleAttr);\r\n        if (!attrValue)\r\n            return MIN_SCALE;\r\n        const value = parseFloat(attrValue);\r\n        if (Number.isFinite(value))\r\n            return Math.max(MIN_SCALE, value);\r\n        return MIN_SCALE;\r\n    }\r\n    set minScale(value) {\r\n        this.setAttribute(minScaleAttr, String(value));\r\n    }\r\n    connectedCallback() {\r\n        this._stageElChange();\r\n    }\r\n    get x() {\r\n        return this._transform.e;\r\n    }\r\n    get y() {\r\n        return this._transform.f;\r\n    }\r\n    get scale() {\r\n        return this._transform.a;\r\n    }\r\n    /**\r\n     * Change the scale, adjusting x/y by a given transform origin.\r\n     */\r\n    scaleTo(scale, opts = {}) {\r\n        let { originX = 0, originY = 0, } = opts;\r\n        const { relativeTo = 'content', allowChangeEvent = false, } = opts;\r\n        const relativeToEl = (relativeTo === 'content' ? this._positioningEl : this);\r\n        // No content element? Fall back to just setting scale\r\n        if (!relativeToEl || !this._positioningEl) {\r\n            this.setTransform({ scale, allowChangeEvent });\r\n            return;\r\n        }\r\n        const rect = relativeToEl.getBoundingClientRect();\r\n        originX = getAbsoluteValue(originX, rect.width);\r\n        originY = getAbsoluteValue(originY, rect.height);\r\n        if (relativeTo === 'content') {\r\n            originX += this.x;\r\n            originY += this.y;\r\n        }\r\n        else {\r\n            const currentRect = this._positioningEl.getBoundingClientRect();\r\n            originX -= currentRect.left;\r\n            originY -= currentRect.top;\r\n        }\r\n        this._applyChange({\r\n            allowChangeEvent,\r\n            originX,\r\n            originY,\r\n            scaleDiff: scale / this.scale,\r\n        });\r\n    }\r\n    /**\r\n     * Update the stage with a given scale/x/y.\r\n     */\r\n    setTransform(opts = {}) {\r\n        const { scale = this.scale, allowChangeEvent = false, } = opts;\r\n        let { x = this.x, y = this.y, } = opts;\r\n        // If we don't have an element to position, just set the value as given.\r\n        // We'll check bounds later.\r\n        if (!this._positioningEl) {\r\n            this._updateTransform(scale, x, y, allowChangeEvent);\r\n            return;\r\n        }\r\n        // Get current layout\r\n        const thisBounds = this.getBoundingClientRect();\r\n        const positioningElBounds = this._positioningEl.getBoundingClientRect();\r\n        // Not displayed. May be disconnected or display:none.\r\n        // Just take the values, and we'll check bounds later.\r\n        if (!thisBounds.width || !thisBounds.height) {\r\n            this._updateTransform(scale, x, y, allowChangeEvent);\r\n            return;\r\n        }\r\n        // Create points for _positioningEl.\r\n        let topLeft = createPoint();\r\n        topLeft.x = positioningElBounds.left - thisBounds.left;\r\n        topLeft.y = positioningElBounds.top - thisBounds.top;\r\n        let bottomRight = createPoint();\r\n        bottomRight.x = positioningElBounds.width + topLeft.x;\r\n        bottomRight.y = positioningElBounds.height + topLeft.y;\r\n        // Calculate the intended position of _positioningEl.\r\n        const matrix = createMatrix()\r\n            .translate(x, y)\r\n            .scale(scale)\r\n            // Undo current transform\r\n            .multiply(this._transform.inverse());\r\n        topLeft = topLeft.matrixTransform(matrix);\r\n        bottomRight = bottomRight.matrixTransform(matrix);\r\n        // Ensure _positioningEl can't move beyond out-of-bounds.\r\n        // Correct for x\r\n        if (topLeft.x > thisBounds.width) {\r\n            x += thisBounds.width - topLeft.x;\r\n        }\r\n        else if (bottomRight.x < 0) {\r\n            x += -bottomRight.x;\r\n        }\r\n        // Correct for y\r\n        if (topLeft.y > thisBounds.height) {\r\n            y += thisBounds.height - topLeft.y;\r\n        }\r\n        else if (bottomRight.y < 0) {\r\n            y += -bottomRight.y;\r\n        }\r\n        this._updateTransform(scale, x, y, allowChangeEvent);\r\n    }\r\n    /**\r\n     * Update transform values without checking bounds. This is only called in setTransform.\r\n     */\r\n    _updateTransform(scale, x, y, allowChangeEvent) {\r\n        // Avoid scaling to zero\r\n        if (scale < this.minScale)\r\n            return;\r\n        // Return if there's no change\r\n        if (scale === this.scale &&\r\n            x === this.x &&\r\n            y === this.y)\r\n            return;\r\n        this._transform.e = x;\r\n        this._transform.f = y;\r\n        this._transform.d = this._transform.a = scale;\r\n        this.style.setProperty('--x', this.x + 'px');\r\n        this.style.setProperty('--y', this.y + 'px');\r\n        this.style.setProperty('--scale', this.scale + '');\r\n        if (allowChangeEvent) {\r\n            const event = new Event('change', { bubbles: true });\r\n            this.dispatchEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Called when the direct children of this element change.\r\n     * Until we have have shadow dom support across the board, we\r\n     * require a single element to be the child of <pinch-zoom>, and\r\n     * that's the element we pan/scale.\r\n     */\r\n    _stageElChange() {\r\n        this._positioningEl = undefined;\r\n        if (this.children.length === 0)\r\n            return;\r\n        this._positioningEl = this.children[0];\r\n        if (this.children.length > 1) {\r\n            console.warn('<pinch-zoom> must not have more than one child.');\r\n        }\r\n        // Do a bounds check\r\n        this.setTransform({ allowChangeEvent: true });\r\n    }\r\n    _onWheel(event) {\r\n        if (!this._positioningEl)\r\n            return;\r\n        event.preventDefault();\r\n        const currentRect = this._positioningEl.getBoundingClientRect();\r\n        let { deltaY } = event;\r\n        const { ctrlKey, deltaMode } = event;\r\n        if (deltaMode === 1) { // 1 is \"lines\", 0 is \"pixels\"\r\n            // Firefox uses \"lines\" for some types of mouse\r\n            deltaY *= 15;\r\n        }\r\n        // ctrlKey is true when pinch-zooming on a trackpad.\r\n        const divisor = ctrlKey ? 100 : 300;\r\n        const scaleDiff = 1 - deltaY / divisor;\r\n        this._applyChange({\r\n            scaleDiff,\r\n            originX: event.clientX - currentRect.left,\r\n            originY: event.clientY - currentRect.top,\r\n            allowChangeEvent: true,\r\n        });\r\n    }\r\n    _onPointerMove(previousPointers, currentPointers) {\r\n        if (!this._positioningEl)\r\n            return;\r\n        // Combine next points with previous points\r\n        const currentRect = this._positioningEl.getBoundingClientRect();\r\n        // For calculating panning movement\r\n        const prevMidpoint = getMidpoint(previousPointers[0], previousPointers[1]);\r\n        const newMidpoint = getMidpoint(currentPointers[0], currentPointers[1]);\r\n        // Midpoint within the element\r\n        const originX = prevMidpoint.clientX - currentRect.left;\r\n        const originY = prevMidpoint.clientY - currentRect.top;\r\n        // Calculate the desired change in scale\r\n        const prevDistance = getDistance(previousPointers[0], previousPointers[1]);\r\n        const newDistance = getDistance(currentPointers[0], currentPointers[1]);\r\n        const scaleDiff = prevDistance ? newDistance / prevDistance : 1;\r\n        this._applyChange({\r\n            originX, originY, scaleDiff,\r\n            panX: newMidpoint.clientX - prevMidpoint.clientX,\r\n            panY: newMidpoint.clientY - prevMidpoint.clientY,\r\n            allowChangeEvent: true,\r\n        });\r\n    }\r\n    /** Transform the view & fire a change event */\r\n    _applyChange(opts = {}) {\r\n        const { panX = 0, panY = 0, originX = 0, originY = 0, scaleDiff = 1, allowChangeEvent = false, } = opts;\r\n        const matrix = createMatrix()\r\n            // Translate according to panning.\r\n            .translate(panX, panY)\r\n            // Scale about the origin.\r\n            .translate(originX, originY)\r\n            // Apply current translate\r\n            .translate(this.x, this.y)\r\n            .scale(scaleDiff)\r\n            .translate(-originX, -originY)\r\n            // Apply current scale.\r\n            .scale(this.scale);\r\n        // Convert the transform into basic translate & scale.\r\n        this.setTransform({\r\n            allowChangeEvent,\r\n            scale: matrix.a,\r\n            x: matrix.e,\r\n            y: matrix.f,\r\n        });\r\n    }\r\n}\n\ncustomElements.define('pinch-zoom', PinchZoom);\n\nexport default PinchZoom;\n"],"names":["Pointer","constructor","nativePointer","this","id","pageX","pageY","clientX","clientY","self","Touch","identifier","isPointerEvent","pointerId","getCoalesced","events","getCoalescedEvents","map","p","length","event","isTouchEvent","noop","PointerTracker","_element","start","move","end","rawUpdates","avoidPointerEvents","startPointers","currentPointers","_excludeFromButtonsCheck","Set","_pointerStart","buttons","add","pointer","some","_triggerPointerStart","target","setPointerCapture","addEventListener","_rawUpdates","_move","_pointerEnd","window","_touchStart","touch","Array","from","changedTouches","has","previousPointers","slice","changedPointers","t","trackedChangedPointers","index","findIndex","push","_moveCallback","_triggerPointerEnd","splice","delete","cancelled","type","_endCallback","removeEventListener","_touchEnd","_startCallback","PointerEvent","stop","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","styleInject","minScaleAttr","getDistance","a","b","Math","sqrt","getMidpoint","getAbsoluteValue","value","max","trimRight","endsWith","parseFloat","cachedSvg","getSVG","createElementNS","createMatrix","createSVGMatrix","createPoint","createSVGPoint","MIN_SCALE","PinchZoom","HTMLElement","super","_transform","MutationObserver","_stageElChange","observe","childList","pointerTracker","_positioningEl","preventDefault","_onPointerMove","_onWheel","observedAttributes","attributeChangedCallback","name","oldValue","newValue","scale","minScale","setTransform","attrValue","getAttribute","Number","isFinite","setAttribute","String","connectedCallback","x","e","y","f","scaleTo","opts","originX","originY","relativeTo","allowChangeEvent","relativeToEl","rect","getBoundingClientRect","width","height","currentRect","left","top","_applyChange","scaleDiff","_updateTransform","thisBounds","positioningElBounds","topLeft","bottomRight","matrix","translate","multiply","inverse","matrixTransform","d","setProperty","Event","bubbles","dispatchEvent","undefined","children","console","warn","deltaY","ctrlKey","deltaMode","prevMidpoint","newMidpoint","prevDistance","newDistance","panX","panY","customElements","define"],"sourceRoot":""}
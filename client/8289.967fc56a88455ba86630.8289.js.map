{"version":3,"file":"8289.967fc56a88455ba86630.8289.js","mappings":"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","sources":["webpack:///./node_modules/emoji-picker-element/database.js"],"sourcesContent":["function assertNonEmptyString (str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str)\n  }\n}\n\nfunction assertNumber (number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number)\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\nfunction uniqEmoji (emojis) {\n  return uniqBy(emojis, _ => _.unicode)\n}\n\nfunction initialMigration (db) {\n  function createObjectStore (name, keyPath, indexes) {\n    const store = keyPath\n      ? db.createObjectStore(name, { keyPath })\n      : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, { multiEntry });\n      }\n    }\n    return store\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */ FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */ true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */ true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openIndexedDBRequests = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq (resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase (dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openIndexedDBRequests[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db\n}\n\nfunction openDatabase (dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName]\n}\n\nfunction dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n    // are really irreplaceable data. IndexedDB is just a cache in this case.\n    const txn = db.transaction(storeName, readOnlyOrReadWrite, { durability: 'relaxed' });\n    const store = typeof storeName === 'string'\n      ? txn.objectStore(storeName)\n      : storeName.map(name => txn.objectStore(name));\n    let res;\n    cb(store, txn, (result) => {\n      res = result;\n    });\n\n    txn.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    txn.onerror = () => reject(txn.error);\n  })\n}\n\nfunction closeDatabase (dbName) {\n  // close any open requests\n  const req = openIndexedDBRequests[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openIndexedDBRequests[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase (dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  })\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener (dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([\n  ':D', 'XD', \":'D\", 'O:)',\n  ':X', ':P', ';P', 'XP',\n  ':L', ':Z', ':j', '8D',\n  'XO', '8)', ':B', ':O',\n  ':S', \":'o\", 'Dx', 'X(',\n  'D:', ':C', '>0)', ':3',\n  '</3', '<3', '\\\\M/', ':E',\n  '8#'\n]);\n\nfunction extractTokens (str) {\n  return str\n    .split(/[\\s_]+/)\n    .map(word => {\n      if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n        // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase()\n      }\n\n      return word\n        .replace(/[)(:,]/g, '')\n        .replace(/’/g, \"'\")\n        .toLowerCase()\n    }).filter(Boolean)\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens (str) {\n  return str\n    .filter(Boolean)\n    .map(_ => _.toLowerCase())\n    .filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH)\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData (emojiData) {\n  const res = emojiData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {\n    const tokens = [...new Set(\n      normalizeTokens([\n        ...(shortcodes || []).map(extractTokens).flat(),\n        ...tags.map(extractTokens).flat(),\n        ...extractTokens(annotation),\n        emoticon\n      ])\n    )].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const { tone, emoji, version } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res\n  });\n  return res\n}\n\n// helper functions that help compress the code better\n\nfunction callStore (store, method, key, cb) {\n  store[method](key).onsuccess = e => (cb && cb(e.target.result));\n}\n\nfunction getIDB (store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB (store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction commit (txn) {\n  /* istanbul ignore else */\n  if (txn.commit) {\n    txn.commit();\n  }\n}\n\n// like lodash's minBy\nfunction minBy (array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n//\n\nfunction findCommonMembers (arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results\n}\n\nasync function isEmpty (db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL))\n}\n\nasync function hasData (db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL]\n    .map(key => get(db, STORE_KEYVALUE, key)));\n  return (oldETag === eTag && oldUrl === url)\n}\n\nasync function doFullDatabaseScanForSingleResult (db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 yarn build:rollup && yarn test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    let lastKey;\n\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result)\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb()\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  })\n}\n\nasync function loadData (db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore], txn) => {\n      let oldETag;\n      let oldUrl;\n      let todo = 0;\n\n      function checkFetched () {\n        if (++todo === 2) { // 2 requests made\n          onFetched();\n        }\n      }\n\n      function onFetched () {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return\n        }\n        // delete old data\n        emojiStore.clear();\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n        commit(txn);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n    });\n  } finally {\n  }\n}\n\nasync function getEmojiByGroup (db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  })\n}\n\nasync function getEmojiBySearchQuery (db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n\n  if (!tokens.length) {\n    return []\n  }\n\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1\n        ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n        : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  })\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode (db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => ((_.shortcodes || []).includes(shortcode.toLowerCase()));\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null\n  }\n\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase())\n  })[0] || null\n}\n\nasync function getEmojiByUnicode (db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => (\n    getIDB(emojiStore, unicode, result => {\n      if (result) {\n        return cb(result)\n      }\n      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n    })\n  ))\n}\n\nfunction get (db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => (\n    getIDB(store, key, cb)\n  ))\n}\n\nfunction set (db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {\n    store.put(value, key);\n    commit(txn);\n  })\n}\n\nfunction incrementFavoriteEmojiCount (db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => (\n    getIDB(store, unicode, result => {\n      store.put((result || 0) + 1, unicode);\n      commit(txn);\n    })\n  ))\n}\n\nfunction getTopFavoriteEmoji (db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return []\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], txn, cb) => {\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) { // no more results\n        return cb(results)\n      }\n\n      function addResult (result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results) // done, reached the limit\n        }\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom)\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji)\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  })\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie (arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return []\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || []\n    }\n\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) { // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results\n  };\n\n  return search\n}\n\nconst requiredKeys$1 = [\n  'name',\n  'url'\n];\n\nfunction assertCustomEmojis (customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray &&\n    customEmojis.length &&\n    (!customEmojis[0] || requiredKeys$1.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format')\n  }\n}\n\nfunction customEmojiIndex (customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => (\n    [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())]\n  );\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (\n      (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token)\n    ));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName)\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of (customEmoji.shortcodes || [])) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  }\n}\n\nconst isFirefoxContentScript = typeof wrappedJSObject !== 'undefined';\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji (emoji) {\n  if (!emoji) {\n    return emoji\n  }\n  // if inside a Firefox content script, need to clone the emoji object to prevent Firefox from complaining about\n  // cross-origin object. See: https://github.com/nolanlawson/emoji-picker-element/issues/356\n  /* istanbul ignore if */\n  if (isFirefoxContentScript) {\n    emoji = structuredClone(emoji);\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji\n}\n\nfunction warnETag (eTag) {\n  if (!eTag) {\n    console.warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys = [\n  'annotation',\n  'emoji',\n  'group',\n  'order',\n  'tags',\n  'version'\n];\n\nfunction assertEmojiData (emojiData) {\n  if (!emojiData ||\n    !Array.isArray(emojiData) ||\n    !emojiData[0] ||\n    (typeof emojiData[0] !== 'object') ||\n    requiredKeys.some(key => (!(key in emojiData[0])))) {\n    throw new Error('Emoji data is in the wrong format')\n  }\n}\n\nfunction assertStatus (response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status)\n  }\n}\n\nasync function getETag (dataSource) {\n  const response = await fetch(dataSource, { method: 'HEAD' });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag\n}\n\nasync function getETagAndData (dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData]\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n// even with --excludePrivate ¯\\_(ツ)_/¯\n/** @private */\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while (++i < length) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while (++i < length) {\n        arr[i] = binary.charCodeAt(i);\n    }\n    return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum (object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString);\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res\n}\n\nasync function checkForUpdates (db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) { // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ; else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime (db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n\n  await loadData(db, emojiData, dataSource, eTag);\n}\n\nclass Database {\n  constructor ({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init () {\n    const db = this._db = await openDatabase(this._dbName);\n\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else { // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready () {\n    const checkReady = async () => {\n      if (!this._ready) {\n        this._ready = this._init();\n      }\n      return this._ready\n    };\n    await checkReady();\n    // There's a possibility of a race condition where the element gets added, removed, and then added again\n    // with a particular timing, which would set the _db to undefined.\n    // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n    if (!this._db) {\n      await checkReady();\n    }\n  }\n\n  async getEmojiByGroup (group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji)\n  }\n\n  async getEmojiBySearchQuery (query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [\n      ...customs,\n      ...natives\n    ]\n  }\n\n  async getEmojiByShortcode (shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode))\n  }\n\n  async getEmojiByUnicodeOrName (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName))\n  }\n\n  async getPreferredSkinTone () {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0\n  }\n\n  async setPreferredSkinTone (skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone)\n  }\n\n  async incrementFavoriteEmojiCount (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName)\n  }\n\n  async getTopFavoriteEmoji (limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji)\n  }\n\n  set customEmoji (customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji () {\n    return this._custom.all\n  }\n\n  async _shutdown () {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) { /* ignore network errors (offline-first) */ }\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear () {\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close () {\n    await this._shutdown();\n    await closeDatabase(this._dbName);\n  }\n\n  async delete () {\n    await this._shutdown();\n    await deleteDatabase(this._dbName);\n  }\n}\n\nexport { Database as default };\n"],"names":["assertNonEmptyString","str","Error","assertNumber","number","DB_VERSION_CURRENT","DB_VERSION_INITIAL","STORE_EMOJI","STORE_KEYVALUE","STORE_FAVORITES","FIELD_TOKENS","INDEX_TOKENS","FIELD_UNICODE","INDEX_COUNT","FIELD_GROUP","FIELD_ORDER","INDEX_GROUP_AND_ORDER","KEY_ETAG","KEY_URL","KEY_PREFERRED_SKINTONE","MODE_READONLY","MODE_READWRITE","INDEX_SKIN_UNICODE","FIELD_SKIN_UNICODE","uniqEmoji","emojis","arr","func","set","Set","res","item","key","has","add","push","uniqBy","_","unicode","openIndexedDBRequests","databaseCache","onCloseListeners","handleOpenOrDeleteReq","resolve","reject","req","onerror","error","onblocked","onsuccess","result","async","createDatabase","dbName","db","Promise","indexedDB","open","onupgradeneeded","e","oldVersion","createObjectStore","name","keyPath","indexes","store","indexName","multiEntry","Object","entries","createIndex","undefined","initialMigration","onclose","closeDatabase","dbPromise","storeName","readOnlyOrReadWrite","cb","txn","transaction","durability","objectStore","map","oncomplete","close","listeners","listener","irregularEmoticons","extractTokens","split","word","match","toLowerCase","replace","filter","Boolean","MIN_SEARCH_TEXT_LENGTH","normalizeTokens","length","callStore","method","target","getIDB","getAllIDB","commit","findCommonMembers","arrays","uniqByFunc","shortestArray","array","minItem","i","minBy","results","some","findIndex","loadData","emojiData","url","eTag","transformedData","annotation","emoticon","group","order","shortcodes","skins","tags","emoji","version","tokens","flat","sort","skinTones","skinUnicodes","skinVersions","tone","transformEmojiData","emojiStore","metaStore","oldETag","oldUrl","todo","checkFetched","clear","data","put","onFetched","getEmojiBySearchQuery","query","intermediateResults","onDone","a","b","token","range","IDBKeyRange","bound","only","index","getEmojiByShortcode","shortcode","predicate","includes","lastKey","processNextBatch","getAll","lowerBound","doFullDatabaseScanForSingleResult","lowerShortcodes","get","CODA_MARKER","requiredKeys$1","customEmojiIndex","customEmojis","isArray","Array","firstItemIsFaulty","assertCustomEmojis","sortByName","all","searchTrie","itemToTokens","Map","currentMap","char","charAt","nextMap","valuesAtCoda","exact","queue","entriesSortedByKey","shift","value","trie","searchByExactMatch","searchByPrefix","shortcodeToEmoji","nameToEmoji","customEmoji","search","byShortcode","byName","isFirefoxContentScript","wrappedJSObject","cleanEmoji","structuredClone","len","warnETag","console","warn","requiredKeys","assertStatus","response","dataSource","Math","floor","status","getETagAndData","fetch","headers","json","assertEmojiData","jsonChecksum","object","inBuffer","binary","buf","ArrayBuffer","Uint8Array","charCodeAt","binaryStringToArrayBuffer","JSON","stringify","outBinString","buffer","bytes","byteLength","String","fromCharCode","arrayBufferToBinaryString","crypto","subtle","digest","btoa","checkForUpdates","getETag","eTagAndData","hasData","Database","constructor","locale","this","_dbName","_db","_lazyUpdate","_custom","_clear","bind","_ready","_init","addOnCloseListener","empty","isEmpty","loadDataForFirstTime","ready","checkReady","getEmojiByGroup","custom","getEmojiByUnicodeOrName","unicodeOrName","getEmojiByUnicode","getPreferredSkinTone","setPreferredSkinTone","skinTone","incrementFavoriteEmojiCount","getTopFavoriteEmoji","limit","favoritesStore","openCursor","cursor","addResult","continue","primaryKey","_shutdown","err","deleteDatabase"],"sourceRoot":""}
{"version":3,"file":"7427.ad2347c099f28a75446d.7427.js","mappings":"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","sources":["webpack:///./src/routes/_actions/filters.js","webpack:///./src/routes/_api/filters.js","webpack:///./src/routes/_api/pushSubscription.js","webpack:///./src/routes/_utils/base64.js","webpack:///./src/routes/_actions/pushSubscription.js","webpack:///./src/routes/_static/instanceSettings.js"],"sourcesContent":["import { store } from '../_store/store.js'\nimport { createFilter, getFilters, updateFilter, deleteFilter as doDeleteFilter } from '../_api/filters.js'\nimport { cacheFirstUpdateAfter, cacheFirstUpdateOnlyIfNotInCache } from '../_utils/sync.js'\nimport { database } from '../_database/database.js'\nimport { isEqual } from '../_thirdparty/lodash/objects.js'\nimport { toast } from '../_components/toast/toast.js'\nimport { formatIntl } from '../_utils/formatIntl.js'\nimport { emit } from '../_utils/eventBus.js'\n\nasync function syncFilters (instanceName, syncMethod) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  await syncMethod(\n    () => getFilters(instanceName, accessToken),\n    () => database.getFilters(instanceName),\n    filters => database.setFilters(instanceName, filters),\n    filters => {\n      const { instanceFilters } = store.get()\n      if (!isEqual(instanceFilters[instanceName], filters)) { // avoid re-render if nothing changed\n        instanceFilters[instanceName] = filters\n        store.set({ instanceFilters })\n      }\n    }\n  )\n}\n\nexport async function updateFiltersForInstance (instanceName) {\n  await syncFilters(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupFiltersForInstance (instanceName) {\n  await syncFilters(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n\nexport async function createOrUpdateFilter (instanceName, filter) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n  try {\n    if (filter.id) {\n      await updateFilter(instanceName, accessToken, filter)\n      /* no await */ toast.say(\"Updated filter\")\n    } else {\n      await createFilter(instanceName, accessToken, filter)\n      /* no await */ toast.say(\"Created filter\")\n    }\n    emit('wordFiltersChanged', instanceName)\n  } catch (err) {\n    /* no await */ toast.say(formatIntl([\"Failed to modify filter: \",[\"error\"]], err.message || ''))\n  }\n}\n\nexport async function deleteFilter (instanceName, id) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n  try {\n    await doDeleteFilter(instanceName, accessToken, id)\n    /* no await */ toast.say(\"Deleted filter\")\n    emit('wordFiltersChanged', instanceName)\n  } catch (err) {\n    /* no await */ toast.say(formatIntl([\"Failed to modify filter: \",[\"error\"]], err.message || ''))\n  }\n}\n","import { get, DEFAULT_TIMEOUT, post, WRITE_TIMEOUT, put, del } from '../_utils/ajax.js'\nimport { auth, basename } from './utils.js'\n\nexport function getFilters (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/filters`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function createFilter (instanceName, accessToken, filter) {\n  const url = `${basename(instanceName)}/api/v1/filters`\n  return post(url, filter, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n\nexport function updateFilter (instanceName, accessToken, filter) {\n  const url = `${basename(instanceName)}/api/v1/filters/${filter.id}`\n  return put(url, filter, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n\nexport function deleteFilter (instanceName, accessToken, id) {\n  const url = `${basename(instanceName)}/api/v1/filters/${id}`\n  return del(url, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n","import { auth, basename } from './utils.js'\nimport { post, put, get, del } from '../_utils/ajax.js'\n\nexport async function postSubscription (instanceName, accessToken, subscription, alerts) {\n  const url = `${basename(instanceName)}/api/v1/push/subscription`\n\n  return post(url, { subscription: subscription.toJSON(), data: { alerts } }, auth(accessToken))\n}\n\nexport async function putSubscription (instanceName, accessToken, alerts) {\n  const url = `${basename(instanceName)}/api/v1/push/subscription`\n\n  return put(url, { data: { alerts } }, auth(accessToken))\n}\n\nexport async function getSubscription (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/push/subscription`\n\n  return get(url, auth(accessToken))\n}\n\nexport async function deleteSubscription (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/push/subscription`\n\n  return del(url, auth(accessToken))\n}\n","const decodeBase64 = base64 => {\n  const rawData = window.atob(base64)\n  const outputArray = new Uint8Array(rawData.length)\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i)\n  }\n\n  return outputArray\n}\n\n// Taken from https://www.npmjs.com/package/web-push\nexport const urlBase64ToUint8Array = (base64String) => {\n  const padding = '='.repeat((4 - base64String.length % 4) % 4)\n  const base64 = (base64String + padding)\n    .replace(/-/g, '+')\n    .replace(/_/g, '/')\n\n  return decodeBase64(base64)\n}\n","import { getSubscription, deleteSubscription, postSubscription, putSubscription } from '../_api/pushSubscription.js'\nimport { store } from '../_store/store.js'\nimport { urlBase64ToUint8Array } from '../_utils/base64.js'\n\nconst dummyApplicationServerKey = 'BImgAz4cF_yvNFp8uoBJCaGpCX4d0atNIFMHfBvAAXCyrnn9IMAFQ10DW_ZvBCzGeR4fZI5FnEi2JVcRE-L88jY='\n\nexport async function updatePushSubscriptionForInstance (instanceName) {\n  const { loggedInInstances, currentPushSubscription } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  if (currentPushSubscription === null) {\n    return\n  }\n\n  const registration = await navigator.serviceWorker.ready\n  const subscription = await registration.pushManager.getSubscription()\n\n  if (subscription === null) {\n    store.setInstanceData(instanceName, 'pushSubscriptions', null)\n    store.save()\n    return\n  }\n\n  try {\n    const backendSubscription = await getSubscription(instanceName, accessToken)\n\n    // Check if applicationServerKey changed (need to get another subscription from the browser)\n    if (btoa(urlBase64ToUint8Array(backendSubscription.server_key).buffer) !== btoa(subscription.options.applicationServerKey)) {\n      await subscription.unsubscribe()\n      await deleteSubscription(instanceName, accessToken)\n      await updateAlerts(instanceName, currentPushSubscription.alerts)\n    } else {\n      store.setInstanceData(instanceName, 'pushSubscriptions', backendSubscription)\n      store.save()\n    }\n  } catch (e) {\n    // TODO: Better way to detect 404\n    if (e.message.startsWith('404:')) {\n      await subscription.unsubscribe()\n      store.setInstanceData(instanceName, 'pushSubscriptions', null)\n      store.save()\n    }\n  }\n}\n\nexport async function updateAlerts (instanceName, alerts) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  const registration = await navigator.serviceWorker.ready\n  let subscription = await registration.pushManager.getSubscription()\n\n  if (subscription === null) {\n    // We need applicationServerKey in order to register a push subscription\n    // but the API doesn't expose it as a constant (as it should).\n    // So we need to register a subscription with a dummy applicationServerKey,\n    // send it to the backend saves it and return applicationServerKey, which\n    // we use to register a new subscription.\n    // https://github.com/tootsuite/mastodon/issues/8785\n    subscription = await registration.pushManager.subscribe({\n      applicationServerKey: urlBase64ToUint8Array(dummyApplicationServerKey),\n      userVisibleOnly: true\n    })\n\n    let backendSubscription = await postSubscription(instanceName, accessToken, subscription, alerts)\n\n    await subscription.unsubscribe()\n\n    subscription = await registration.pushManager.subscribe({\n      applicationServerKey: urlBase64ToUint8Array(backendSubscription.server_key),\n      userVisibleOnly: true\n    })\n\n    backendSubscription = await postSubscription(instanceName, accessToken, subscription, alerts)\n\n    store.setInstanceData(instanceName, 'pushSubscriptions', backendSubscription)\n    store.save()\n  } else {\n    try {\n      const backendSubscription = await putSubscription(instanceName, accessToken, alerts)\n      store.setInstanceData(instanceName, 'pushSubscriptions', backendSubscription)\n      store.save()\n    } catch (e) {\n      const backendSubscription = await postSubscription(instanceName, accessToken, subscription, alerts)\n      store.setInstanceData(instanceName, 'pushSubscriptions', backendSubscription)\n      store.save()\n    }\n  }\n}\n","export const HOME_REBLOGS = 'homeReblogs'\nexport const HOME_REPLIES = 'homeReplies'\n\nexport const NOTIFICATION_REBLOGS = 'notificationReblogs'\nexport const NOTIFICATION_FAVORITES = 'notificationFavs'\nexport const NOTIFICATION_FOLLOWS = 'notificationFollows'\nexport const NOTIFICATION_MENTIONS = 'notificationMentions'\nexport const NOTIFICATION_POLLS = 'notificationPolls'\nexport const NOTIFICATION_SUBSCRIPTIONS = 'notificationSubscriptions'\n"],"names":["async","syncFilters","instanceName","syncMethod","loggedInInstances","store","get","accessToken","access_token","url","timeout","getFilters","database","filters","setFilters","instanceFilters","set","updateFiltersForInstance","setupFiltersForInstance","createOrUpdateFilter","filter","id","updateFilter","toast","say","createFilter","err","formatIntl","message","postSubscription","subscription","alerts","toJSON","data","urlBase64ToUint8Array","base64String","base64","rawData","window","atob","outputArray","Uint8Array","length","i","charCodeAt","decodeBase64","repeat","replace","dummyApplicationServerKey","updatePushSubscriptionForInstance","currentPushSubscription","registration","navigator","serviceWorker","ready","pushManager","getSubscription","setInstanceData","save","backendSubscription","btoa","server_key","buffer","options","applicationServerKey","unsubscribe","deleteSubscription","updateAlerts","e","startsWith","subscribe","userVisibleOnly","putSubscription","HOME_REBLOGS","HOME_REPLIES","NOTIFICATION_REBLOGS","NOTIFICATION_FAVORITES","NOTIFICATION_FOLLOWS","NOTIFICATION_MENTIONS","NOTIFICATION_POLLS","NOTIFICATION_SUBSCRIPTIONS"],"sourceRoot":""}
{"version":3,"file":"7323.d67cc56ecf06f52b9c26.7323.js","mappings":"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","sources":["webpack:///./src/routes/_actions/addStatusOrNotification.js","webpack:///./src/routes/_actions/emoji.js","webpack:///./src/routes/_api/emoji.js","webpack:///./src/routes/_actions/media.js","webpack:///./src/routes/_api/media.js","webpack:///./src/routes/_utils/arrays.js","webpack:///./src/routes/_utils/createSearchIndexFromStatusOrNotification.js","webpack:///./src/routes/_utils/computeFilterContextsForStatusOrNotification.js","webpack:///./src/routes/_utils/sync.js","webpack:///./src/routes/_utils/timelineItemToSummary.js"],"sourcesContent":["import { mark, stop } from '../_utils/marks.js'\nimport { store } from '../_store/store.js'\nimport { uniqBy, isEqual } from '../_thirdparty/lodash/objects.js'\nimport { database } from '../_database/database.js'\nimport { concat } from '../_utils/arrays.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { timelineItemToSummary } from '../_utils/timelineItemToSummary.js'\n\nfunction getExistingItemIdsSet (instanceName, timelineName) {\n  const timelineItemSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries') || []\n  return new Set(timelineItemSummaries.map(_ => _.id))\n}\n\nfunction removeDuplicates (instanceName, timelineName, updates) {\n  // remove duplicates, including duplicates due to reblogs\n  const existingItemIds = getExistingItemIdsSet(instanceName, timelineName)\n  return updates.filter(update => !existingItemIds.has(update.id))\n}\n\nasync function insertUpdatesIntoTimeline (instanceName, timelineName, updates) {\n  updates = removeDuplicates(instanceName, timelineName, updates)\n\n  if (!updates.length) {\n    return\n  }\n\n  await database.insertTimelineItems(instanceName, timelineName, updates)\n\n  const itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd') || []\n  console.log('itemSummariesToAdd', JSON.parse(JSON.stringify(itemSummariesToAdd)))\n  console.log('updates.map(timelineItemToSummary)', JSON.parse(JSON.stringify(updates.map(timelineItemToSummary))))\n  console.log('concat(itemSummariesToAdd, updates.map(timelineItemToSummary))',\n    JSON.parse(JSON.stringify(concat(itemSummariesToAdd, updates.map(item => timelineItemToSummary(item, instanceName))))))\n  const newItemSummariesToAdd = uniqBy(\n    concat(itemSummariesToAdd, updates.map(item => timelineItemToSummary(item, instanceName))),\n    _ => _.id\n  )\n  if (!isEqual(itemSummariesToAdd, newItemSummariesToAdd)) {\n    console.log('adding ', (newItemSummariesToAdd.length - itemSummariesToAdd.length),\n      'items to timelineItemSummariesToAdd for timeline', timelineName)\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummariesToAdd: newItemSummariesToAdd })\n  }\n}\n\nfunction isValidStatusForThread (thread, timelineName, itemSummariesToAdd) {\n  const itemSummariesToAddIdSet = new Set(itemSummariesToAdd.map(_ => _.id))\n  const threadIdSet = new Set(thread.map(_ => _.id))\n  const focusedStatusId = timelineName.split('/')[1] // e.g. \"status/123456\"\n  const focusedStatusIdx = thread.findIndex(_ => _.id === focusedStatusId)\n  return status => {\n    const repliedToStatusIdx = thread.findIndex(_ => _.id === status.in_reply_to_id)\n    return (\n      // A reply to an ancestor status is not valid for this thread, but for the focused status\n      // itself or any of its descendents, it is valid.\n      repliedToStatusIdx >= focusedStatusIdx &&\n      // Not a duplicate\n      !threadIdSet.has(status.id) &&\n      // Not already about to be added\n      !itemSummariesToAddIdSet.has(status.id)\n    )\n  }\n}\n\nasync function insertUpdatesIntoThreads (instanceName, updates) {\n  if (!updates.length) {\n    return\n  }\n\n  const threads = store.getThreads(instanceName)\n  const timelineNames = Object.keys(threads)\n  for (const timelineName of timelineNames) {\n    const thread = threads[timelineName]\n\n    const itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd') || []\n    const validUpdates = updates.filter(isValidStatusForThread(thread, timelineName, itemSummariesToAdd))\n    if (!validUpdates.length) {\n      continue\n    }\n    const newItemSummariesToAdd = uniqBy(\n      concat(itemSummariesToAdd, validUpdates.map(item => timelineItemToSummary(item, instanceName))),\n      _ => _.id\n    )\n    if (!isEqual(itemSummariesToAdd, newItemSummariesToAdd)) {\n      console.log('adding ', (newItemSummariesToAdd.length - itemSummariesToAdd.length),\n        'items to timelineItemSummariesToAdd for thread', timelineName)\n      store.setForTimeline(instanceName, timelineName, { timelineItemSummariesToAdd: newItemSummariesToAdd })\n    }\n  }\n}\n\nasync function processFreshUpdates (instanceName, timelineName) {\n  mark('processFreshUpdates')\n  const freshUpdates = store.getForTimeline(instanceName, timelineName, 'freshUpdates')\n  if (freshUpdates && freshUpdates.length) {\n    const updates = freshUpdates.slice()\n    store.setForTimeline(instanceName, timelineName, { freshUpdates: [] })\n\n    await Promise.all([\n      insertUpdatesIntoTimeline(instanceName, timelineName, updates),\n      insertUpdatesIntoThreads(instanceName, updates.filter(status => status.in_reply_to_id))\n    ])\n  }\n  stop('processFreshUpdates')\n}\n\nfunction lazilyProcessFreshUpdates (instanceName, timelineName) {\n  scheduleIdleTask(() => {\n    /* no await */ processFreshUpdates(instanceName, timelineName)\n  })\n}\n\nexport function addStatusOrNotification (instanceName, timelineName, newStatusOrNotification) {\n  addStatusesOrNotifications(instanceName, timelineName, [newStatusOrNotification])\n}\n\nexport function addStatusesOrNotifications (instanceName, timelineName, newStatusesOrNotifications) {\n  console.log('addStatusesOrNotifications', Date.now())\n  let freshUpdates = store.getForTimeline(instanceName, timelineName, 'freshUpdates') || []\n  freshUpdates = concat(freshUpdates, newStatusesOrNotifications)\n  freshUpdates = uniqBy(freshUpdates, _ => _.id)\n  store.setForTimeline(instanceName, timelineName, { freshUpdates })\n  lazilyProcessFreshUpdates(instanceName, timelineName)\n}\n","import {\n  cacheFirstUpdateAfter,\n  cacheFirstUpdateOnlyIfNotInCache\n} from '../_utils/sync.js'\nimport { database } from '../_database/database.js'\nimport { getCustomEmoji } from '../_api/emoji.js'\nimport { store } from '../_store/store.js'\nimport { isEqual } from '../_thirdparty/lodash/objects.js'\n\nasync function syncEmojiForInstance (instanceName, syncMethod) {\n  await syncMethod(\n    () => {\n      const { loggedInInstances } = store.get()\n      const accessToken = loggedInInstances[instanceName].access_token\n      return getCustomEmoji(instanceName, accessToken)\n    },\n    () => database.getCustomEmoji(instanceName),\n    emoji => database.setCustomEmoji(instanceName, emoji),\n    emoji => {\n      const { customEmoji } = store.get()\n      if (!isEqual(customEmoji[instanceName], emoji)) { // avoid triggering updates if nothing's changed\n        customEmoji[instanceName] = emoji\n        store.set({ customEmoji })\n      }\n    }\n  )\n}\n\nexport async function updateCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n\nexport function insertEmoji (realm, emoji) {\n  const emojiText = emoji.unicode || `:${emoji.name}:`\n  const { composeSelectionStart } = store.get()\n  const idx = composeSelectionStart || 0\n  const oldText = store.getComposeData(realm, 'text') || ''\n  const pre = oldText.substring(0, idx)\n  const post = oldText.substring(idx)\n  const newText = `${pre}${emojiText} ${post}`\n  store.setComposeData(realm, { text: newText })\n}\n","import { auth, basename } from './utils.js'\nimport { DEFAULT_TIMEOUT, get } from '../_utils/ajax.js'\n\nexport function getCustomEmoji (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/custom_emojis`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","import { store } from '../_store/store.js'\nimport { uploadMedia } from '../_api/media.js'\nimport { toast } from '../_components/toast/toast.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { formatIntl } from '../_utils/formatIntl.js'\nimport { database } from '../_database/database.js'\n\nexport async function doMediaUpload (realm, file) {\n  const { currentInstance, accessToken, maxStatusMediaAttachments } = store.get()\n  store.set({ uploadingMedia: true })\n  try {\n    let composeMedia = store.getComposeData(realm, 'media') || []\n    if (composeMedia.length === maxStatusMediaAttachments) {\n      throw new Error('Only ' + maxStatusMediaAttachments + ' media max are allowed')\n    }\n    const response = await uploadMedia(currentInstance, accessToken, file)\n    composeMedia = store.getComposeData(realm, 'media') || []\n    if (composeMedia.length === maxStatusMediaAttachments) {\n      throw new Error('Only ' + maxStatusMediaAttachments + ' media max are allowed')\n    }\n    await database.setCachedMediaFile(response.id, file)\n    composeMedia.push({\n      data: response,\n      file: { name: file.name },\n      description: ''\n    })\n    store.setComposeData(realm, {\n      media: composeMedia\n    })\n    scheduleIdleTask(() => store.save())\n  } catch (e) {\n    console.error(e)\n    /* no await */ toast.say(formatIntl([\"Failed to upload media: \",[\"error\"]], { error: (e.message || '') }))\n  } finally {\n    store.set({ uploadingMedia: false })\n  }\n}\n\nexport function deleteMedia (realm, i) {\n  const composeMedia = store.getComposeData(realm, 'media')\n  composeMedia.splice(i, 1)\n\n  store.setComposeData(realm, {\n    media: composeMedia\n  })\n  if (!composeMedia.length) {\n    const contentWarningShown = store.getComposeData(realm, 'contentWarningShown')\n    const contentWarning = store.getComposeData(realm, 'contentWarning')\n    store.setComposeData(realm, {\n      sensitive: contentWarningShown && contentWarning // reset sensitive if the last media is deleted\n    })\n  }\n  scheduleIdleTask(() => store.save())\n}\n","import { auth, basename } from './utils.js'\nimport { post, put, MEDIA_WRITE_TIMEOUT, WRITE_TIMEOUT } from '../_utils/ajax.js'\n\nasync function doUploadMedia (version, instanceName, accessToken, file, description) {\n  const formData = new FormData()\n  formData.append('file', file)\n  if (description) {\n    formData.append('description', description)\n  }\n  const url = `${basename(instanceName)}/api/${version}/media`\n  return post(url, formData, auth(accessToken), { timeout: MEDIA_WRITE_TIMEOUT })\n}\n\nasync function doPutMediaMetadata (version, instanceName, accessToken, mediaId, description, focus) {\n  const url = `${basename(instanceName)}/api/${version}/media/${mediaId}`\n  return put(url, { description, focus: (focus && focus.join(',')) }, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n\nexport async function uploadMedia (instanceName, accessToken, file, description) {\n  try {\n    return (await doUploadMedia('v2', instanceName, accessToken, file, description))\n  } catch (err) {\n    if (err && err.status === 404) { // fall back to old v1 API\n      return doUploadMedia('v1', instanceName, accessToken, file, description)\n    } else {\n      throw err\n    }\n  }\n}\n\nexport async function putMediaMetadata (instanceName, accessToken, mediaId, description, focus) {\n  try {\n    return (await doPutMediaMetadata('v2', instanceName, accessToken, mediaId, description, focus))\n  } catch (err) {\n    if (err && err.status === 404) { // fall back to old v1 API\n      return doPutMediaMetadata('v1', instanceName, accessToken, mediaId, description, focus)\n    } else {\n      throw err\n    }\n  }\n}\n","// Merge two arrays, using the given comparator\nexport function mergeArrays (leftArray, rightArray, comparator) {\n  let leftIndex = 0\n  let rightIndex = 0\n  const merged = []\n  while (leftIndex < leftArray.length || rightIndex < rightArray.length) {\n    if (leftIndex === leftArray.length) {\n      merged.push(rightArray[rightIndex])\n      rightIndex++\n      continue\n    }\n    if (rightIndex === rightArray.length) {\n      merged.push(leftArray[leftIndex])\n      leftIndex++\n      continue\n    }\n    const left = leftArray[leftIndex]\n    const right = rightArray[rightIndex]\n    const comparison = comparator(right, left)\n    if (comparison === 0) {\n      merged.push(left)\n      rightIndex++\n      leftIndex++\n    } else if (comparison > 0) {\n      merged.push(right)\n      rightIndex++\n    } else {\n      merged.push(left)\n      leftIndex++\n    }\n  }\n  return merged\n}\n\nexport function concat () {\n  let res = []\n  for (let i = 0, len = arguments.length; i < len; i++) {\n    const arg = arguments[i]\n    if (Array.isArray(arg)) {\n      res = res.concat(arguments[i])\n    } else {\n      res.push(arguments[i])\n    }\n  }\n  return res\n}\n","let domParser\n\n// copy-pasta'd from\n// https://github.com/tootsuite/mastodon/blob/2ff01f7/app/javascript/mastodon/actions/importer/normalizer.js#L58-L75\nexport const createSearchIndexFromStatusOrNotification = statusOrNotification => {\n  const status = statusOrNotification.status || statusOrNotification // status on a notification\n  const originalStatus = status.reblog || status\n  domParser = domParser || new DOMParser()\n  const spoilerText = originalStatus.spoiler_text || ''\n  const searchContent = ([spoilerText, originalStatus.content]\n    .concat(\n      (originalStatus.poll && originalStatus.poll.options)\n        ? originalStatus.poll.options.map(option => option.title)\n        : []\n    ))\n    .join('\\n\\n').replace(/<br\\s*\\/?>/g, '\\n').replace(/<\\/p><p>/g, '\\n\\n')\n  return domParser.parseFromString(searchContent, 'text/html').documentElement.textContent\n}\n","import { createSearchIndexFromStatusOrNotification } from './createSearchIndexFromStatusOrNotification.js'\n\nexport function computeFilterContextsForStatusOrNotification (statusOrNotification, contextsToRegex) {\n  if (!contextsToRegex || !Object.keys(contextsToRegex).length) {\n    // avoid computing the search index, just bail out\n    return undefined\n  }\n  // the searchIndex is really just a string of text\n  const searchIndex = createSearchIndexFromStatusOrNotification(statusOrNotification)\n  const res = Object.entries(contextsToRegex)\n    .filter(([context, regex]) => regex.test(searchIndex))\n    .map(([context]) => context)\n\n  // return undefined instead of a new array to reduce memory usage of TimelineSummary\n  return res.length ? res : undefined\n}\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n","import { computeFilterContextsForStatusOrNotification } from './computeFilterContextsForStatusOrNotification.js'\nimport { store } from '../_store/store.js'\n\nclass TimelineSummary {\n  constructor (item, instanceName) {\n    this.id = item.id\n    this.accountId = item.account.id\n    this.replyId = (item.in_reply_to_id) || undefined\n    this.reblogId = (item.reblog && item.reblog.id) || undefined\n    this.quoteId = item.quote_id || undefined\n    this.type = item.type || undefined\n\n    // This is admittedly a weird place to do the filtering logic. But there are a few reasons to do it here:\n    // 1. Avoid computing html-to-text (expensive) for users who don't have any filters (probably most users)\n    // 2. Avoiding keeping the entire html-to-text in memory at all times for all summaries\n    // 3. Filters probably change infrequently. When they do, we can just update the summaries\n    const { unexpiredInstanceFilterRegexes } = store.get()\n    const contextsToRegex = unexpiredInstanceFilterRegexes[instanceName]\n    this.filterContexts = computeFilterContextsForStatusOrNotification(item, contextsToRegex)\n  }\n}\n\nexport function timelineItemToSummary (item, instanceName) {\n  return new TimelineSummary(item, instanceName)\n}\n"],"names":["removeDuplicates","instanceName","timelineName","updates","existingItemIds","timelineItemSummaries","getForTimeline","Set","map","_","id","getExistingItemIdsSet","filter","update","has","async","insertUpdatesIntoTimeline","length","insertTimelineItems","itemSummariesToAdd","JSON","parse","stringify","item","newItemSummariesToAdd","setForTimeline","timelineItemSummariesToAdd","isValidStatusForThread","thread","itemSummariesToAddIdSet","threadIdSet","focusedStatusId","split","focusedStatusIdx","findIndex","status","in_reply_to_id","insertUpdatesIntoThreads","threads","getThreads","timelineNames","Object","keys","validUpdates","lazilyProcessFreshUpdates","freshUpdates","slice","Promise","all","s","processFreshUpdates","addStatusOrNotification","newStatusOrNotification","addStatusesOrNotifications","newStatusesOrNotifications","Date","now","syncEmojiForInstance","syncMethod","loggedInInstances","store","get","accessToken","access_token","url","timeout","getCustomEmoji","database","emoji","setCustomEmoji","customEmoji","set","updateCustomEmojiForInstance","setupCustomEmojiForInstance","insertEmoji","realm","emojiText","unicode","name","composeSelectionStart","idx","oldText","getComposeData","newText","substring","setComposeData","text","doMediaUpload","file","currentInstance","maxStatusMediaAttachments","uploadingMedia","composeMedia","Error","response","setCachedMediaFile","push","data","description","media","save","e","console","error","say","message","deleteMedia","i","splice","contentWarningShown","contentWarning","sensitive","doUploadMedia","version","formData","FormData","append","doPutMediaMetadata","mediaId","focus","join","uploadMedia","err","putMediaMetadata","mergeArrays","leftArray","rightArray","comparator","leftIndex","rightIndex","merged","left","right","comparison","concat","res","len","arguments","arg","Array","isArray","domParser","createSearchIndexFromStatusOrNotification","statusOrNotification","originalStatus","reblog","DOMParser","searchContent","spoiler_text","content","poll","options","option","title","replace","parseFromString","documentElement","textContent","computeFilterContextsForStatusOrNotification","contextsToRegex","searchIndex","entries","context","regex","test","undefined","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","fetchAndUpdatePromise","then","networkResponse","cacheFirstUpdateOnlyIfNotInCache","TimelineSummary","constructor","this","accountId","account","replyId","reblogId","quoteId","quote_id","type","unexpiredInstanceFilterRegexes","filterContexts","timelineItemToSummary"],"sourceRoot":""}